---
title: 【代码大全2】04 语句 Statements
date: 2018-09-01 10:41:22
tags:
categories:
- Programming
---

## 第14章 组织直线型代码 Organizing straight-line code
组织直线型代码最主要原则是按照依赖关系进行排列。
### 必须有顺序明确的语句 Statements that must be in a specific order
组织语句的原则：
- 设法组织代码，使依赖关系变得非常明显
- 使子程序名能突显依赖关系
- 利用子程序参数明确显示依赖关系
- 用注释对不清晰的依赖关系进行说明
- 用断言或错误处理代码来检查依赖关系

### 顺序无关的语句 Statements whose order doesn't matter
缺少顺序执行的依赖关系时，按照就近原则(principle of proximity)：把相关的操作放在一起。
- 使代码易于自上而下地阅读。把对每一个对象的引用都放在一起，使它们“局部化(localized)”，对象“存活(live)”的代码行数非常少。
- 把相关的语句组织在一起。一些语句之所以相关，是因为它们都处理相同的数据，执行了类似的任务，或者具有某种执行顺序上的依赖关系。

<!-- more -->
## 第15章 使用条件语句 Using conditionals
### if 语句 if statements
简单 if-then 语句的指导原则：
- 首先写正常代码路径，再处理不常见的情况。在编写代码时，要使得正常情况的执行路径在代码中时清晰的；确认那些不常见的情况不会影响正常的执行路径。
- 确保对于等量的分支是正确的
- 把正常情况的处理放在 if 后面而不要放在 else 后面，这符合把决策的结果代码放在尽可能靠近决策位置的一般原则。
- 让 if 后面跟随一个有意义的语句。不要使用空的 if 语句，然后把处理逻辑放在 else 子句中。
- 考虑 else 子句。若编写空的 else 子句或无 else 子句，需要用注释来说明原因。
- 测试 else 子句的正确性。
- 检查 if 和 else 子句是不是弄反了。

if-then-else 语句串的指导原则：
- 使用布尔函数调用简化复杂的检测
- 把最常见的情况放在最前面
- 确保所有的情况都考虑到了
- 如果语言支持字符串、枚举和逻辑函数的 case 语句，可代替 if-then-else 语句

### case 语句
case 语句随着编程语言的不同而有很大差异，C++ 和 Java 只支持在 case 语句中使用整型类型，并且一次只能取一个值。
case 语句的指导原则：
- 为 case 选择最有效的排列顺序。
  - 如果所有情况的重要性相同，按字母顺序或数字书奴排列各种情况。
  - 把正常的情况放在前面，添加注释说明正常情况和非正常情况。
  - 按执行频率排列 case 子句。
- 简化每种情况对应的操作，使得与每种情况相关的代码短小精悍。如果某种情况执行的操作非常复杂，考虑写一个子程序。
- 不要为了使用 case 语句而刻意制造一个变量。case 语句应该用于处理简单的、容易分类的数据，如果数据并不简单，那么使用 if-then-else 语句串更好。
- 把 default 子句只用来检查真正的默认情况。
- 利用 default 子句来检测错误。**如果 case 语句中的默认子句既没有用来做其他处理，按照正常执行顺序也不可能发生，那么就向里面加入一条诊断消息**。
- 避免代码执行越过一条 case 子句的末尾。必须明确地为每一条 case 子句写结束语句(break 语句)。
- 若必须要让代码越过 case 子句的末尾，则在 case 末尾明确无误地标明需要穿越执行的程序流程，解释清楚为什么这么做。


## 第16章 控制循环 Controlling loops
### 循环种类 Selecting the kind of loop
- 计数循环(counted loop)：执行的次数是一定的。
- 连续求值的循环(continuously evaluated loop)：预先并不知道将要执行多少次，它会在每次迭代时检查是否应该结束。
- 无限循环(endless loop)：一旦启动就会一直执行下去。
- 迭代器循环(iterator loop)：对容器类里面的每个元素执行一次操作。

while 循环：如果预先不知道循环要迭代多少次，那么就使用 while 循环。while 循环可以放在循环开始处(while)或者结尾处(do-while)做检测。

for 循环：如果执行次数固定，那么就使用 for 循环。

foreach 循环：适用于对数组或者其他容器的各项元素执行操作。它的优势在于消除了循环内务处理算术，从而也消除了任何由循环控制算术导致出错的可能性。

带退出的循环：使用 break 语句来实现。把所有的退出条件尽量放在一处；用注释来阐明操作意图。

### 控制循环 Controlling the loop
把循环内部当成一个子程序来看待，把控制尽可能地放到循环体外。
#### 进入循环 Entering the loop
- 只从一个位置进入循环，即循环头部。
- 把初始化代码进放在循环前面。就近原则主张把相关的语句放在一起。
- 用 while(true) 表示无限循环。或者 for ( ; ; ) 。
- 在适当的情况下多使用 for 循环。for 循环把循环的控制代码集中在一起，从而有助于写成可读性强的循环。while 循环顶部的循环初始化代码和循环底部的相关代码容易修改遗漏。
- 在 while 循环更合适时，不要使用 for 循环。for 循环的优势在于能够更加灵活地表现所能使用的初始化信息和终止信息的种类。这种灵活性所固有的不足之处在于，可以把与控制循环无关的语句放在循环头里面。

#### 处理好循环体 Processing the middle of the loop
- 任何时候都要用 { 和 } 把循环中的语句括起来。
- 避免空循环。

```c++
//空循环
while ( (inputChar = dataFile.getChar() ) != CharType_Eof ) {
    ;
}

//将空循环改造为有循环体的循环
do {
    inputChar = dataFile.getChar();
} while (inputChar != CharType_Eof);
```
- 把循环内务操作要么放在循环的开始，要么放在循环的末尾。循环内务操作(housekeeping)是指像 i = i + 1 或者 j++ 这样的表达式，其主要目的不是完成循环工作，而是控制循环。
- **每个循环只做一件事并且把它做好**。如果用两个循环会导致效率低下，而使用一个循环很合适，那么还是先把代码写成两个循环，并注明可以把它们合并起来以提高效率，然后等测量数据显示程序的这一部分性能低下的时候再去合并它们。

#### 退出循环 Exiting the loop
- 设法确认循环能够终止
- 使循环终止条件看起来很明显
- 不要为了终止循环而胡乱改动 for 循环的下标
- 避免出现依赖于循环下标最终取值的代码。在循环终止后仍使用循环下标是很不好的，更好的并且更具描述性的做法是，在循环体内适当的地方把这一最终取值赋给某个变量。

```c++
//滥用循环下标
for ( recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {
    if ( entry[ recordCount ] == testValue ) {
        break;
    }
}
if ( recordCount < MAX_RECORDS) {
    return ( true );
} else {
    return ( false );
}

//多加一个变量，并对 recordCount 的引用变得更加局部化
found = false;
for ( recordCount = 0; recordCount < MAX_RECORDS; recordCount++ ) {
    if ( entry[ recordCount ] == testValue ) {
        found = true;
        break;
    }
}
return ( found );
```
- 考虑使用安全计数器。安全计数器是一个变量，你在每次循环之后都递增它，以便判断该循环的执行次数是不是过多。使用安全计数器同时也会增加复杂度。

```c++
safetyCounter = 0;
do {
    node = node->next;

    safetyCounter++;
    if (safetyCounter >= SAFETY_LIMIT) {
        ASSERT( false, "Internal Error: safety-counter violation." );
    }
} while ( node->next != NULL )
```

提前退出循环：
break 语句时循环通过正常的退出渠道退出，程序会从循环后面的第一条语句开始执行下去。
而 continue 语句不会让程序从循环中退出，而是让程序跳过循环体的余下部分，从该循环下一次迭代的开始位置继续执行。
- 考虑在循环中使用 break 语句而不用布尔标记来实现退出循环体
- 小心那些很多的 break 散步其中的循环。在大量使用 break 的场合中，用一系列的循环而非一个含有多个出口的循环可能会使表达更为清晰。
- 在循环开始处用 continue 进行判断。
- 如果语言支持，使用带标号 break 结构。在 Java 中支持使用带标号的 break 语句(labeled break)，使退出目标一目了然。
- 使用 break 和 continue 时要小心谨慎。使用 break 消除了把循环看作是黑盒子的可能性，使用 break 就使阅读代码的人必须去读循环体，才能理解循环是如何控制的。

#### 检查端点 Checking endpoints
对于任何一个循环，需要注意三种情况：开始的情况，任意选择的中间情况，以及最终的情况。

#### 使用循环变量 Using loop variables
- 用整数或枚举类型来表示数组和循环的边界。通常来说，循环计数器应该是整数。浮点数递增时会有问题。
- 在嵌套循环中使用有意义的变量名来提高可读性。
- 用有意义的名字来避免下标串话(cross-talk)。
- 把循环下标变量的作用域限制在本循环内。

#### 循环应该有多长 How long should a loop be
- 循环要尽可能地短，以便能够一目了然
- 把嵌套限制在 3 层以内
- 把长循环的内容移到子程序里
- 要让长循环格外清晰

### 创建循环：由内而外 Creating loops: From the inside out
从具体事件入手，在同一时间只考虑一件事，从简单的部分开始创建循环。在开发更通用、更复杂循环的过程中，你迈的步子要小，并且每一步的目的要明确清晰。

### 循环与数组 Correspondence between loops and arrays
在许多情况下，循环就是用来操纵数组的，而且循环计数器和数组下标一一对应。


## 第17章 不常见的控制结构 Unusual control structures
### 子程序中多处返回 Multiple returns from a routine
多数语言都提供了某种半途退出子程序的方法。程序通过 return 和 exit 这类控制结构，在任何需要的时候推出子程序，并把控制权转交给调用方子程序。
使用 return 语句的指导原则：
- 如果能增强可读性，那么就使用 return。
- 用卫语句(guard clause)(早返回或早退出)来简化复杂的错误处理。如果代码中必须在执行正常操作前做大量的错误条件检测，就很可能导致代码的缩紧层次过深，并且遮蔽正常情况的执行路径。在这种情况下，先检查错误情况，用这些代码来为正确的执行路径**清路**。若错误情况为真时，立刻从当前子程序中退出。
- 减少每个子程序中 return 的数量。

### 递归 Recursion
在递归里面，一个子程序负责解决某个问题的一小部分，把问题分解成许多小块，然后调用来分别解决每一小块。当问题的小部分容易解决，而问题的大部分也很容易分解成众多的小部分时，可用递归。
递归并不常用，对于小范围内的问题，使用使用递归会带来简单、优雅的解。对于稍大一些范围，使用递归会带来简单、优雅但是难懂的解。有选择地使用递归。
编写递归子程序的关键目标之一是：**防止产生无限递归**。
使用递归的技巧：
- 确认递归能够停止。必须检查子程序以确认其中含有一条非递归的路径。
- 使用安全计数器防止出现无穷递归。
- 把递归限制在一个子程序中。循环递归非常危险，因为它难以检查。
- 留心栈空间。用了递归以后，将无法保证你的程序会使用多少栈空间，也很难预料程序在运行期间会表现得怎么样。使用以下步骤来控制程序在运行期间的表现：
  - 如果使用了安全计数器，那么在给它设置上限时需要考虑，你愿意给递归子程序分配多少栈空间，要把它的上限设置为足够低，防止栈溢出。
  - 观察递归函数中局部变量的分配情况，特别留意那些内存消耗较大的对象。要用 new 在堆上创建对象，而不妖让编译器在栈上自动创建对象。
- 不要使用递归去计算阶乘或者斐波那契数列。用递归写出的子程序要比用循环写出的子程序更难理解。

最重要的，在用递归之前，先考虑递归的替换方案。你用递归能做到的，同样也可以用栈和循环来做到。

### goto
不要使用 goto。

### 针对不常见控制结构的观点
- goto 标号
- 可变的子程序入口点
- 自修改代码

注重灵活方便而忽视结构和复杂度管理的结构，必须存在于程序员的垃圾堆里。


## 第18章 表驱动法 Table-driven methods
表驱动法是一种编程模式(scheme)，即从表里查找信息而不是用逻辑语句(if 和 case)。事实上，凡事能通过逻辑语句来选择的事物，都可以通过查表来选择。
对于简单的情况，使用逻辑语句更为容易和直白；随着逻辑链越来越复杂，查表法也就愈发显得更具吸引力。
### 表驱动法使用总则 General considerations in using table-driven methods
**把程序中的信息存放在数据里而不是逻辑里**。
使用表驱动法的两个问题：
- 怎样从表中查询条目
- 在表里面存放什么数据

### 直接访问表 Direct access tables
直接访问表是指无须绕很多复杂的圈子就能够在表里面找到需要的信息。
通过构造查询表键值来实现直接访问：
- 复制信息从而能够直接使用键值。该方法的缺点在于，复制生成的冗余信息会浪费空间。
- 转换键值以使其能够直接使用。创建转换函数，从作为键值的数据中识别出某种模式来。
- 把键值转换提取成独立子程序。把从数据到键值的转换操作提取成独立的子程序。

### 索引访问表 Indexed access tables
索引表不是直接访问，而是通过居中的索引去访问。
当使用索引时，先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查处你感兴趣的主数据。
索引访问技术的优点：
- 如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的索引数组所用的空间，就要比创建一个浪费了很多空间的主查询表所用的空间小得多。
- 即使你用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便更廉价。
- 表查询技术在可维护性上的普遍优点，即编写到表里面的数据比嵌入到代码中的数据更容易维护。

### 阶梯访问表
阶梯结构的基本想法是：表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。
阶梯方法通过确定每项命中的阶梯层次确定其归类，它命中的“台阶”确定其类属。
阶梯访问表的优点在于适合处理无规则的数据。
使用阶梯技术时需注意：
- 留心端点。确认你已经考虑到每一个阶梯区间的上界。
- 考虑用二分查找来取代顺序查找。
- 考虑使用索引访问来取代阶梯技术。即以牺牲存储空间来换取速度。
- 把阶梯表查询操作提取成单独的子程序。


## 第19章 一般控制问题 General control issues
### 布尔表达式 Boolean expressions
除了最简单的、要求语句按顺序执行的控制结构以外，所有的控制结构都依赖于布尔表达式的求值(evaluation)。

#### 用 true 或 false 做布尔判断 Using true and false for boolean tests
在布尔表达式中应该使用标识符 true 和 false，而不要用 0 和 1 等数值。如果语言不支持，那么就用预处理宏或者全局变量来创建它们。
隐式地比较布尔值与 true 和 false。表达式具有值语义，将其当作布尔表达式，可以写出更清晰的判断语句。

#### 简化复杂的表达式 Making complicated expressions simple
- 拆分复杂的判断并引入新的布尔变量。把中间执行结果赋值给新的变量。
- 把复杂的表达式做成布尔函数。可以清晰地在代码中说明该逻辑判断的目的。
- 用决策表(desicion-table)来代替复杂的条件。

#### 编写肯定形式的布尔表达式 Forming boolean expressions positively
- 在 if 语句中，把判断条件从否定形式转换为肯定形式，并且互换 if 和 else 子句中的代码。或者，可以给变量换一个名字，以表达判断真值的反义。
- 用德·摩根定理(De Morgan's laws)来简化否定的布尔判断。

```java
//否定型判断
if ( !displayOK || !printOK ) {

}

//应用德摩根定理
if ( !( displayOK && printOK) ) {

}
```

| 原表达式 | 等价表达式 | 
| :--- | :--- | 
| not A and not B  | not (A or B) | 
| not A and B | not(A or not B) | 
| A and not B  | not(not A or B) | 
| A and B | not (not A or not B) | 
| not A or not B | not (A and B) | 
| not A or B | not(A and not B) |
| A or not B| not(not A and B) |
| A or B | not (not A and not B) |

#### 用括号使布尔表达式更清晰 Using parentheses to clarify boolean expressions
把布尔表达式全括在括号里，改善可读性，避免依赖于所用语言的求职顺序。
#### 理解布尔表达式是如何求值的 Knowing how boolean expressions are evaluated
一些语言的编译器会先计算布尔表达式中每个项的值，然后再把这些项组合起来求出整个表达式的值。一些语言的编译器采用“短路(short-circuit)”或者“惰性(lazy)”求值，只求出那些必须的部分。
更好的做法是：使用嵌套的判断语言来明确你的用意，而不要依赖于求职顺序和短路求值。
#### 按照数轴顺序编写数值表达式 Writing numeric expressions in number-line order
组织数值判断，使其顺序与数轴上的点排列顺序相符。
#### 与 0 比较的指导原则 Guidelines for comparisons to 0
- 隐式地比较逻辑变量

```c
if ( !done )
```
- 显式地与数值做比较

```c 
if (balance != 0)
```
- 在 C 中显式地比较字符和零终止符('\0')。

```c
while ( *charPtr != '\0') 
```
- 把指针与 NULL 相比较

```c
while ( bufferPtr != NULL )
```
#### 布尔表达式的常见问题 Common problems with boolean expressions
- 应该把常量放在比较的左端。将常量放在等号的左侧，编译器会捕获这个错误。
- 在 C++ 中，考虑创建预处理宏来替换 &&(AND)， ||(OR)和 ==(EQUALS)。
- 在 Java 中，a == b 判断的是 a 和 b 是不是引用了同一对象，而 a.equals(b) 判断的是两个对象是否具有相同的值。


### 复合语句(语句块) Compound statements (blocks)
复合语句或语句块是指一组语句，用于控制程序流。在 C++、Java 中，可以通过在一组语句的外面括上 { 和 } 来创建复合语句。
- 把括号对一起写出
- 用括号来把条件表达清楚

### 空语句 NULL statements
空语句，即一条仅含有分号的语句。
- 小心使用空语句。让空语句中的分号自占一行，并且加以缩进，强调该空语句。
- 为空语句创建一个 doNothing() 预处理宏或者内联函数或者子程序。
- 考虑如果换用一个非空的循环体，是否会让代码更清晰。空循环体代码的产生多数都是为了利用循环控制代码的副作用(side effects)。

### 驯服危险的深层嵌套 Taming dangerously deep nesting
避免深层嵌套(避免使用超过 3 到 4 层的嵌套)的方法：
- 通过重复检测条件中的某一部分来简化嵌套的 if 语句。但不能无偿地减少嵌套，对应地，你必须要容忍使用一个更复杂的判断。
- 把嵌套 if 转换成一组 if-then-else 语句。
- 把嵌套的 if 转换成 case 语句。
- 把深层嵌套的代码抽取出来放进单独的子程序。
- 使用面向对象的多态机制进行分派，调用对象工厂方法(object factory)。

### 编程基础：结构化编程 A programming foundation: structured programming
结构化编程的核心思想：一个应用程序应该只采用一些单入单出的控制结构。即一个代码块，只能从一个位置开始执行，并且只能结束于一个位置，除此之外，再无其他入口或出口。
一个结构化的程序按照一种有序的且有规则的方式执行，不会做不可预知的随便跳转。

结构化编程的三个组成部分：
- 顺序(sequence)。顺序是指一组按照先后顺序执行的语句。
- 选择(selection)。选择是一种有选择的执行语句的控制结构。
- 迭代(iteration)。迭代是一种使一组语句多次执行的控制语句。

结构化编程的中心论点是：任何一种控制流都可以由顺序、选择、迭代三种结构生成。

对于三种标准的结构化编程结构之外的任何控制结构的使用，即使用 break、continue、return、throw-catch，都要持一种批判的态度。

### 控制结构与复杂度 Control structures and complexity
程序的复杂度的一个衡量标准是：为了理解应用程序，你必须在同一时间内记住的智力实体的数量。
程序的复杂度在很大程度上决定了理解程序所需要花费的精力。
“有能力的程序员会充分地认识到自己的大脑容量是多么地有限，所在，他会非常谦卑地处理编程任务”(Dijkstra 1972)。

#### 如何度量复杂度 How to measure complexity
采用 Tom McCabe 方法，通过计算子程序中的决策点(decision points)的数量来衡量复杂度。
- 从 1 开始，一直往下通过程序。
- 一旦遇到以下关键字，或者同类的词，就加1： if、while、repeat、for、and、or。
- 给 case 语句中的每一种情况都加 1。

分析子程序的复杂度：
- 0 - 5：子程序可能还不错
- 6 - 10：得想办法简化子程序了
- 10+：把子程序的某一部分拆分成另一个子程序并调用它

把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点转移到其他地方，但是这样做可以降低在同一时间内必须关注的复杂度水平。














## 参考
[1] Steve, McConnell 著, 金戈, 汤凌, 陈硕, & 张菲. (2011). 代码大全(第2版). 电子工业出版社.