---
title: 【代码大全2】03 变量 Variables
date: 2018-08-25 23:35:25
tags:
categories:
- Programming
---

## 第10章 使用变量的一般事项 General issues in using variables
利用构建活动来填补需求和架构中存在的细小间隙是一种行之有效的做法。
### 变量声明 Declaration
指导原则：
- 关闭隐式声明。有些语言支持隐式变量声明，但是这是最具危险性的特性之一。
- 声明全部变量。
- 遵循某种命名规则。
- 检查变量名。

### 变量初始化 Initialization
不合理的变量初始化所导致的一系列问题都源于变量的默认初始值与你的预期不同。以下行为都会导致此类问题：
- 从未对变量赋值。它的值只是程序启动时变量所处内存区域的值。
- 变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效。
- 变量的一部分被赋值，而另一部分没有。

<!-- more -->
避免初始化错误的建议：
- 在声明变量时初始化。

```c++
float studentGrades[ MAX_STUDENTS ] = { 0.0 };
```
- 在靠近变量第一次使用的位置初始化。对于不支持在声明变量的同时初始化的语言（如 VB）。这就是就近原则(principle of proximity)，即把相关的操作放在一起。
- **在理想情况下（如 C++， Java 等语言），在靠近第一次使用变量的位置声明和定义该变量**。
- 在可能的情况下使用 final(在 Java 中) 或 const(在 C++ 中)声明变量。防止该变量在初始化后再被赋值。final 和 const 关键字在定义类常量(class constants)、输入参数以及任何初始化后其值不再改变的局部变量时非常有用。
- 特别注意计数器(counter)和累加器(accumulator)。i、j、k、sum、total等变量，在下一次使用前务必重置其值。
- 在类的构造函数里初始化类的数据成员。如果在构造函数中分配了内存，那么就应该在析构函数中释放这些内存。
- 检查是否需要重新初始化，当初始化语句位于那些重复执行的代码内部。
- **一次性初始化具名常量，用可执行代码来初始化变量**。
- 利用编译器的警告信息。对未经过初始化的变量会发出警告。
- 检查输入参数的合法性。由输入参数来初始化工作变量。
- 使用内存访问检查工具来检查错误的指针。
- 在程序开始时初始化工作内存。把工作内存(working memory)初始化一个已知数值将会有助于发现初始化错误。使用内存填充工具(memory filler)把程序的工作内存填充为一个可预料的值。

### 变量作用域 Scope
作用域或者可见性(visibility)指的是变量在程序内的可见和可引用的范围。
使用作用域的规则：
- 使变量引用局部化(localize references to variables)。那些介于同一变量多个引用点之间的代码可称为“攻击窗口(window of vulnerability)”，可能会有新代码加到这种窗口中，不当地修改这个变量。使变量引用局部化，即**把引用点尽可能地集中在一起**。衡量一个变量的不同引用点的靠近程度的一种方法是计算该变量的“跨度(span)”。

```java
a = 0;
b = 0;
c = 0;
b = a + 1;
b = b / c;

//b第1次和第2次引用的跨度为1，第2次和第3次引用跨度为0，平均跨度为0.5
```
- 尽可能缩短变量的存活时间(keep variables live for as short a time as possible)。存活时间是一个变量存在期间所跨越的语句总数。变量的存活时间开始于引用它的第一条语句，结束于引用它的最后一条语句。保持短的存活时间也是为了减少攻击窗口。

减小作用域的一般原则：
- 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。
- 直到变量即将被使用时再为其赋值。让变量的赋值位置越明显越好。
- 把相关语句放到一起。
- 把相关语句提取成单独的子程序。
- **开始时采用最严格的可见性，然后根据需要扩展变量的作用域**。

### 持续性 Persistence
持续性是对一项数据的生命期的另一种描述。持续性具有多种形态：
- 特定代码段或子程序的生命期。在 C++ 和 Java 中 的 for 循环里声明的变量。
- 只要你允许，它就会持续下去。在 Java 中用 new 创建的变量会一直持续到它成为垃圾被回收为止，在 C++ 中，用 new 创建的变量会一直持续到你 delete 掉它。
- 程序的生命期。大多数语言的全局变量都属于这一类，在 C++ 和 Java 里的 static 变量也是如此。
- 永远持续。数据库，文件保留的数据。

避免数据的持续性失效的措施：
- 在程序中加入调试代码或断言来检查那些关键变量的合理取值。如不合理，就发出警告信息。
- 准备抛弃变量时给它们赋上“不合理的数值”。比如在删除一个指针后把它的值设为 null。
- 编写代码时要假定数据并没有持续性。例外是 C++ 和 Java 中的 static 变量在子程序多次调用间维护其值。
- 养成在使用所有数据前声明和初始化的习惯。

### 绑定时间 Binding time
绑定时间是把变量和它的值绑定在一起的时间。
采用越晚的绑定时间会越有利。绑定时间越晚，你的代码里就包含了越多的可能性。早期绑定会降低灵活性，但有助于减小复杂度。晚期绑定可以增加灵活性，但同时增加了复杂度。
```java
//a. 在编写代码时绑定其值
titleBar.color = 0xFF; //0xFF is hex value for color blue

//0xFF 是硬编码(hard-code)在程序里的数值
//一旦要改动 0xFF，那么这个新值就无法同代码里其他那些必须和它一样的 0xFF 值保持一致了。

//b. 在编译时绑定其值
private static final int COLOR_BLUE = 0xFF;
private static final int TITLE_BAR_COLOR = COLOR_BLUE;

titleBar.color = TITLE_BAR_COLOR;

//TITLE_BAR_COLOR 是一个具名常量，编译器会在编译的时候把它替换为一个数值
//增加了可读性，一处改动就能对所有位置生效，也不影响运行期的性能

//c. 在运行时绑定其值
titleBar.color = readTitleColor();

//更具可读性和灵活性，无需通过修改程序来改变赋值，只需要修改子程序要读取的数据源内容即可，常用于交互式应用程序。
```
变量与数值相绑定的时间：
- 编码时(使用魔鬼数字)
- 编译时(使用具名常量)
- 加载时(从外部数据源中读取数据)
- 对象实例化时(比如每次窗体创建时读取数据)
- 即时(比如每次窗体重绘时读取数据)

### 数据类型与控制结构之间的关系 Relationship between data types and control structures
数据类型与控制结构之间以一种定义明确的方式相互结合。
- 序列型数据翻译为顺序结构。序列型数据(sequential data)是由一些按照特定顺序使用的数据组成，你的程序中必须有负责从从文件中读取这些序列型数据的一系列语句。
- 选择型数据翻译为选择结构(if-else 和 case 语句等)。选择型数据(selective data)指的是一组数据，这些数据在任一特定时刻有且仅有一项被使用。
- 迭代型数据翻译为循环结构(for 和 while等)。迭代型数据(iterative data)是需要反复进行操作的同类型数据。

### 为变量指定单一用途 Using each variable for exactly one purpose
实施建议：
- 每个变量只用于单一用途。当两个场合下使用同一个“临时”变量时，会引起不适当。
- 避免让代码具有隐含意义。**把同一变量用于多个用途的另一种方式是当变量代表不同事物时让其具有不同的取值集合**。这种滥用被称为“混合耦合(hybrid coupling)”。应使用两个变量来保存两种信息，能带来更多的清晰度，同时，没有人吝惜你多用的那一点存储空间。
- 确保使用了所有已声明的变量。

## 第11章 变量名的力量 The power of variable names
**代码阅读的次数远远多于编写的次数，确保你所取的名字更侧重于阅读方便而不是编写方便**。

### 选择好变量名的注意事项 Considerations in choosing good names
- 为变量命名时最重要的考虑事项是：该名字要完全、准确地描述出该变量所代表的事物。
- 以问题为导向。一个好记的名字反映的通常都是问题，而不是解决方案。即表达的是“什么(what)”，而不是“如何(how)”。
- 控制最适当的名字长度，一般地，变量名的平均长度在 10 到 16 个字符时，调试程序所需花费的气力是最小的，关键是确保名字含义足够清晰。
- 变量名对作用域的影响，较长的名字适用于很少用到的变量或全局变量，较短的名字适用于局部变量或循环变量。对于全局命名空间的名字加以限定词或者带有子系统特征的前缀。
- 变量名中的计算值限定词，通常把限定词加到名字的最后。一致性可以提高可读性，简化维护工作。限定词包括 Total, Sum, Count, Average, Max, Min, Record, Index 等等。
- 使用对仗词来提高命名的一致性。

### 为特定类型的数据命名 Naming specific types of data
#### 为循环下标命名 Naming loop indexes
使用 i, j, k 这些名字是约定俗成的。
如果一个变量要在循环体之外使用，那么就应该命名一个更有意义的名字。
如果使用了嵌套循环，那就应该给循环变量赋予更有意义的更具描述性的名字。
#### 为状态变量命名 Naming status variables
为状态变量去一个比 flag 更好的名字，标记应该使用枚举类型、具名常量或者用做具名常量的全局变量来对其赋值。
#### 为临时变量命名 Naming temporary variables
警惕“临时”变量，临时性地保存一些值常常是很有必要的，而程序的大多数变量都是临时性的，被赋予 temp，x，没有反映出该变量的功能，而应该使用准确的而且具有描述性的变量名来解释其用途。
#### 为布尔变量命名 Naming boolean variables
- 谨记典型的布尔变量名：
  - **done** 用 done 表示某件事情已经完成。事情完成之前把 done 设置为 false，在事情完成之后设置为 true。
  - **error** 用 error 表示有错误发生。在错误发生之前把变量值设置为 false，在错误已经发生时设置为 true。
  - **found** 用 found 来表明这个值已经找到了。在没有找到该值的时候把 found 设置为 false，一旦找到该值就把 found 设置为 true。
  - **success 或 ok** 用 success 或 ok 来表明一项操作是否成功。在操作失败时把该变量设置为 false，在操作成功时设置为 true。
- 给布尔变量赋予隐含“真假”含义的名字。
- 使用肯定的布尔变量名。如有需要则用适当的运算符求反。

#### 为枚举类型命名 Naming enumerated types
在使用枚举类型时，可以通过使用组前缀来明确表示该类型的成员都同属于一个组。
在某些编程语言中，枚举成员总是被冠以枚举名字前缀，那么可省略组前缀。
#### 为常量命名 Naming constants
在具名常量时，应该根据常量表示的含义为其命名。

### 命名规则的力量 The power of naming conventions
**规则的存在为你的代码增加了结构，减少了你需要考虑的事情**。
- 要求个人更多地按规矩行事
- 有助于项目之间传递知识
- 有助于快速学习代码
- 有助于减少名字增生
- 弥补编程语言的不足之处
- 强调相关变量之间的关系

### 非正式命名规则 Informal naming conventions
#### 与语言无关的命名规则
- 区分变量名和子程序名字
- 区分类和对象
  - 通过大写字母开头区分类型和变量
  - 通过给类型加“t_”前缀区分类型和变量
  - 通过给变量加“a”前缀区分类型和变量
  - 通过对变量采用更明确的名字区分类型和变量
- 标识全局变量。在全局变量名之前加上“g_”前缀。
- 标识成员变量。根据名字识别出变量是类的数据成员，既不是局部变量，也不是全局变量，在成员变量名之前加上“m_”前缀。
- 标识类型声明。C++ 惯用方法是把类型名全部大写，适用于 typedef 和 struct，不适用于类名。为类名增加“t_”前缀。
- 标识具名常量。给具名常量名增加“c_”前缀。 C++ 和 Java 里的规则是全部用大写，以及如有可能使用下划线来分隔单词。
- 标识枚举类型的元素。全部用大写，或者为类型名前增加“e_”或“E_”前缀，同时为该类型的成员增加基于特定类型的前缀。
- 在不能保证输入参数只读的语言里标识只读参数。在 C++ 中分别使用 * 、& 和 const 指明。
- 格式化命名以提高可读性。使用大小写和分隔符这两种方法来分隔单词，勿要混用。

#### 与语言相关的命名规则
##### C 语言
- c 和 ch 是字符变量
- i 和 j 是整数下标
- n 表示某物的数量
- p 是指针
- s 是字符串
- 预处理宏全部大写
- 变量名和子程序名全部小写
- 下划线用做分隔符

##### C++ 语言
- i 和 j 是整数下标
- p 是指针
- 常量、typedef、和预处理宏全部大写
- 类和其他类型的名字混合大小写
- 类变量和函数名中的第一个单词小写，后续每个单词首字母大写
- 不把下划线用做名字中的分隔符，除非用于全部大写的名字以及特定的前缀中

##### Java 语言
- i 和 j 是整数下标
- 常量全部大写，并用下划线分隔
- 类名和接口中的每一个单词的首字母均大写，包括第一个单词
- 变量名和方法名中的第一个单词首字母小写，后续单词的首字母大写
- 除用于全部大写的名字之外，不使用下划线作为名字中的分隔符
- 访问器子程序使用 get 和 set 前缀。

#### 命名规则
变量名包含了三类信息：
- 变量的内容（它代表了什么）
- 变量的种类（具名常量、简单变量、用户自定义类型、类）
- 变量的作用域（私用的、类的、包的、全局作用域）

### 标准前缀 Standardized prefixes
对具有通用含义的前缀标准化，为数据命名提供了一种简洁、一致并且可读性好的方法。
#### 用户自定义类型缩写 User-defined type abbreviations
UDT缩写可以标识被命名对象或变量的数据类型。

| UDT 缩写 | 含义 | 
| :---: | :--- | 
| ch  | 字符(character) | 
| doc | 文档(document) | 
| pa  | 段落(paragraph) | 
| scr | 屏幕区域(screen region) | 
| sel | 选中范围(selection) | 
| wn  | 窗体(window) |


#### 语义前缀
语义前缀描述变量或对象是如何使用的。

| 语义前缀 | 含义 |
| :------: |:------ |
| c | 数量(count) |
| first | 数组中需要处理的第一个元素 |
| g | 全局变量(global variable) |
| i | 数组下标(index into an array) |
| last | 数组中需要处理的最后一个元素 |
| lim | 数组中需要处理的元素的上限，通常 lim = last + 1 |
| m | 类的成员变量 |
| max | 数组或其他种类列表中的最大的一个元素 |
| min | 数组或其他种类列表中的最小的一个元素 |
| p | 指针(pointer) |

### 创建具备可读性的短名字 Creating short names that are readable
缩写的指导原则：
- 使用标准的缩写
- 去掉所有非前置元音。（computer -> cmpt, screen -> scrn, integer -> intgr）
- 去掉虚词(and, or, the)。
- 使用每个单词的第一个或前几个字母
- 统一地在每个单词的第一、第二、或第三个字母后截断
- 保留每个单词的第一个和最后一个字母
- 使用名字中的每一个重要单词，不超过三个
- 去掉无用的后缀(ing, ed)。
- 保留每个音节中最引人注意的发音
- 确保不改变变量的含义
- 反复使用以上技术，直到把每个变量名的长度缩减到 8 到 20 个字符。

### 应该避免的名字 Kinds of names to avoid
指导原则：
- 避免使用令人误解的名字或缩写
- 避免使用具有相似含义的名字
- 避免使用具有不同含义单却有相似名字的变量
- 避免使用发音相近的名字
- 避免在名字使用数字。**如果名字中的数字真的非常重要，考虑使用数组来代替一组单个的变量**。
- 避免在名字中拼错单词
- 避免使用英语中常常拼错的单词
- 不要仅靠大小写来区分变量名
- 避免使用多种自然语言，应该一种英文版本为标准，以便你不用在代码中应该使用 color 还是 colour，check 还是 cheque 等感到迷惑
- 避免使用标准类型、变量、子程序的名字
- 不要使用与变量含义完全无关的名字
- **避免在名字中包含易混淆的字符**


## 第12章 基本数据类型 Fundamental data types
基本数据类型是构建其他所有数据类型的构造块(building blocks)。

### 数值概论 Numbers in general
使用数的注意事项：
- 避免使用魔鬼数字(magic number)。魔鬼数字是在程序中出现的、没有经过解释的数值字面量(literal numbers)。应使用具名常量来代替该数值。
- 如有需要，可以使用硬编码的 0 和 1。主要用于增量、减量和从数组的第一个元素开始循环。经验法则：**程序主体中仅能出现的文字量就是 0 和 1，任何其他文字量都应该换成更有描述性的表示**。
- 预防除零(divide-by-zero)错误。必须考虑表达式的分母为 0 的情况。
- 使类型转换变得明显。
- 避免混合类型的比较。
- 注意编译器的警告。

### 整数 Integers
使用整数的注意事项：
- 检查整数除法。补救办法是重新安排表达式的顺序，以最后执行除法运算。
- 检查整数溢出。考虑清楚算数表示式中的每个项，设想每项可能达到的最大值，以及程序在未来的扩展。
- 检查中间结果溢出。考虑换一种更长的整型或浮点类型。

### 浮点数 Floating-point numbers
使用浮点数的注意事项：
- 避免数量级相差巨大的数之间的加减运算。解决方案是：如果你必须把一系列差异如此巨大的数相加，那么就先对这些数排序，然后从最小值开始把它们加起来，使得“舍入问题”的影响减到最低限度。
- 避免等量判断。替代对浮点数执行等量判断的方案是：先确定可接受的精度范围，然后用布尔函数判断数值是否足够接近。
- 处理舍入误差问题。解决方案：
  - 换用一种精确度更高的变量类型。单精度浮点数换成双精度浮点数。
  - 换用二进制编码的十进制(binary code decimal, BCD)变量。BCD模式的处理通常更慢，并且要占用更多的存储空间，但是能防止很多舍入错误的发生。
  - 把浮点变量变成整型变量。比如处理人民币中的元角分。
- 检查语言和函数库对特定数据类型的支持。

### 字符和字符串 Characters and strings
使用字符和字符串的注意事项：
- 避免使用魔鬼字符和魔鬼字符串。
- 避免偏差一(off-by-one)错误。因为字符串的下标索引几乎与数组相同。
- 了解所使用的语言和开发环境是如何支持 Unicode 的。在 Java 中所有的字符串都是 Unicode 的，在 C 和 C++ 中，常常需要在 Unicode 和其他字符集之间进行转换。
- 在程序生命期中尽早决定国际化/本地化策略。决定是否把所有字符串保存在外部资源里，是否为每一种语言创建单独的版本，或者在运行时确定特定的界面语言。
- 如果只需要支持一种文字的语言，请考虑使用 ISO 8859 字符集。(ISO-8859-1编码是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。Latin1是ISO-8859-1的别名。因为ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。换言之，把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。这是个很重要的特性，MySQL数据库默认编码是Latin1就是利用了这个特性。ASCII编码是一个7位的容器，ISO-8859-1编码是一个8位的容器。)
- 如果需要支持多种语言，请考虑使用 Unicode 字符集。Unicode 对国际字符集提供了全面的支持。
- 采用某种一致的字符串类型转换策略。把程序中所有字符串都保存为一种格式，同时在尽可能靠近输入和输出的位置将字符串转换为其他格式。

C语言中的字符串(Strings in C)注意事项：
- 注意字符串指针(string pointer)和字符数组(character array)之间的差异。
  - 警惕任何包含字符串和等号的表达式。

```c
char *stringPtr = "Some Text String";

//在这种情况下，"Some Text String"是一个指向字面量字符串的指针，
//赋值操作的结果是：让 stringPtr 指针指向该字面量字符串，
//并没有将字符串的内容拷贝给 stringPtr。
```
  - 通过命名规则区分变量是字符数组还是字符串指针。常见规则：用“ps”前缀来标识字符串指针，用“ach”前缀来标识字符数组。
- 把 C风格(C-style)字符串的长度声明为 CONSTANT + 1。在使用 C 风格字符串时，很容易忘记长度为 n 的字符串需要 n+1 字节的存储空间，从而忘记为空结束符(位于字符串的最后取值为0的字节)预留空间。使用具名常量来声明所有字符串的长度。

```c
#define NAME_LENGTH 10

/* a Good Declaration of a Character Array */
char name[ NAME_LENGTH + 1] = { 0 }; /* string of length NAME_LENGTH */

int i;
for (i = 0; i < NAME_LENGTH; i++) {
    name[ i ] = 'A';
}

strncpy(name, some_other_name, NAME_LENGTH);
```
- 用 null 来初始化字符串以避免没有终止的字符串。C 语言通过查找空结束符，即字符串末尾取值为 0 的字节，来判断字符串的末尾。只要没有找到空结束符，则认为字符串还没有结束。避免无终止的字符串：
  - 在声明数组时把它初始化为 0。如上例所示。
  - 在动态分配字符串时，使用 calloc() 而不是 malloc()来把它初始化为 0。calloc() 负责分配内存，并把它初始化为 0；malloc() 只分配内存，并不执行初始化。
- 用字符数组来取代 C 中的指针。有助于避免指针错误。

### 布尔变量 Boolean variables
- 对使用布尔变量的程序加以文档说明。
- 用布尔变量来简化复杂的判断。

```java
//目的不明确的布尔判断
if ((elementIndex < 0) || (MAX_ELEMENTS < elementsIndex) ||
    (elementIndex == lastElementIndex)) {
    //...
}

//目的明确的布尔判断
finished = ((elementIndex < 0) || (MAX_ELEMENTS < elementsIndex));
repeatedEntry = (elementIndex == lastElementIndex);
if (finished || repeatedEntry) {
    //...
}
```
- 如有需要的话，创建你自己的布尔类型。在 C 语言中没有预定义的布尔类型。

```c
typedef int BOOLEAN;

//或者
enum Boolean {
    True = 1,
    False = (!True)
};

//把变量声明为 Boolean 而非 int，可以让其用途更为明显，使程序不言自明
```

### 枚举类型
- 用枚举类型来提高可读性。
- 用枚举类型来提高可靠性。
- 用枚举类型来简化修改。
- **将枚举类型作为布尔变量的替换方案**。布尔变量往往无法充分表达它所需要表达的含义。
- 检查非法数值。常用于 case 语句捕捉非法值。
- 定义出枚举的第一项和最后一项，以便用于循环边界。

```c
enum Country_Code {
    Country_First = 0,
    Country_China = 0,
    Country_England = 1,
    Country_France = 2,
    Country_American = 3,
    Country_Japan = 4,
    Country_Last = 4
};
```
- 明确定义项目代码编写标准中第一个和最后一个元素的使用规则，并且在使用时保持一致。
- 警惕给枚举元素明确赋值而带来的失误。

如果你的语言中没有枚举类型，可以使用全局变量或类来模拟。
```java
class Country () {
    private Country () {}

    public static final Country China = new Country();
    public static final Country England = new Country();
    public static final Country France = new Country();
    public static final Country Japan = new Country();
    //...
}
```

### 具名常量 Named constants
使用具名常量是将程序“参数化”的方法，即把程序中可能变化的一个方面写为一个参数，当需要对其修改时，只改动一处就可以了，而不必在程序中到处改动。这种“单点控制(single-point control)”是减少维护工作量的好技术。
- 在数据声明中使用具名常量。提高可读性和可维护性。
- 避免使用字面量。
- **用具有适当作用域的变量或类来模拟具名常量**。优先选择局部作用域，其次是类作用域，再次是全局作用域。
- 统一地使用具名常量。

### 数组 Arrays
一个数组中含有一组类型完全相同，并且可以用数组下标来直接访问的条目(数组的元素的可以随机访问)。
- 确认所有的数组下标都没有超出数组的边界。
- 考虑用容器来取代数组，或者只将数组作为顺序化结构来处理。
  - 永远不要随机地访问数组，只能顺序地访问。在数组里随机访问就像在程序里随便使用的 goto 语句一样，这种访问很容易变得难于管理且容易出错，要证明其是否正确也很困难。
  - 使用集合、栈、队列等按顺序存取元素的数据结构来取代数组。
- 检查数组的边界点。
- 如果数组是多维的，确认下标的使用顺序是否是正确的。
- 提防下标串话(cross-talk)。
- 在 C 语言中结合 ARRAY_LENGTH() 宏来使用数组，取代具名常量来表示数组大小的上限。

```c
#define ARRAY_LENGTH(x) (sinzeof(x)/sizeof(x[0]))

ConsistencyRatios[] = 
    { 0.0, 0.0, 0.58, 0.90, 1.12,
    1.24, 1.32, 1.41, 1.45, 1.49 };

for ( ratioIdx = 0; ratioIdx < ARRAY_LENGTH( ConsistencyRatios ); ratioIdx++ ) {
    //...
}

```

### 创建你自己的类型(类型别名) Creating your own types （Type Aliasing)
自定义数据类型是语言所能赋予的一种最强有力的、最有助于澄清你对程序理解的功能之一，它保护你的程序免受预料之外更改的困扰，并使程序更容易阅读。C，C++ 支持用户自定义类型。
创建自定义类型的原因：
- 易于修改
- 避免过多的信息分发。**采用硬编码而非集中在一处管理数据的方式会导致数据类型的细节散布于程序内部**。
- 增加可靠性
- 弥补语言的不足

创建自定义类型的指导原则：
- 给所创建的类型取功能导向的名字。避免使用那些代表底层计算机数据类的类型名，应该用能代表新类型所表现的现实世界问题的类型名。创建自定义类型的最大优点在于它提供了介于你的程序和实现语言之间的一层绝缘层。
- 避免使用预定义类型。
- 不要重定义一个预定义的类型。改变一个标准类型的定义会引起混淆。
- 定义替代类型以便于移植。为标准类型定义替代类型，以便于让变量在不同的硬件平台上正确地代表相同的实体。
- **考虑创建一个类而不是使用 typedef**。简单的 typedef 对隐藏变量的底层类型信息是大有帮助的，然而，在一些情况下，你可能需要定义类来获得那些额外的灵活度和控制力。

## 第13章 不常见的数据类型 Unusual data types
### 结构体 Structures
结合体是指使用其他类型组建的数据。C 和 C++ 中的 struct。在 Java 和 C++ 里当类完全由公用的数据成员组成而不包含公用子程序时也表现得像结构体一样。
使用结构体的理由：
- 用结构体来明确数据关系。结构体把相关联的一组数据项聚集在一起。
- 用结构体简化对数据块的操作。对结构体执行操作比对各元素执行同样的操作要容易得多，并且更可靠，且只需更少的代码。
- 用结构体来简化参数列表。把相关的元素组织到一个结构体里，然后把它作为一个整体传递。
- 用结构体来减少维护。

### 指针 Pointers
#### 理解指针 Paradigm for understanding pointers
每一个指针都包含两部分：内存中的某处位置，以及如何解释该位置中的内容。
内存中的一个位置就是一个地址，常用 16 进制形式表示。指针本身只包含这个地址，为了使用该指针所指向的数据，就必须访问该地址，解释该位置处的的内容。
**如何解释内容中某个位置的内容，是由指针的基类型(base type)决定的**。如果某指针指向整数，编译器会把该指针所指向内存位置的数据解释为一个整数。**内存并不包含任何与之相关联的内在解释，只有通过使用一个特定类型的指针，一个特殊位置的比特才能解释为有意义的数据**。
#### 使用指针的一般技巧 Ceneral tips on pointers
当通过一个坏了的指针变量赋值时，会把数据写入本不该写值的内存区域，这称为“内存破坏(memory corruption)”。有时内存破坏会导致可怕、严重的系统崩溃；有时它会篡改程序其他部分的计算结果；有时它会致使你的程序不可预知地跳过某些子程序；而有时候它又什么事情都没做。
使用技巧：
- 把指针操作限制在子程序或者类里面。减少访问指针代码位置的数量，为指针操作编写子程序，进行集中控制。
- 同时声明和定义指针。在靠近变量声明的位置为该变量赋初始值。
- 在与指针分配相同的作用域中删除指针。**要保持指针分配和释放操作的对称性**。
- 在使用指针之前检查指针。确保所指向的内存位置是合理的。
- 先检查指针所指向的数据再使用它。
- **用标记字段来检测损毁的内存**。标记字段(tag field)是指加入结构体内的一个仅仅用于检测错误的字段。在分配一个变量时，把一个应该保持不变的数值放在标记字段中，当使用该结构时，特别是释放其内存时，检测这个标记字段的取值，如果与预期不相符，那么这一数据已被破坏。在删除指针的时候，就破坏了这个字段。把标记字段放置在所分配的内存区域的开始位置，能够检查是否多执行了释放该内存的操作，而无须去维护一个包含你所分配的全部内存区域的列表。把标记字段放置在内存区域的结束位置，能够让你检查是否做过超出该内存块末尾的覆盖数据操作。检查标记字段，有助于找到产生问题的根源。
- 增加明显的冗余。代替标记字段的方案可通过对某些特定字段重复两次，如果位于冗余字段中的数据不匹配，那么就可以确定数据已经被破坏了。
- **用额外的指针变量来提高代码清晰度**。一定不要节约使用指针变量，也不要把同一个变量用于多种用途。

```c++
//一般地双向链表插入节点
void insertLink (
    Node *currentNode, 
    Node *insertNode
    ) {
    //insert insertNode after currentNode
    insertNode->next = curentNode->next;
    insertNode->previous = currentNode;
    current->next = insertNode;
    if (currentNode->next != NULL) {
        currentNode->next->previous = insertNode;
    }
}

//更具可读性的节点插入
void insertLink (
    Node *startNode,
    Node *newMiddleNode
    ) {
    //insert newMiddleNode between startNode and followingNode
    Node *followingNode = startNode->next;
    newMiddleNode->next = followingNode;
    newMiddleNode->previous = startNode;
    startNode->next = newMiddleNode;
    if (followingNode != NULL) {
        followingNode->privious = newMiddleNode;
    }
}
```
- 简化复杂的指针表达式。考虑把它赋给一个命名良好的变量，以明确该操作的用意。
- 画一个图。用图表来解释指针链接步骤。
- 按照正确的顺序删除链表中的指针。在释放当前指针之前，确保已经有指向链表中下一个元素的指针。
- 分配一片保留的内存后备区域。如果在程序中使用动态内存，就需要避免发生程序忽然用尽了内存，把你的用户和用户的数据丢在 RAM 空间里的尴尬场景。避免此类错误的方式是预先分配一片内存后备区域。设法确定程序为了保存所做的工作，执行清理并体面地退出需要多少内存，在程序初始化阶段就把这部分内存分配出来作为后备。一旦用光了内存，就释放保留下来的后备区，执行清理工作，然后退出。
- 粉碎垃圾数据。在释放内存区域之前用垃圾数据来覆盖这些内存区域，可以让使用已释放的指针的错误的表现方式更一致。
- 在删除或释放指针之后把他们设为空值。悬空指针(dangling pointer)错误是指使用一个已经被 delete 或 free 的指针。
- 在删除变量之前检查非法指针。防止重复释放已经 delete 或 free 掉的指针。

```c++
//在删除指针前断言其不为 NULL
ASSERT( pointer != NULL, "Attempting to delete null pointer");
//强制让释放的内存包含垃圾数据
memset( pointer, GARBAGE_DATA, MemoryBloackSize( pointer ) );
//在删除指针后再将其设为 NULL
delete pointer;
pointer = NULL;
```
- 跟踪指针分配情况。维护一份已分配的指针的列表，在释放一个指针前检查它是不是位于列表里面。

```c++
ASSERT( pointer != NULL, "Attempting to delete null pointer" );
if ( isPointerInList( pointer ) ) {
    memset( pointer, GARBAGE_DATA, MemoryBloackSize( pointer ) );
    removePointerFromList( pointer );
    delete pointer;
    pointer = NULL;
} else {
    ASSERT( FALSE, "Attempting to delete unallocated pointer" );
}
```
- 编写覆盖子程序，集中实现避免指针问题的策略。通常对常见的指针操作编写覆盖子程序(cover routine)，可以减少编程的工作量，并且降低错误几率。比如 C++ 中，最常见的指针分配和删除：
  - SAFE_NEW 调用 new 来分配指针，把这一新的指针加入已分配指针列表中，然后把这一新分配的指针返回给调用方子程序。它还可以在该子程序中检查 new 操作的返回值是否为空或者抛出异常(如是否发生内存不足的错误)，从而简化了程序其他部分的错误处理。
  - SAFE_DELETE 检查传递的指针是否在已分配指针的列表里，如果在列表里，就把该指针所指向的内存设置为垃圾数据，把该指针从列表中移除，再调用 C++ 的 delete 运算符释放该指针，并且把指针设为空值。若指针不在列表里，那么该子程序将打印一条诊断信息，并且终止程序的运行。

#### C++ 指针
- 理解指针和引用的区别。在 C++ 中，指针(*)和引用(&)都能够间接地引用对象，字面上的差异，ptr->filed 和 ref.field 不同，最重要的区别是：引用必须总是引用一个对象，而指针可以指向空值；引用所指向的对象在该引用初始化之后不能改变。
- 把指针用于“按引用传递(pass by reference)”参数，把 const 引用用于“按值传递(pass by value)”参数。C++ 向子程序传递参数的默认方式是传递值，当以传递值的方式向一个子程序传递一个对象时，C++ 创建了该对象的一份拷贝。为避免复制该对象需要按引用来传递。但有时又希望不能修改传入的对象，即具有传值的语义，通过 const 引用来实现按值传递。

```c++
void routine (
    const LARGE_OBJECT &nonModifiableOject,
    LARGE_OBECT *modifiableObject
);
//这种方法的好处：在被调用子程序里对可修改和不可修改的对象做了语法上的区分。在可修改的对象里，对象引用使用 object->member 的表示法；对不可修改的对象，成员引用使用 object.member 的表示法。
//这种方法的局限性：const 引用难以传播。
```
- 灵活运用智能指针。

#### C 指针
- 使用显式指针类型而不是默认类型。C 允许对任何类型的变量使用 char 或者 void 指针，C 语言只关心这类指针有所指向，不会去关心它所指向的内容是什么。当你必须进行类型转换时就要使用显式类型转换。

```c
NodePtr = (NODE_PTR) calloc (1, sizeof( NODE ));
```
- 避免强制类型转换(type casting)。强制类型转换将一种类型的变量挤压入另一个类型变量的空间，关闭了编译器检查类型不符的功能。
- 遵循参数传递的星号规则。在 C 语言中，只有当你在赋值语句的参数前加了星号，才能把该参数从子程序中传回去。

```c
//不奏效
void tryToPassPackAValue (int *parameter) {
    parameter = SOME_VALUE;
}

//奏效
void tryToPassBackAValue (int *parameter) {
    *parameter = SOME_VALUE;
}
```
- 在内存分配时使用 sizeof() 确定变量的大小。由于 sizeof() 是在编译期间计算的，因此不会带来性能上的损失；而且它是可以移植的，需要维护工作也很少。


### 全局数据 Global data
与全局数据相关的常见问题：
- 无意间修改了全局数据，然后错误地认为它在其他位置还是保持不变的。
- 别名(aliasing)问题。两个或者过个不同名字，指向同一变量。
- 代码重入(re-entrant)问题。多线程代码使得全局数据将不但在多个子程序之间共享，而且也将在同一程序的不同拷贝之间共享。这就必须确保即使一个程序的多个拷贝同时运行，全局数据也要保持其意义。
- 阻碍代码复用。使用了全局数据的子程序无法简单地插入新的程序里。
- 非确定的初始化顺序问题。如果一个文件中的全局变量使用了另一个不同文件中的全局变量，就必须有明确的措施来确保这两个变量能按照正确的顺序初始化。
- 全局数据破坏了模块化和可管理性。

使用全局数据的理由：
- 保存全局数值
- 模拟具名常量
- 模拟枚举类型
- 简化对极其常用的数据的使用
- 消除流浪数据

只有万不得已时才使用全局数据：
- **首先把每一个变量设置为局部的，仅当需要时才把变量设置为全局的**。
- 区分全局变量和类变量
- 创建访问器子程序

访问器子程序的优势：
- 对数据集中控制
- 信息隐藏
- 转变抽象数据类型

如何使用访问器子程序：
- 要求所有代码通过访问器子程序来存取数据。要求所有的全局数据冠以 g_ 前缀，并且除了该变量的访问器子程序以外，所有的代码都不可以访问具有 g_ 前缀的变量。

```vb
g_globalStatus;

globalStatus.get();
globalStatus.set();
```
- 不要把所有的全局数据都扔在一处。考虑每一个全局数据都属于哪个类，然后把该数据和它的访问器子程序以及其他的数据和子程序打包放入那个类里面。
- 用锁定来控制对全局变量的访问。锁定要求在使用或者更新一个全局变量值之前，该变量必须被签出(check out)。在用完这一变量之后再把它签入(check in)回去。在使用期间，如果程序的其他部分尝试要将它 check out，那么锁定/解锁子程序就会显示一条错误信息，或者触发一个断言。
- 在访问器子程序中里构建一个抽象层。要在问题域这一层次构建抽象层子程序，而不是在细节实现层次上。
- 对一项数据的所有访问都发生在同一抽象层上。

降低使用全局数据的风险：
- 创建一种命名规则来突出全局变量
- 为全部的全局变量创建一份注释良好的清单
- 不要用全局变量来存放中间结果。如果需要为全局变量赋新值，那么应该在结束后再把最终结果赋给全局变量，而不是用它来保存计算的中间结果。
- 不要把所有的数据都放在一个大对象中并到处传递，考虑全局变量




## 参考
[1] Steve, McConnell 著, 金戈, 汤凌, 陈硕, & 张菲. (2011). 代码大全(第2版). 电子工业出版社.