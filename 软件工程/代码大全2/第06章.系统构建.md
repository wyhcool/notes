---
title: 【代码大全2】06 系统考虑 System considerations
date: 2018-09-09 19:30:54
tags:
categories:
- Programming
---

## 第27章 程序规模对构建的影响 How program size affects construction
### 交流和规模 Communication adn size
交流路径的数量与项目成员数量的平方大致成正比。
改善交流效率的常用方式是：采用正式的文档。

### 项目规模的范围 Range of project sizes
评估项目规模的方法之一是考虑项目团队的规模。

### 项目规模对错误的影响 Effect of project size on errors
随着项目规模的增大，通常需求和设计犯的错误会更多，但主要错误来自于构建时。
大项目的每千行代码错误率会高于小项目。

### 项目规模对生产率的影响 Effect of project size on productivity
大项目的生产率会低于小项目。

### 项目规模对开发活动的影响 Effect of project size on development activities
项目越大，所需要的正式交流越多，所需进行的各种活动的种类也会急剧变化。
小项目以构建活动为主，更大的项目需要做更多的架构、集成工作和系统测试工作才能成功。

<!-- more -->
随着项目增大，构建活动（详细设计、编码、调试、单元测试）将会按比例增长，但是其他活动的工作量随项目规模扩大而非线性地增加。

程序、产品、系统、系统产品在精致度和复杂度上区别明显。
- 程序：只有它的开发者使用它，或者少数几个人非正式使用
- 产品：提供给最初开发者以外的人员使用。在发布之前要有充分的测试，要有文档，并且刻意由其他人来维护。开发软件产品的成本是开发软件程序的 3 倍。
- 系统：开发出一组能够结合起来工作的程序，即软件系统。软件系统的开发成本也是简单程序开发成本的 3 倍。
- 系统产品：既要具有单一产品的精致特征，又要拥有一套系统所具备的多个成分。系统产品的开发成本大约是简单程序的 9 倍。

对于小项目，方法论的应用显得很不经意并且趋于本能。对于大项目，方法论的应用变得十分严格，并且计划得非常仔细。
在社交场合，活动越正式，你所穿的服装就会越不舒服。项目越正规，你不得不写的文件的数量也会越多，用于确认你已经完成了工作。


## 第28章 管理构建 Managing construction
### 鼓励良好的编码实践 Encouraging good coding
推行良好的编码实践的若干技术：
- 给项目的每一部分分派两个人
- 逐行复查代码。代码复查通常包括程序员本人和至少两名评审员。
- 要求代码签名。
- 安排一些好的代码示例供人参考。
- 强调代码是公有财产。
- 奖励好代码。

### 配置管理 Configuration management
配置管理是系统化地定义项目工作(project artifacts)和处理变化，以使项目一直保持其完整性的实践活动。它的另一种说法是“变更控制”，其中的技术包括：评估所提交的修改、追踪更改、保留系统在不同时间点的各历史版本。
配置管理实施中的可选项：
- 需求变更和设计变更。
  - 遵循某种系统化的变更控制手续。
  - 成组地处理变更请求。记下所有的想法和建议，直到有时间去处理它们。
  - 评估每项变更的成本。
  - 提防大量的变更请求。这是一个警报信号，表明需求、架构、或上层设计做得不够好，从而无法有效地支持构建活动。
  - 成立变更控制委员会(change-control board, CCB)。变更控制委员会的职责是在收到变更请求的时候去芜存菁。任何想提出更改的人都要把变更请求提交给变更控制委员会。
  - 警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制。
- 软件代码变更。
  - 使用版本控制系统(ersion control system)。
- 工具版本。创建软件的各个特定版本的原样环境，将这些工具纳入版本控制中
- 机器配置。为标准的开发工作站生成一份的磁盘映像，然后将其加载到每位开发者的机器上。
- 备份计划。定期进行备份，并将备份介质转移到脱机存储设备里。除了源代码，还应该备份：文档、图表、笔记等等。

### 评估构建进度表 Estimating a construction schedule
#### 评估的方法
- 建立目标
- 为评估留出时间，并且做出计划
- 清楚地说明软件需求
- 在底层细节层面进行评估
- 使用若干不同的评估方法，并且比较其结果
- 定期做重新评估。项目早期的评估结果注定不会很准确，随着项目推进，评估的准确度会越来越高。在项目进行过程中要定期地重新评估，用你在每一项活动中学到的知识去改进你对下一次活动的评估。

#### 对进度的影响因素
- 需求开发者(requirements developer)的经验和能力
- 程序员的经验和能力
- 团队的动力
- 管理的质量
- 复用的代码数量
- 人员流动性
- 需求变更
- 客户关系的质量
- 用户对需求的参与度
- 客户度此类应用软件的经验
- 程序员对需求开发的参与程度
- 计算机、软件和数据的分级安全环境
- 文档量
- 项目目标(进度、质量、可用性等)

#### 如果落后了该怎么办
- 希望自己能赶上。越接近项目后期，延误和超支的现象就越严重，项目并不能在后期把时间补回来，而会越来越落后。
- 扩充团队。往一个已经落后的软件项目里增加人手只会使得它更加落后(Brooks 1995)。前提是如果一个项目中的任务是不可分割，不能个个击破，那么增加人手也是无济于事的。反之如果项目中的任务可以分割，那就可以进一步细分，然后分配给不同的人来做，甚至是分配给项目后期才加入进来的人。
- 缩减项目范围。如果做不到完整地某项功能，还可以提供一个该功能的简化版本。重新评估实现那些非重要特性的开发时间。


### 度量 Measurement
对项目进行度量的根本原因：任何一种项目特征(attribute)都是可以用某种方法来度量的，而且总会比根本不度量好得多。


### 把程序员当人看 Treating programmer as people
- 花费时间：一个程序员大约有 30% 的时间花费在对项目没有直接好处的非技术活动上：步行，个人事务等。
- 个体差异：程序员之间有着数量级的差异。
- 团队差异：好的程序员倾向于集聚在一起，差的程序员也是一样。
- 信仰问题：
  - 编程语言
  - 缩进风格
  - 大括号的摆放位置
  - 所用的集成开发环境
  - 注释风格
  - 效率与可读性的取舍
  - 对方法的选择
  - 编程工具
  - 命名习惯
  - 对 goto 的使用
  - 对全局变量的使用
  - 有关生产力的量度，比如每天编写的代码行数
- 物理环境：在生产力和工作场所质量之间有着很强的关联性

### 管理你的管理者 Managing your manager
管理你的管理者，意味着你需要告诉他应该怎样做而不应该怎样做。其要诀在于，你要表现得使你的管理者认为他仍然在管理你。


## 第29章 集成 Integration
集成指的是一种软件开发行为：将一些独立的软件组件组合为一个完整系统。

### 集成频率 Integration frequency
程序集成有两种方式：阶段式集成和增量集成。
#### 阶段式集成 Phased integration
阶段式集成遵循明确的步骤，又称阶段：
- 设计、编码、测试、调试各个类。这一步称为“单元开发”。
- 将这些类组合为一个庞大的系统。这一步称为“系统集成(system integration)”。
- 测试并调试整个系统。这一步称为“系统瓦解(system dis-integration)”。

阶段式集成的一个问题是：当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现。出现问题的位置不确定，再加上所有问题都是一下子出现，因此又被称为“大爆炸集成”。

#### 增量集成 Incremental integration
增量集成遵循以下步骤：
- 开发一个小的系统功能部件。他可能是最小的功能部件、最难的部件、关键部件、或者以上的某种组合。对它彻底地进行测试并调试。将其作为骨架，稍后附上肌肉、神经、皮肤等其余部件。
- 设计、编码、测试、调试某个类。
- 将这个新的类集成到系统骨架上。测试并调试骨架和新类的结合体。在进一步添加任何新类之前，确保该结合体能工作。如果做完了剩余的所有工作，就会到步骤2开始重复这一过程。

增量集成的益处：
- 易于定位错误
- 及早在项目里取得系统级的成果
- 改善对进度的监控
- 改善客户关系
- 更加充分地测试系统中的每个单元
- 能在更短的开发进度计划内建造出整个系统

### 增量集成的策略 Incremental integration strategies
#### 自顶向下集成 Top-down integration
在自顶向下集成中，首先编写并集成位于继承体系顶部的类，然后随着自上而下地集成各个类。
纯粹的自顶向下集成将棘手的系统接口的演练留到最后才进行，导致从底层的问题冒上来影响顶层。

#### 自底向上集成 Bottom-up integration
在自底向上集成中，首先编写并集成位于底部的类，后集成顶部的类。

#### 三明治集成 Sandwich integration
三明治集成法：首先集成继承体系顶部的高层业务对象(business-object)类，然后集成底部的与设备接口的类和广泛使用的工具类。稍后开始集成中间层的类。

#### 风险导向集成 Risk-oriented integration
风险导向集成也称为困难部件优先集成法。首先集成你认为棘手的类，然后实现较容易的类。
在风险导向的集成中，需要首先鉴别各个类对应的风险级别，确定哪些部件实现起来是最有挑战的，然后先实现这些部件。巧合的是，它也趋向于先集成顶层类和底层类，将中间层类留后处理。但与三明治集成的动机不同。

#### 功能导向的集成 Feature-oriented integration
功能导向的集成，一次集成一项功能。以一组构成一项可确认的功能的类为单位进行集成。
通常是首先要搭好一个骨架，选择骨架的标准是它能支撑其他功能。另外，通常需要先集成某些底层的代码，之后才能集成某些重要的功能。
功能导向的集成的优点：
- 基本不用脚手架。把各个功能挂到骨架上无须脚手架。
- 每个新集成的功能都增加了系统的功能性。
- 功能导向的集成与面向对象设计能很好地协同工作。

#### T-型集成 T-shaped integration
在T-型集成中，首先建造并集成系统的一个直插到底层的块，以验证架构的假设，然后建造并集成系统的挑大梁部件，为开发余下的功能提供一个框架。


### Daily build 与冒烟测试
每天都将各个源文件编译、链接并组合为一个可执行程序，然后对这个程序进行冒烟测试，即执行一种相对简单的检查，看看产品在运行时是否冒烟。

Daily build 详情：
- 每日构建。daily build 可视为项目的脉搏。
- 检查失败的 build。修复它就成了优先级最高的事情。
- 每天进行冒烟测试。冒烟测试应该从头到尾地演练整个系统，不必做到毫无遗漏，但是应该能够暴露主要的问题。
- 让冒烟测试与时俱进。
- 将 daily build 和冒烟测试自动化。
- 成立 build 小组。看护 daily build 并让冒烟测试保持更新。
- 仅当有意义时，才将修订(revisions)纳入到 build 中。
- 但是别等太久才将修订加入进来。
- 要求开发人员把他的代码添加到系统之前，进行冒烟测试。在开发人员自己机器上建立系统的一套私有 build，由开发人员独自进行测试。
- 为即将添加到 build 的代码准备一块暂存区。
- 惩罚破坏 build 的人。保持 build 健康是本项目优先级最高的事情之一。
- 在早上发布 build。
- 即使有压力，也要进行  daily build 和冒烟测试。


## 第30章 编程工具 Programming tools
使用最前沿的工具集，并熟悉你所用的工具，能使生产力增加 50% 还不止。

### 设计工具 Design tools
设计工具主要是那些图形化工具，使用标准的图形符号来表述你的设计，包括： UML、架构方块图、继承体系图、实体关系图、类图等。
设计工具能够让你在高层抽象和底层抽象之间来回移动。

### 源代码工具 Source-code tools
#### 编辑 Editing
- 集成开发环境 Integrated development environments (IDEs)
- 针对多个文件的字符串查找和替换
- Diff工具，通常集成在版本控制工具中。
- Merge工具，通常集成在版本控制工具中。
- 源代码美化器。
- 生成接口文档的工具。比如 Javadoc。
- 模版。简化经常从键盘键入的格式系统的内容这一类工作。
- 交叉引用工具。
- 类的继承体系生成器。

#### 分析代码质量 Analyzing code quality
- 吹毛求疵的语法/语义检查器。在 C/C++ 使用 lint 工具。
- 尺度报告器。检查和报告子程序的复杂度。

#### 重构源代码 Refactoring source code
- 重构器。
- 结构改组工具。
- 代码翻译器。

#### 版本控制 Version control
- 源代码控制
- 依赖关系控制，类似于 Unix 下提供的 make 工具
- 项目文档的版本管理
- 将项目的工件(artifacts)(如需求、代码、测试用例)关联到一起

#### 数组字典 Data dictionaries
数据字典是描述项目中所有重要数据的数据库。

### 可执行码工具 Executable-code tools
#### 产生目标码 Code creation
- 编译器和链接器
- Build 工具
- 程序库
- 代码生成向导
- 安装
- 预处理器

#### 调试 Debugging
- 编译器的警告信息
- 测试用的脚手架
- Diff工具
- 执行剖测器
- 追踪监视器
- 交互式调试器

#### 测试 Testing
- 自动测试框架。 JUnit、CppUnit等
- 自动化的测试生成器
- 测试用例的记录和回放工具
- 覆盖率监视器（逻辑分析器和执行剖测器）
- 符号调试器
- 系统扰动器（内存填充工具、内存抖动工具、选择性的内存失效的工具、内存访问检查器）
- Diff工具（比较数据文件、截获的输出、屏幕图像）
- 脚手架
- 缺陷注入工具
- 缺陷跟踪软件

#### 代码调整 Code tuning
- 执行剖测器
- 汇编代码清单和反汇编

### 工具导向的环境 Tool-oriented environments
Unix 环境因此而著名：它有一堆名称古怪的小工具，而这些小工具彼此能很好地配合工作。
C/C++语言与 Unix 紧密耦合，体现了相同的哲学。

### 打造你自己的编程工具 build your own programming tools
- 项目特有的工具。
- 脚本。

### 工具环境 Tool fantasyland
软件工业界不断地开发出新的工具，用于减少或消除编程过程中某些最单调乏味的工作的数量。

编程从根本上而言就是困难的，程序员必须与凌乱的真实世界较力，我们须得严密地思考前后次序、依赖关系、异常情况，还要与无法说清楚自己想法的最终用户交往，始终应对连接到其他软件或硬件的定义不清的接口，还要解决规章制度、业务规则以及其他复杂性之源。

**始终需要人来填补真实世界里需要解决的问题和准备用来解决问题的计算机之间鸿沟，这些人将会被称做程序员**。

**只要有计算机，就需要能告诉计算机该去做什么的人，这一活动将会被称作编程**。





















## 参考
[1] Steve, McConnell 著, 金戈, 汤凌, 陈硕, & 张菲. (2011). 代码大全(第2版). 电子工业出版社.
