---
title: 【代码大全2】05 代码改善 Code improvement
date: 2018-09-04 23:35:46
tags:
categories:
- Programming
---

## 第20章 软件质量概述 The software-quality landscape
### 软件质量的特性 Characteristics of software quality
软件同时拥有外在的和内在的质量特性。
外在特性指的是该产品的用户所能感受到的部分。包括：
- 正确性(correctness)。系统规范、设计和实现方面的错误的稀少程度。
- 可用性(usability)。用户学习和使用一个系统的容易程度。
- 效率(efficiency)。软件是否尽可能少地占用系统资源，包括内存和执行时间。
- 可靠性(reliability)。在指定的必需条件下，一个系统完成所需要功能的能力，应该有很长的平均无故障时间。
- 完整性(integrity)。系统阻止对程序或数据进行未经验证或者不正确的访问的能力，以及确保数据能够正确访问的能力。
- 适应性(adaptability)。指为特定的应用或者环境设计的系统，在不做修改的情况下，能够在其他应用或者环境中使用的范围。
- 精确性(accuracy)。指系统输出结果的误差程度。精确性是用来判断系统完成工作的优劣程度，正确性是判断系统是否被正确开发出来。
- 健壮性(robustness)。指系统在接收无效输入或者处于压力环境时正常运行的能力。

程序员除了关心软件质量的外在特性外，还要关心它的内在特性，包括：
- 可维护性(maintainability)。指是否能够很容易对系统进行修改、改变或增加功能、提高性能、以及修正缺陷。
- 灵活性(flexibility)。指假如一个系统是为特定用途或者环境设计的，那么当该系统被用于其他目的或环境时，需要对系统做修改的程度。
- 可移植性(portability)。指为了在原有设计的特定环境之外运行，对系统所进行修改的难易程度。
- 可复用性(reusability)。指系统的某些部分可被应用到其他系统中的程度，以及此项工作的难易程度。
- 可读性(readability)。指阅读并理解系统代码的难易程度。
- 可测试性(testability)。指可以进行何种程度的单元测试或系统测试，以及在何种程度上验证系统是否符合要求。
- 可理解性(understandability)。指在系统组织和细节语句的层次上理解整个系统的难易程度。

系统的内在和外在特性并不能完全割裂开来。强调软件的某个特性，可能会对另一些特性产生正面或负面的影响。
软件工程的目标是根据一组相互竞争的目标寻找出一套优化的解决方案。

<!-- more -->
### 改善软件质量的技术 Techniques for improving software quality
描述软件质量的要素：
- 明确定义出软件质量的目标。
- 明确定义出软件质量的保证工作。
- 制定出一套与产品需求、架构以及设计相关联的测试策略。
- 软件开发指南。贯彻到所有的开发活动中，包括问题定义、需求分析、架构设计、构建及系统测试。
- 非正式技术复查。自行检查或者和若干同事一起代码检视。
- 正式技术复查。**管理软件工程过程的工作之一，就是要在低成本的环节里抓出问题，即在投资最小并且修正问题成本最小的时候**。开发人员可周期性使用“质量门(quality gates)”测试或复查，以检查某一阶段的产品是否具备了进入下一阶段前所要求的质量。
- 外部审查。由开发小组之外的人员构成对开发项目进行复查。

开发过程：
- 对变更进行控制的过程。需求变更的失控可能导致设计与编码工作前功尽弃；设计变更的失控则会造成代码与需求背离，或代码自相矛盾；代码变更的失控则可能造成内部冲突。**有效地管理变更是实现高质量的一个关键**。
- 结果的量化。通过对各种质量特性（正确性、可用性、效率）的度量。
- 制作原型(prototyping)。制作原型是指开发出系统中关键功能的实际模型。开发出一部分用户界面的原型可以判断系统的可用性；开发出关键算法的模型可以确定功能的执行时间；开发出典型数据集的原型能去诶定程序的内存需求。**构建原型能产生更完善的设计、更贴近用户的需求、以及更好的可维护性**。

一个有效的软件质量项目的底线，必须包括在开发的所有阶段联合使用多种技术。以下阵容，可获取高于平均水平的质量：
- 对所有的需求、架构以及系统关键部分的设计进行正式检查
- 建模或者创建原型
- 代码阅读或者检查
- 执行测试

### 什么时候进行质量保证工作 When to do quality assurance
错误越早引入到软件当中，问题就会越复杂，修正这个错误的代价也更高，因为错误会牵涉到系统的更多部分。
你需要**在早期阶段就开始强调质量保证工作，并且将其贯彻到项目的余下部分中**。

### 软件质量的普遍原理 The general principle of software quality
软件质量的普遍原理是：改善质量以降低开发成本。
提高生产效率和改善质量的最佳途径是：减少花在代码返工上的时间，无论返工是由需求、设计改变还是调试引起的。


## 第21章 协同构建 Collaborative construction
**所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来**。协同开发实践往往比测试发现更多的缺陷，并且更有效率。

### 协同开发实践概要 Overview of collaborative development practices
“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读、以及其他开发人员共同承担创建代码及其他工作产品责任的技术。
协同构建技术的思想是：在工作中开发人员总会对某些错误视而不见，而其他人不会有相同的盲点。

协同构建的首要目的是改善软件的质量。由人进行的复查能够发现不明显的错误信息、不恰当的注释、硬编码的变量值、以及重复出现的需要进行统一的代码模式，这些是测试发现不了的。协同开发让人们意识到他们的工作会被复查，这样会更加谨慎检查自己的工作。

协同构建有利于传授公司文化及编程专业知识，复查为编程新人和资深程序员提供了一个技术交流的平台，可以快速地将所有开发者的水平提升到最优秀的开发者的高度。

将协同构建技术扩展开来正是集体所有权的思想，所有的代码都属于团队而不是某一个人，并且团队中的所有成员都可以对其进行访问和修改。

### 结对编程 Pair programming
成功运用结对编程的关键：
- 用编码规范来支持结对编程。对编程风格进行标准化，以便程序员将精力集中到本质任务上。
- 不要让结对编程变成旁观。不掌握键盘的人应该主动参与到编程当中，他应该分析代码，提前思考接下来的代码应该做什么，对设计进行评估，并对如何测试代码做出计划。
- 不要强迫在简单的问题上使用结对编程
- 有规律地对结对人员和分配的工作进行轮换
- 鼓励双方跟上对方的节奏
- 确认两个人都能够看到显示器
- 不要强迫程序员与自己关系紧张的人组对
- 避免新手组合
- 指定一个组长

### 正式检查(详查) Formal inspections
详查与普通复查的区别：
- 详查表关注的是复查者过去所遇到的问题
- 详查专注于缺陷的检测，而非修正
- 复查人员要为详查会议做好预先准备，整理已发现的问题列表
- 参与者都被赋予了明确的角色
- 详查的主持人不是被检查产品的作者
- 详查的主持人应该已经接受过详查会议方面的培训
- 只有在与会者都做好充分准备后才会召开详查会议
- 每次详查所收集的数据都会被应用到以后的详查当中，以便对详查进行改进

详查中的人员角色：
- 主持人。保持详查以特定的速度进行，保证效率的同时发现尽可能多的错误。主持人必须在技术层面上胜任，同时负责管理详查的其他方面，分派复查设计和代码的任务、分发详查所需的核对表、预定会议室、以及跟踪详查会议上指派的任务。
- 作者。作者的责任是解释设计和代码中不清晰的部分。若设计或代码不够清晰，就需要向作者分配任务。
- 评论员。评论员的职责是找出缺陷。
- 记录员。记录员将详查会议期间发现的错误，以及指派的任务记录下来。

详查的一般步骤：
- 计划(planning)。作者将设计或代码交与主持人，主持人决定由哪些人复查这些材料，决定会议召开的时间地点，并将设计或代码、及核对表打印，并分发与会人员。
- 概述(overview)。**加入概述也许有风险，因为这会导致被检查的设计或代码中不清晰的地方被掩饰，设计或代码本身应该可以自我表达**。
- 准备(preparation)。每个评论员要独立地对设计或代码进行详查。当评论员被赋予某一特定视角时(负责维护工作的程序员、客户、或者是设计师)，可以发现更多错误。
- 详查会议。详查小组的注意力应保持在识别缺陷上，所有的讨论应当在确认这是一个错误的时候就停止，当记录员将错误的类型及严重程度记录后，详查工作继续向下进行。**不要在开会的过程当中讨论解决方案**。
- 详查报告。主持人整理详查报告，列出每一个缺陷，包括它的类型和严重级别。以 email 形式发出。
- 返工。主持人将缺陷分配给某人来修复。
- 跟进。主持人负责监督在详查过程中分配的返工任务。根据发现错误的数量及严重程度，决定是否让评论员重新详查返工结果。
- 第三小时的会议。非正式的第三小时会议，允许有兴趣参与的人在正式检查结束之后讨论解决方案。

进行详查的目的是发现设计或代码中的缺陷，而不是探索替代方案，或者争论谁对谁错，其目的也**绝不应该是批评作者的设计或代码**。

作者需要记住：作者应该承认每一个所谓的缺陷，然后继续详查。**承认一个批评并不意味着作者认同批评的内容**。在复查工作中，作者不应该试图为正在被检查的工作辩护；在复查之后，作者可以独自对每一个问题进行思考，判断它是否真的是一个缺陷。

评论员需要记住：最终是由作者来负责决定如何处理缺陷，必须尊重作者决定如何解决某个错误的最终权力。



## 第22章 开发者测试 Developer testing
某些测试通常由开发人员进行，而有些测试则更多由专门的测试人员进行。
- 单元测试(Unit testing)。将一个程序员或开发团队编写的一个完整的类、子程序或者小程序从完整的系统中隔离出来进行测试。
- 组件测试(Component testing)。将多个程序员或者更多团队编写的一个类、包、小程序或其他程序元素从更加完整的系统中隔离出来进行测试。
- 集成测试(Integration testing)。对两个或更多的类、包、组件或子系统进行的联合测试。
- 回归测试(Regression testing)。重复执行以前的测试用例，以便在原先通过了相同测试集合的软件中查找缺陷。
- 系统测试(System testing)。在最终的配置下运行整个软件，以便测试安全、性能、资源消耗、时序方面的问题，以及其他无法在低级集成上测试的问题。

开发者测试：指由开发者进行的测试，通常包括单元测试、组件测试和集成测试。
测试通常分为两大类：
- 黑盒测试(black-box testing)。测试者无法了解测试对象内部工作机制的测试。
- 白盒测试(white-box testing)。测试者清楚待测试对象内部工作机制的测试。

测试(testing)是一种检查错误的方法。
调试(debugging)意味着错误已经被发现，要做的是诊断错误并消灭造成这些错误的根本原因。

### 开发者测试在软件质量中的角色 Role of developer testing in software quality
测试于绝大多数开发人员来说是一种煎熬：
- 测试的目标是找出错误，一个成功的测试应该弄垮软件，而其他开发活动的目标是避免程序错误和软件的崩溃。
- 测试永远不可能彻底证明程序中没有错误。
- 测试本身并不能改善软件的质量，测试的结果是软件质量的一个指示器。如果你希望减肥，不是应该买一个新的秤，而是应该改变你的饮食习惯。如果你希望改善你的软件，你需要的是更高质量的开发。
- 测试时要求你假设会在代码里找到错误，

测试发现缺陷的记录有助于归纳出程序中最常见错误的类型，用来指引今后的技术复查活动。

### 开发者测试的推荐方法
采用系统化的开发者测试方法，能最大限度提高你发现各种错误的能力，同时能让你的花费也最少：
- 对每一项相关的需求进行测试，以确保需求都已被实现。在需求阶段就计划好这一部分的用例。
- 对每一个相关的设计关注点进行测试，以确保设计都已被实现。在设计阶段就计划好这一部分用例。
- 用基础测试(basis testing)来扩充针对需求和设计的详细测试用例；增加数据流测试(data-flow test)来补充其他所需的测试用例，以便对代码进行彻底的考验。
- 使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型。

测试先行(Test First)：
**首先编写测试用例可以将从引入缺陷到发现并排除缺陷之间的时间缩减至最短**：
- 在开始代码之前先写测试用例，并不比之后再写要多花时间，只是调整了测试用例编写活动的工作顺序而已。
- 可以更早发现缺陷，同时也更容易修正。
- **将迫使你在写代码之前至少思考一下需求和设计**，而这往往会催生更高质量的代码。
- 能更早把需求上的问题暴露出来。因为对于一个糟糕的需求，要写出测试用例是一件困难的事情。


### 测试技巧锦囊 Bag of testing tricks
#### 结构化的基础测试 Structured basis testing
结构化的基础测试是指：**需要去测试程序中的每一条语句至少一次，要确保你已经覆盖了所有的基础情况**。最简单的方法是算一算有多少条通过程序的路径，然后据此开发出能通过程序里每条路径的最少数量的测试用例。
所需测试用例的最少数量计算方法：
- 对通过子程序的直路，开始时记1。
- 遇到关键字，加1：if、while、repeat、for、and、or 等。
- 遇到每一个 case 加1；如果 case 没有缺省情况，则再加 1。

#### 数据流测试 Data-flow testing
数据流测试基于：数据使用的出错几率至少不亚于控制流。数据的状态可以是下列状态中的一种：
- 已定义(defined)。数据已经初始化了，但是还没有使用。
- 已使用(used)。数据已经用于计算、或作为某个子程序调用的一个参数等。
- 已销毁(killed)。数据曾经定义过，但是现在已经通过某种途径取消了对它的定义。
- 已进入(entered)。控制流已经进入一个子程序，但还没有使用该变量。
- 已退出(exited)。在对变量产生影响之后，控制流退出子程序。

数据状态的组合(Combinations of data states)：
正常的数据状态的组合是变量已定义、已经一次或多次使用，并且可能已经销毁。各种搭配形式：
- 已定义-已定义。在对变量赋值之前将其定义了两次。
- 已定义-已退出。对局部变量，定义之后却不使用就退出是不合理的；对于子程序的参数或全局变量，尚可。
- 已定义-已销毁。定义一个变量然后销毁是不合理的。
- 已进入-已销毁。对局部变量，未定义或未使用就不需要被销毁；对于子程序的参数或全局变量，需要在销毁之前确定该变量已经在其他地方是否被定义。
- 已进入-已使用。对局部变量，使用之前需要被定义。对于子程序的参数或全局变量，需要在销毁之前确定该变量已经在其他地方是否被定义。
- 已销毁-已销毁。一个变量不应该被销毁两次。
- 已销毁-已使用。使用一个已销毁的变量是不合理的。
- 已使用-已定义。可能是问题也可能不是问题。至少 JavaScript 中变量提升是支持这种情况的。

编写数据流测试用例的关键是：对所有可能的定义-使用路径进行测试。

#### 猜测错误 Error guessing
- 边界值分析。防止 off-by-one 错误。
- 坏数据分析：
  - 数据太少/没有数据
  - 太多的数据
  - 错误的数据情况/无效数据
  - 长度错误的数据
  - 未初始化的数据
- 好数据分析：
  - 正常的情形
  - 最小的正常局面
  - 最大的正常局面
  - 与旧数据的兼容性

### 典型错误 Typical errors
- 大多数错误的影响范围是相当有限的。即可以在修改不超过一个子程序的范围内得以修正。
- 许多错误发生在构建的范畴之外。常见错误的源头：缺乏应用领域知识，频繁变动且相互矛盾的需求，沟通和协调的失效。
- 大多数的构建期错误是编程人员失误造成的。
- 笔误(拼写错误)是一个常见的问题根源。
- 错误理解设计是程序员常犯错误的原因。
- 大多数错误都很容易修正。通过早期对需求和设计的复查来避免软件中的硬伤，以及尽可能早地处理大量存在的小问题。
- 总结所在组织中对付错误的经验。

### 测试支持工具 Test-support tools
#### 为测试各个类构造脚手架 Building scaffoldings to test individual classes
脚手架：建筑工人如果要对建筑的某个部分进行施工，就必须搭建脚手架。
在软件中搭建脚手架是为了方便地测试代码。
脚手架的分类：
- 哑类(dummy class)，待测试的类可以使用它们。这样的类也被称为模仿对象(mock object)或者桩对象(stub object)。根据所需的真实性来决定它们与现实的接近程度。
- 驱动函数。调用待测试的真实函数的伪造函数。

### 改善测试过程 Improving your testing
#### 有计划的测试 Planning to test
重视测试并保障这一过程的质量。
#### 回归测试 Regression Testing
确保修改没有引入错误，回归测试每次都应该使用之前保留的旧的测试用例。
#### 自动化测试 Automated testing
管理回归测试唯一可行的方法，是将其变成一个自动化的过程。

### 保留测试记录 Keeping testing records
改善测试过程的最好方法是将其规范化，并对其进行评估，然后从评估中获得的经验教训来改善这个过程。


## 第23章 调试 Debugging
调试是确定错误根本原因并纠正错误的过程。

### 调试概述 Overview of debugging issues
开发高质量软件产品的最佳途径是：精确描述需求，完善设计，并使用高质量的代码编写规范。**调试只是迫不得已时采用的手段**。

程序中的错误可以让你：
- 理解你正在编写的程序。
- 明确你犯了哪种类型的错误。
- 从代码阅读者的角度分析代码质量。
- 审视自己解决问题的方法。
- 审视自己修正缺陷的方法。


### 寻找缺陷 Finding a defect
科学的调试方法：
- 将错误状态稳定下来
- 确定错误的来源
  - 收集产生缺陷的相关数据
  - 分析所收集的数据，并构造对缺陷的假设
  - 确定怎样去证实或证伪这个假设，可以对程序进行测试或是通过检查代码
  - 通过测试或检查，对假设作出最终的结论
- 修补缺陷
- 对所修补的地方地方进行测试
- 查找是否还有类似的错误


### 修正缺陷 Fixing a defect
减少出错几率的方法：
- 在动手之前先要理解问题。
- 理解程序本身，而不仅仅是问题。
- 验证对错误的分析。
- 放松一下。**匆忙动手解决问题是你所能做的最低效的事情之一**。
- 保留最初的源代码。
- 治本，而不是治标。
- 修改代码时，一定要有恰当的理由。
- 一次只做一个改动。让问题简单一点，避免修改引入。
- 检查自己的改动。
- 增加能暴露问题的单元测试。
- 探索类似的缺陷。


### 调试中的心理因素 Psychological considerations in debugging
#### “心理取向”导致调试时的盲目
如果你在程序中看到一个名为 Num 的符号，你会把它看作是什么？被拼错的 Numb(麻木)？Number 的简写？这种现象就是心理取向(psychological set)。
这说明养成良好的编程习惯的重要性，规范的格式、恰当的注释、良好的变量和子程序命名方式、以及其他编程风格要素有助于构建编程的良好基础。
当发现错误时，高效的程序员能够在调试过程中对程序中的无关部分视而不见，从而收缩研究范围，更快地发现问题。

#### 心理距离在调试中的作用
在编写代码时，应该为变量或子程序选择差别较大的名字，避免混淆。

### 调试工具
#### 编译器的警告消息
将编译器的警告级别设置为最高级，尽可能不放过任何一个警告，然后修正全部错误。
#### 增强的语法检查和逻辑检查
与大多数C语言编译器相比，lint可以对程序进行更加广泛的错误分析，是一种更加严密的编译工具。最初，lint这个工具用来扫描C源文件并对源程序中不可移植的代码提出警告。但是现在大多数lint实用程序已经变得更加严密，它不但可以检查出可移植性问题，而且可以检查出那些虽然可移植并且完全合乎语法但却很可能是错误的特性。



## 第24章 重构 Refactoring
### 软件演化的类型 Kinds of software evolution
软件演化的基本准则是：演化应该提升程序的内在质量。

### 重构 
重构是在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。
重构的理由：
- 代码重复。重复代码总是将你置于一种两线作战的尴尬境地。 Don't Repeat Yourself(DRY原则)。复制粘贴即设计之谬。
- 冗长的子程序。改善系统的方法之一就是提升其模块性、命名准确的子程序，让它们各自集中力量做好一件事情。
- 循环过长或嵌套过深
- 内聚性太差的类
- 类的接口未能提供层次一致的抽象
- 拥有太多参数的参数列表
- 类的内部修改往往被局限于某个部分。标明类应该根据相互独立的功能拆分为多个类。
- 变化导致对多个类的相同修改。
- 对继承体系的同样修改。
- case 语句需要做相同的修改。考虑使用继承多态是否更明智的选择。
- 同时使用的相关数据并未以类的方式进行组织。考虑是否将这些操作和数据组织到一个类里面。
- 成员函数使用其他类的特征比使用自身类的特征还要多。考虑将这一子程序放到另一个类里面。
- 过多使用基本数据类型。
- 某个类无所事事。考虑彻底去掉。
- 一系列传递流浪数据的子程序。把数据传递给某个子程序，是否仅仅就是为了让该子程序把数据转交给另一个子程序，这种被传来传去的数据称为流浪数据(tramp data)。
- 中间人对象无事可做。只是调用其他类中的成员函数。考虑是否去掉中间人，转而直接调用其他的类。
- 某个类同其他类的关系过于亲密。宁可让代码因较强的封装而出错，也不要减弱封装。
- 子程序命名不恰当。
- 数据成员被设置为公用。考虑把 public 数据成员藏在访问器子程序背后。
- 某个派生类仅使用了基类的很少一步成员函数。考虑把积累转换成原来的派生类的数据成员。
- 注释被用于解释难懂的代码。**不要为了拙劣的代码编写文档，应当重写代码**。
- 使用了全局变量。避免使用全局变量和通过访问器子程序来访问这些数据。
- 在子程序调用前设置了前置代码(setup code)，或在调用后使用收尾代码(takedown code)。
- 程序中的一些代码似乎是在将来的某个时候才会用到的。超前设计。

### 特定的重构 Specific refactorings
#### 数据级的重构 Data-level refactorings
- 用具名常量代替神秘数值
- 将变量的名字更为清晰且传递更多消息
- 将表达式内联化
- 用函数来代替表达式
- 引入中间变量
- 用多个单一用途变量代替某个多用途变量
- 在局部用途中使用局部变量而不是参数
- 将基础数据类型转换为类
- 将一组类型码转换为类或枚举类型
- 将一组类型码转换为一个基类及其相应的派生类
- 将数组转换为对象
- 把集合(colletion)封装起来
- 用数据类来代替传统记录

#### 语句级重构 Statement-level refactorings
- 分解布尔表达式。通过引入命名准确的中间变量。
- 将复杂布尔表达式转换为命名准确的布尔函数
- 合并条件语句不同部分中的重叠代码片段
- 在循环中使用 break 或 return 而不是循环控制变量
- 在嵌套 if-then-else 语句中一旦知道答案就立即返回，而不是去赋一个返回值。
- 用多态来代替条件语句，尤其在重复的 case 语句中。
- 创建和使用 null 对象，而不是去检测空值。

#### 子程序级重构 Routine-level refactorings
- 提取子程序或方法
- 将子程序的代码内联化
- 将冗长的子程序转换为类
- 用简单算法代替复杂算法
- 增加参数
- 删除参数
- 将查询操作从修改操作中独立出来
- 合并相似的子程序，通过参数区分它们的功能
- 将行为取决于参数的子程序拆分开来。分解为无需传递特定参数，可单独被调用的子程序
- 传递整个对象而非特定成员。如果同一对象的多个值被传递给了一个子程序。
- 传递特定成员而非整个对象。
- 包装向下转型的操作。

#### 类实现的重构 Class implementation refactorings
- 将值对象转化为引用对象
- 将引用对象转化为值对象
- 将数据初始化替代虚函数
- 改变成员函数或成员数据的位置：
  - 减少派生类的重复工作：
    - 将子程序上移到基类中
    - 将成员上移到基类中
    - 将构造函数中的部分代码上移到基类中
  - 对派生类进行特殊化：
    - 将子程序下移到派生类中
    - 将成员下移到派生类中
    - 将构造函数下移到派生类中
- 将特殊代码提取为派生类
- 将相似的代码结合起来放置到基类中

#### 类接口的重构 Class interface refactorings
- 将成员函数放到另一个类中
- 将一个类变成两个。使每个类完成一种明确定义的功能。
- 删除类
- 去除委托关系
- 去除中间人
- 用委托代替继承
- 用继承代替委托
- 引入外部的成员函数
- 引入扩展类
- 对暴露在外的成员变量进行封装
- 对不能修改的类成员，删除相关的 set() 成员函数
- 封装不使用的成员函数
- 合并那些实现非常类似的基类和派生类

#### 系统级重构 System-level refactorings
- 为无法控制的数据创建明确的索引源
- 将单向的类联系改为双向的类联系
- 将双向的类联系改为单向的类联系
- 使用工厂方法(factory method)而不是简单地构造函数
- 用异常取代错误处理代码，或者用错误处理代码取代异常

### 安全的重构 Refactoring safely
避免错误地使用重构：
- 保存初始代码
- 重构的步伐请小点
- 同一时间只做一项重构
- 把要做的事情一条条列出来
- 设置一个停车场。为了处理并不需要立即对付的修改工作，设置一个停车场，把你需要在未来某个时间进行而不是现在可以先放在一边的修改工作列出来
- 多使用检查点
- 利用编译器警告信息
- 重新测试
- 增加测试用例
- 检查对代码的修改
- 根据重构风险级别来调整重构方法

不宜重构的情况：
- 不要把重构当作先写后改的代名词。重构最大的问题在于被滥用。
- 避免用重构代替重写。

### 重构策略 Refactoring strategies
- 在增加子程序时进行重构
- 在添加类的时候进行重构
- 在修补缺陷的时候进行重构
- 关注易于出错的模块，集中处理这样的代码是最为有效的重构策略
- 关注高度复杂的模块
- 在维护环境中，改善你手中正在处理的代码
- 定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界。**真实世界混乱不堪并不等于你的代码也得同样糟糕，将你的系统看作理想代码、混乱的现实世界、以及从前者到后者的接口的结合**。

**开发阶段的重构是提升程序质量的最佳时期**。

## 第25章 代码调整策略 Code-tuning strategies
### 性能概述 Performance overview
性能只是软件整体质量的一个方面，通常不是最重要的。

性能问题，涉及的方面：
- 程序需求。考虑清楚是否确实需要花费时间处理一个性能问题。
- 程序的设计。在设计架构时是否需要优先考虑整体性能，然后再为单个子系统、特征和类设置要达到的资源占用目标。
- 类和子程序设计。是否选择了合适的数据类型和算法将对性能产生重要影响。
- 同操作系统的交互。在需要同外部文件、动态内存或输出设备打交道时需要考虑。
- 代码编译。编译器对高级语言转换为经过优化后的机器码。
- 硬件。硬件升级将改善硬件上运行的所有程序的性能。
- 代码调整。代码调整是一种对正确代码进行调整的实践，它可以使代码的运行更为高效。调整(tuning)指较小规模的修改，可能会影响到单个的类、单个子程序。

### 代码调整简介 Introduction to code tuning
代码调整只是实现整体性能的一种方法，通常也不是决定性的。程序的架构、细节设计、数据结构及算法选择对程序的执行速度和资源占用的影响通常会更大。
代码调整的吸引力在于：掌握编写高效代码的这门艺术是成为严肃意义上程序员所需的加冕仪式。
代码调整的问题在于，高效的代码并不一定就是更好的代码。
80/20原则，程序中 20% 的子程序耗费了 80% 的执行时间。
**代码调整的误解**：
- 在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度或减少其资源占用。错误！
- 特定运算可能比其他的快，代码规模也较小。错误！
- 应当随时随地地进行优化。错误！
- 程序的运行速度同其正确性同等重要。错误！

何时调整代码：
程序员应当使用高质量的设计，把程序编写正确，使之模块化并易于修改，将让后期的维护工作变得很容易。在程序已经完成并且正确之后，再去检查系统的性能。如果程序运行迟钝，那么再设法让它更快更小。除非你对需要完成的工作一清二楚，否则绝不要对程序做优化。


### 蜜糖和哥拉斯 Kinds of fat and molasses
调整代码时，你会发现程序某个部分运行起来如同是寒冬罐子里的蜜糖一般粘乎乎、体积同哥拉斯一样，而你的目标就是让它运行起来像加了润滑油，快如闪电。

常见的低效率之源：
- 输入/输出操作。内存、磁盘、数据库、跨网络访问的差异巨大。
- 引发操作系统交换内存页面。缺页中断(page faults)，每一次访问都会造成磁盘和内存之间的页面切换。
- 系统调用。系统调用通常会涉及到系统的上下文切换(context switch)：保存程序状态、恢复内核状态、以及相反的操作。
- 解释型语言。
- 错误。


### 性能测量 Measurement
定量测量是实现性能最优化的关键。
由于程序中某些一小部分常常会耗费同自己体积不成比例的运算时间，所以应当测量代码性能，找出代码中的热点(hot spots)。
**一旦发现了这样的区域并对该处的代码进行了优化，就再一次进行测量，确定你到底有了多少改进。性能问题的很多方面都是违反直觉的**。

### 反复调整 Iteration
代码调整需要反复尝试，这样才能获得理想的性能提高。
一旦确定了性能瓶颈，你一定会为自己通过代码调整而获得的代码性能提升吃惊不已。

### 代码调整总结
1. 用设计良好的代码来开发软件，从而使程序易于理解和修改。
2. 如果程序性能很差：
  a. 保存代码的可运行版本，这样你才能回到最近的已知正常状态；
  b. 对系统进行分析测量，找出热点；
  c. 判断性能拙劣是否源于设计、数据结构、算法上的缺陷，确定是否应该做代码调整，如果不是，跳回第 1 步；
  d. 对步骤 c 中所确定的瓶颈代码进行调整；
  e. 每次调整后都对性能提升进行测量；
  f. 如果调整没有改进代码的性能，就恢复到步骤 a 保存的代码。
3. 重复步骤 2。


## 第26章 代码调整技术 Code-tuning techniques
减小代码资源占用更主要的是通过对类和数据结构的重新设计来实现，而非代码调整。代码调整更多的是指小规模的修改，而非大规模的设计变更。
不要盲从于任何优化建议，特定编译器实现将会极大地影响到优化结果。唯一可以信赖的法则是：每次都应当在具体的环境下评估代码调整所带来的效果。

### 逻辑 Logic
- 在知道答案后立即停止判断。一些语言提供了短路求值，即一旦知道了判断的结果就会自动停止继续判断。
- 按照出现频率来调整判断顺序。
- 相似逻辑结构之间的性能比较。case vs. if-then-else
- 用查询表代替复杂表达式。
- 使用惰性求值(lazy evaluation)。

### 循环 Loops
- 将判断外提。如果在循环运行时某个判断结果不会改变，则可以把这个判断提到循环的外部。通常需要把循环放在条件语句内。
- 合并。把两个对相同一组元素进行操作的循环合并到一起。
- 展开。减少维护循环所需要做的工作。展开循环影响可读性，性能通常会提高。
- 尽可能减少在循环内部作的工作。在循环外面计算某语句或部分语句，在循环内部只是使用计算结果。
- 哨兵值。当循环的判断条件是复合判断时，使用一个哨兵值(sentinel values)来改善，将其放到循环范围的末尾，从而保证循环一定能够中止。**任何使用线性查找的场合都可以使用哨兵法**。

```c
//搜索循环中的组合判断
found = FALSE;
i = 0;
while ( ( !found ) && ( i < count ) ) {
    if ( item[ i ] == testValue ) {
        found = TRUE;
    } else {
        i++;
    }
}

if ( found ) {
    
}

//使用哨兵值
//把需要查找的值赋给超过查找范围之外的元素(在声明数组时，切记为该元素预留空间)

initialValue = item[ count ];
item[ count ] = testValue;

i = 0;
while ( item[i] != testValue ) {
    i++;
}

if ( i < count ) {
    
}

```
- 把最忙的循环放到最内层。解决外层循环执行的次数远远多于内层循环这一问题。
- 削减强度。多次使用轻量级运算(eg.加法)来代替一次代价高昂的运算(eg.乘法)。

### 数据转换 Data transformations
- 使用整型数而不是浮点数。
- 数组维度尽可能少。
- 尽可能减少数组引用。
- 使用辅助索引。添加相关数据，使得对某种类型的访问更为高效。
  - 字符串长度索引。在 C 语言中，要确定字符串的长度，需要从字符产开始位置对各个字节计数，直到发现值为 0 的字节为止。
  - 独立的平行的索引结构。创建辅助结构，存放关键码和指向详细信息的指针。
- 使用缓存机制。把某些值存起来，使得最常用的值会比不太常用的值更容易被获取。缓存的成功取决于访问被缓存元素、创建未缓存元素，以及在缓存中保存新元素等动作相关的代价。缓存同其他优化技术一样，增加了程序的复杂性，使得程序更容易出错。

### 表达式 Expressions
- 利用代数恒等式。用低代价的操作来代替复杂操作。
- 削弱运算强度。
  - 用加法代替乘法
  - 用乘法代替幂乘
  - 利用三角恒等式代替等价的三角函数
  - 用 long 或 int 来代替 longlong 整数
  - 使用定点数或整型数代替浮点数
  - 使用单精度代替双精度数
  - 用移位操作代替整数乘 2 或除 2
- 编译期初始化。
- 小心系统函数。系统函数运行起来很慢，提供的精度常常是根本不需要的。
- 使用正确的常量类型。
- 预先算出结果。在详细设计阶段，需要选择即时计算有关结果，还是提早把他们算好并保存保存起来。
- 删除公共子表达式。将其赋给一个变量，然后在需要的地方引用该变量。

### 子程序 Routines
短小、定义明确的子程序能够代替多处单独执行相同操作的代码。
- 将子程序重写为内联。子程序调用意味着操作系统需要把程序从内存交换出去，换入一个子程序目录，换入特定的子程序，执行子程序，然后再把这个子程序换出去，最后把调用方子程序交换回来。

### 用低级语言重写代码 Recoding in a low-level language
在程序遭遇性能瓶颈时，你应当用低级语言重写代码。
使用低级语言优化代码的标准方法：
- 用高级语言编写整个应用程序
- 对程序进行完整的测试，验证其正确性
- 如果测试后发现需要改进程序性能，就对程序进行分析，确定出热点。
- 把几小段代码在低级语言中重写，以此提高整体性能。

### 变得越多，事情反而越没变 The more things change, the more they stay the same
代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、可维护性方面的代价。
恪守“**对每一次的改动进行量化**”的准则，是抵御思考成熟前匆忙优化之诱惑的法宝。



## 参考
[1] Steve, McConnell 著, 金戈, 汤凌, 陈硕, & 张菲. (2011). 代码大全(第2版). 电子工业出版社.