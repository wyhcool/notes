---
title: 【代码大全2】01 打好基础 Laying the foundation
date: 2018-08-03 22:38:25
tags:
categories:
- Programming
---

## 第1章 软件构建 Software Construction
### 什么是软件构建
软件开发过程中的活动(activity)：
- 定义问题(problem definition)
- 需求分析(requirements development)
- 规划构建(construction planning)
- 软件架构(software architecture)，或高层设计(high-level design)
- 详细设计(detailed design)
- 编码与调试(coding and debugging)
- 单元测试(unit testing)
- 集成测试(integration testing)
- 集成(integration)
- 系统测试(system testing)
- 保障维护(corrective maintenance)

软件构建主要关注于**编码和调试**，同时也包含详细设计、单元测试、集成测试等一系列活动。
<!-- more -->
软件构建活动中的具体任务(task)：
- 验证相关的基础工作已经完成，因此构建活动可以顺利地进行下去
- 确定如何测试所写的代码
- 设计并编写类(class)和子程序(routine)
- 创建并命名变量(variable)和常量(constant)
- 选择控制结构(control structure)，组织语句块
- 单元测试和集成测试，排除其中错误
- 评审开发团队其他成员的底层设计和代码，并让他们评审你的工作，代码检视(code review)
- 润饰代码，仔细地进行代码的格式化和注释(comments)
- 将单独开发的多个软件组件集成为一体
- 调整代码(turning code)，让它更快、更省资源

### 为什么软件构建是如此重要
软件构建是软件开发的核心工作。
软件构建的产物 —— 源代码 —— 往往是对软件的唯一精确描述。

## 第2章 用隐喻来更深刻地理解软件开发
### 什么是隐喻 Metaphor
**重要的研究成果常常产自类比(analogy)**。
通常把不太理解的东西和较为理解的、且十分类似的东西做比较，你可以对这些不太理解的东西产生更甚深刻的理解，这种使用隐喻的方法叫做建模(modeling)。
**模型的威力在于生动性**，能被多数人理解，减少不必要的沟通和误解，学习和教授更为快速。
隐喻是对概念进行的内在化(internalizing)和抽象(abstracting)的一种途径，让人在更高的层面上思考问题，从而避免低层次的错误。
一个好的隐喻，应该是简单的，它与另一些相关的隐喻联系密切，且能够解释大部分实验证据及其他已观测到的现象。
科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列“从不太合适”的隐喻到“更好更贴切”的隐喻的转变。

### 如何使用隐喻
隐喻的作用更像是启示(heuristic，启发)，而不是算法(algorithm)。
算法是一系列定义明确的指令，用以完成某个特定的任务。算法是可预测的(predictable)、确定性的(deterministic)、不易变化的(not subject to change)。
算法和启发式方法的差别在于其距离最终解决问题办法的间接程度：算法直接给出解决问题的指导，启发式方法则告诉如何发现指导信息。
编程最大的挑战在于将问题概念化(conceptualizing)。
使用隐喻来提高你对编程问题和编程过程的洞察力，帮助你思考编程过程中的活动，想出更好的做事情的方法。

### 常见的软件隐喻
#### 软件中的书法：写作代码 Software penmanship: Writing code
软件开发的最原始的隐喻是：写作代码，暗示着开发一个程序就像写一封有缘由的书信一样。
程序的编程风格与书信的文体类似。
程序的可读性与书信的可读性类似。
书写通常是个人的活动，而一个软件项目多半会涉及承担许多不同职责的很多人。
书写一封信寄出去就结束了，即再也不能修改它，而软件很难说有真正完全结束的时候。
书写最重要的是原创性，而对于软件构建来说，努力创造真正的原创成果的开发效率，往往低于专注于复用(reuse)以往项目的一些设计思想、代码以及测试用例(test case)的开发效率。
不幸的是，文字写作这一隐喻暗示着软件开发过程是一种代价昂贵的试错(trial and error)过程，而非仔细的规划和设计，因为我们经常可以看到：被扔进纸篓里的成堆的半成品草稿。因此，将书写软件这个隐喻若引申为“计划扔掉一个软件”，这绝对是糟糕的建议。诀窍在于当第一次尝试的时候就让它成功，或者在成本最低的时候多试几次。

#### 软件的耕作法：培植系统 Software farming: Growing a system
将创造软件想象成类似播种和耕作的情形，你一次设计系统的一小部分，写出一段代码，做一点测试，并将成果一点点添加到整个系统中，通过这种小步前进(增量)，你可以把每次可能遇到的麻烦减到最小。
软件耕作这一隐喻的弱点在于暗示人们将无法对开发软件的过程和方式进行任何直接的控制。在春天播下代码的种子，然后按照农历节气施肥蔬果，再许几个愿，你将在秋天收获丰收的代码😂。

#### 软件的牡蛎养殖观点：系统生长 Software oyster farming: System accretion
在谈论培育(growing)软件时，有时人们实际是指软件的生长(accretion)。生长是通过外在的增加或吸收而逐渐变大变强，生长这个词描述了牡蛎制造珍珠的过程，逐渐地增添微量的碳酸钙，因此，需要学会如何一次为软件系统增加一个小部分。跟生长密切相关的一些词语有：增量的(incremental)，迭代的(iterative)，自适应的(adaptive)，演进的(evolutionary)。
**以增量方式进行设计、编译和测试，是目前已知的最强有力的软件开发概念**。
增量式开发的优势在于未做出过度的承诺。

#### 软件构建：建造软件 Software construction: Building software
建造软件这一说法暗示了软件开发中存在着诸多阶段，如计划、准备及执行等，根据所建造软件的不同，这些阶段的种类和程度可能会发生变化。
在简单结构上犯下错误，其惩罚也不过是一点时间，或是些许尴尬。
**精心计划，并非意味着事无巨细的计划或者过度的计划。一项规划得当的项目能够提升你“在后期改变细节(设计)”的能力**。
在软件开发中，通常你只需要用灵活的、轻量级(lightweight)的方法，但有时必须得用严格的、重量级的开发方法，正如建筑业中，盖间仓库或者工具房、或是一座医院或者核反应站，在规划、设计及质量保证方面所达到的程度是不一样的。
软件变动中，对软件进行结构性的修改所需花费的成本，肯定也比仅仅删除一些周边功能要高。
对于超大型的项目，结构一旦出现问题，后果将非常严重，因此需要对这样的结构进行超常规的规划与建设(over-engineered)，与之相当水准的技术和管理控制也是必需的。
按房屋建筑所作的这一隐喻，引申出许多软件开发术语：软件架构(建筑学，architecture)、支撑性测试代码(脚手架，scaffolding)、构建(建设，construction)、基础类(foundation classes)以及分离代码(tearing code apart)等。

#### 应用软件技术：工具箱 Applying software techniques: the intellectual toolbox
好的工匠知道完成某项工作要用到哪样工具，也知道该怎样正确地使用。
程序员也是这样，编程方面的知识学得越多，你脑中的工具箱中就会有更多的分析工具，也会知道该在何时用这些工具，以及怎样正确地使用它们(因地制宜)。
工具箱隐喻能够帮助你把所有的方法、技术以及技巧留在脑海中，合适的时候即可拿来就用。

### 组合各种隐喻 Combining metaphors
不同的隐喻并不排斥，可以选用一种隐喻或是一些隐喻的组合，只要它能激发你的思维灵感，并让你和团队其他成员更好地沟通。
适当地引申隐喻的含义，才能从其蕴含的深刻启发中受益。若过分地或者在错误地方向上引申会误导人。

## 第3章 三思而后行：前期准备 Measure twice, cut once: upstream prerequisites
无论何种项目，都会对“准备工作”进行剪裁，使之符合项目的特定需要，在构建活动开始之前，准备工作要做周全。
### 前期准备的重要性 Importance of prerequisites
高质量的实践方法在项目的初期、中期、末期都强调质量。
在项目的末期强调质量，则强调的是系统测试。**但是测试只是完整的质量保证策略的一部分，但不是最有影响的部分。测试是不能检查出诸如“制造了一个错误的产品”或者“使用错误的方法制造正确的产品”之类的缺陷的，这样的缺陷必须在构建活动之前解决**。
在项目的中期强调质量，则强调的是构建实践。
在项目的初期强调质量，则强调的是计划、要求并且设计一个高质量的产品。
**在项目的初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大**。
**准备工作的中心（根本）目标就是降低风险**。一个好的项目规划者能够尽可能早地将主要的风险清除掉，以使项目的大部分工作能够尽可能平稳地进行。
#### 准备不周全的原因
造成准备工作不充分的一个常见原因是：那些分配去做前期准备活动的开发人员并不具备完成这一任务的专业技能。
第二个原因是管理者们对那些“花时间进行构建活动的前期准备的程序员”的冷漠。人生苦短，当有大量的更好的选择摆在面前时，在一个蛮荒的软件企业中工作是不明智的。记住，优秀的程序员永远是紧缺的。
#### 构建之前要做前期准备的论据
在实现一个系统之前，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。
##### 诉诸逻辑 appeal to logic
从管理的角度看，做计划意味着确定项目所需要用的时间、人数及机器数量；从技术的角度讲，做计划意味着弄清楚你想要建造的是什么，以防止浪费钱去建造错误的东西。
##### 诉诸类比 appeal to analogy
**在做软件时，必须按正确的顺序去做事情，程序员是软件食物链的最后一环，架构师吃掉需求，设计师吃掉架构，而程序员则消化设计**。
##### 诉诸数据 appeal to data
发现错误的时间要尽可能接近引入该错误的时间。缺陷在软件食物链里呆的时间越长，对食物链的后级造成的损害就越严重。
**修复缺陷的成本随着“从引入缺陷到检测该缺陷之间的时间”变长而急剧增加。**

### 辨明你所从事的软件的类型
不同种类的软件项目，需要在“准备工作”和“构建活动”之间作出不同的平衡。
最常见的软件项目种类：商业系统、使命攸关的系统、性命攸关的嵌入式系统。
开发商业系统的项目往往受益于高度迭代的开发法，这种方法的“计划、需求、架构”活动与“构建、系统测试、质量保证”活动交织在一起。
性命攸关的系统往往要求采用更加序列式的方法，“需求稳定”是确保“超高等级的可靠性”的必备条件之一。
选择序列式开发方法的原因：
- 需求相当稳定
- 设计直截了当，而且理解透彻
- 开发团队对这一应用领域非常熟悉
- 项目的风险很小
- “长期可预测性”很重要
- 后期改变需求、设计和编码的代价很可能较昂贵

选择迭代式开发方法的原因：
- 需求并没有被理解透彻，或者出于其他理由你认为它是不稳定的
- 设计很复杂，或者有挑战性
- 开发团队对这一应用领域不熟悉
- 项目包含许多风险
- “长期可预测”不重要
- 后期改变需求、设计和编码的代价很可能较低

### 问题定义的先决条件 Problem-definition prerequisite
在开始构建之前，首先要满足的一项先决条件是：对这个系统要解决的问题做出清楚的陈述。
“问题定义”只定义了“问题是什么”，而不涉及任何可能的解决方案。
问题定义在具体的需求分析工作之前，而需求分析是对所定义的问题的深入调查。
**问题定义应该用客户的语言来书写，应该从客户的角度来描述问题。**
反之，如果没有一个良好的问题定义，你努力解决的可能是一个错误的问题。

### 需求的先决条件 Requirements prerequisiste
“需求”详细描述软件系统应该做什么，这是达成解决方法的第一步。
#### 为什么要有正式的需求 Why have official requirements
明确的需求有助于确保用户(而非程序员)驾驭系统的功能。
明确的需求有助于避免争论，解决分歧。
重视需求有助于减少开始编程开发之后的系统变更情况。
**充分详尽地描述需求，是项目成功的关键**。如果没有好的需求，你也许会对问题有总体的把握，但却没有击中问题的特定方面。
#### 需求稳定是神话 The myth of stable requirements
对于一个典型的项目来说，在编写代码之前，客户无法可靠地描述他们想要的是什么。客户参与项目的时间越长，他们对项目的理解也就越深入。**开发过程能够帮助客户更好地理解自己的需求，这是需求变更的主要来源**。
#### 在构建期间应对需求变更
- 核和需求，如果需求不够好，那么就停止工作，退回去，先把需求做好，再继续前进。
- 确保每一个人都知道需求变更的代价，明确“进度”和“成本”。
- 建立一套变更控制程序，考虑建立一个正式的变更控制委员会（Configuration Control Board，CCB），评审提交上来的更改方案。
- **使用能适应变更的开发方法，演进原型(evolutionary prototyping)法能让你在投入全部精力建造系统之前，先探索系统的需求。演进交付(evolutionary delivery)是一种分阶段交付系统的方法，你可以建造一小块、从用户获得一点反馈、调整一点设计、做少量改动，再多建造一块。关键在于缩短开发周期，以便更快响应用户的要求。**
- 放弃该项目，若需求特别糟糕，或者极不稳定，而上边的建议无一奏效。
- 注意项目的商业案例，考虑需求变更所带来的商业影响。

<hr />

#### 需求核对表 Checklist: Requirements
##### 针对功能需求
- 是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等
- 是否详细定义了系统的全部输出，包括其目标、精度、取值范围、出现频率等
- 是否详细定义了所有的输出格式（web页面，报表，文档等）
- 是否详细定义了所有硬件及软件的外部接口
- 是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等
- 是否列举完全了用户想要做的全部事情
- 是否详细定义了每个任务所用的数据，以及每个任务得到的数据

##### 针对非功能需求（质量需求）
- 是否为全部的必要操作指定了预期的响应时间
- 是否详细描述了其他与时间相关的事项，包括处理时间、数据传输速率，系统吞吐量等
- 是否详细定义了安全级别
- 是否详细定义了可靠性，包括软件故障的后果、发生故障时需要保护的重要信息、错误检测、恢复策略等
- 是否详细定义了机器内存和剩余磁盘空间的最小值
- 是否详细定义了系统的可维护性，包括适应特定功能的变更、操作系统的变更、与其他软件的接口的变更能力等

##### 需求的质量
- 每条需求与待解决的问题及其解决方案相关吗(可溯性)
- 需求是否足够清晰
- 每条需求都不与其他需求冲突吗
- 是否避免在需求中规定设计方案
- 每条需求在详细程度上是否保持相当一致的水平
- 是否每条需求都是可测试的
- **是否详细描述了所有可能的对需求的改动**

##### 需求的完备性
- 是否详细描述了信息不完全的区域
- 如果产品满足所有需求，那么它就是可接受的吗
- 你对全部需求感到舒服吗？是否已经去掉了那些不可能实现的只是为了安抚客户和老板的部分

<hr />

### 架构的先决条件 Architecture prerequisite
软件架构(software architecture)是软件设计的高层部分，是用于支撑更细节的设计的框架。
架构比需求离构建活动又近了一步。
架构的质量决定了系统的“概念完整性”，继而决定了系统的最终质量。离开了良好的软件架构，你可能瞄准了正确的目标，但却是用了错误的解决方案，也许完全不可能有成功的构建。

#### 架构的组成部分 Typical architectural components
通过以下这些来评估架构的质量。
##### 程序组织 Program organization
系统架构首先要以概括的形式对系统做一个综述。
**必须有一份对设计实践的综述发现，描述其他组织结构，才能说明架构最终选定的这种系统组织结构的缘由，“维护设计的缘由”至少与“维护设计本身”一样重要**。
**架构应该定义程序的主要构造块(building blocks)**。每个构造块无论是一个类还是一组协同工作的类和子程序，他们共同实现一种高层功能，诸如与用户交互、显示web页面、解释命令、封装业务规则、访问数据等。每条列在需求中的功能特性(feature)都至少应该有一个构造块覆盖它，如果两个或多个构造块都实现同一项功能，那么他们应该相互配合而不会冲突。
**应该明确定义各个构造块的责任**。每个构造块应该负责某一区域的事情，并且对其他构造块负责的区域知道的越少越好，将设计的信息局限于各个构造块之内。
**应该明确定义每个构造块的通信规则**。对于每个构造块，架构应该描述它能直接使用哪些构造块、能间接使用哪些构造块、不能使用哪些构造块。
##### 主要的类 Major classes
架构应该详细定义所用的主要类。指出每个主要类的责任，以及该类如何与其他类交互。它应该包含对类的继承体系、状态转换、对象持久化等的描述。
**架构应该记述曾经考虑过的其他类设计方案，并给出选用当前的组织结构的理由**。
架构无须详细说明系统中的每一个类，**瞄准 80/20 法则：对那些构成系统 80% 的行为的 20% 的类进行详细说明**。
##### 数据设计 Data design
架构应该描述所用到的主要文件和数据表的设计。
**架构应该描述曾经考虑过的其他方案，并说明选择的理由**。比如架构师决定使用顺序访问的列表(sequential-access list)来维护客户ID列表，那么文档就应该解释为什么顺序访问的列表比随机访问的列表(random-access list)、堆栈、散列表要好。在构建期间，这些信息让你能洞察架构师的思想。在维护阶段，这种洞察力是无价之宝。
数据通常只是应该由一个子系统或一个类直接访问。
架构应该详细定义所用数据库的高层组织结构和内容。架构应该解释为什么单个数据库要比多个数据库要好（反之亦然），解释为什么不用平坦的文件而要用数据库，指出程序访问同一数据的可能的交互方式，说明会创建哪些数据视图(view)等等。
##### 业务规则 Business rules
如果架构依赖于特定的业务规则，那么就应该详细描述这些规则，并描述这些规则对系统设计的影响。
比如要求客户信息过时的时间不能超过 30 秒，那么架构应该描述这条规则对架构采用的“保持客户信息及时更新且同步”的方法的影响。
##### 用户接口设计 User interface design
用户接口常常在需求阶段进行详细设计，若没有，就应该在软件架构中进行详细说明。架构应该详细定义 Web 页面格式、GUI（图形用户界面，Graphical User Interface）、命令行接口（cli，command line interface）。
**架构应该模块化，以便在替换为新用户接口时不影响业务规则和程序的输出部分**。比如砍掉交互式界面的类，插入一组命令行的类，尤其是因为命令行界面便于单元级别和子系统级别的软件测试。
##### 资源管理 Resource management
架构应该描述一份管理稀缺资源的计划。稀缺资源包括数据库连接、线程、句柄(handle)等。在内存受限的应用领域，比如驱动程序开发和嵌入式系统中，内存管理是架构应该认真对待的另一重要领域。
**架构应该估算在正常情况和极端情况下的资源使用量**。
##### 安全性 Security
**架构应该描述实现设计层面和代码层面的安全性的方法**。
如果先前尚未建立威胁模型(threat model)，那么就应该架构阶段建立威胁模型。
在制定编码规范的时候把安全性牢记心中，包括处理缓冲区的方法、处理非受信(untrusted)数据(用户输入的数据、cookie、配置数据和其他外部接口输入的数据)的规则、加密、错误消息的细致程度、保护内存中的秘密数据等等。
##### 性能 Performance
如果需要关注性能，那么应该在需求中定义性能目标。性能目标可以包括资源的使用，应该详细定义资源(速度、内存、成本)之间的优先顺序。
架构应该提供估计的数据，并解释为什么架构师相信能达到性能目标。如果某些部分存在达不到性能目标的风险，那么架构也应该明确指出来。如果为了满足性能目标，需要在某些部分使用特定的算法或数据结构，架构也应该说清楚。架构中也可以包括各个类或各个对象的空间和时间预算。
##### 可伸缩性 Scalability
可伸缩性是指系统增长以满足未来需要的能力。
架构应该描述系统如何应对用户数量、服务器数量、网络节点数量、数据库记录数、数据库记录的长度、交易量等等的增长。
如果预计系统不会增长，而且可伸缩性不适问题，那么架构应该明确指出这一假设。
##### 互用性 Interoperability
如果预计这个系统会与其他软件或硬件共享数据或资源，架构应该描述如何完成这一任务。
##### 国际化/本地化 Internationalization/Localization
国家化是一项准备让程序支持多个 locales(地域/文化)的技术活动。
国家化常常称为“I18n”，因为 Internationalization 首尾两个字符 I 和 N 之间一共有18个字母。同理，本地化常常称为“L10n”。
对交互系统，国家化问题值得在架构中关注。如何无须更改代码就能维护这些字符串，如果将这些字符串翻译为另一种语言而又尽量不影响代码和用户界面，是在代码中直接嵌入字符串，还是将这些字符串封入某个类，并透过类的接口使用它，或者是将这些字符串存入资源文件，架构应说明选用的是哪种方案，并解释原因。
##### 输入输入 Input/output
架构应该详细定义读取策略(reading scheme)是先做(look-ahead)、后做(look-behind)、即时做(just-in-time)。TODO
架构应该描述在哪一层检测 I/O 错误：在字段、记录、流、文件的层次。
##### 错误处理 Error processing
架构中应该清楚地说明“一致地处理错误”的策略。
需要考虑以下问题：
- **错误处理是进行纠正还是仅仅进行检测？**如果是纠正，程序可以尝试从错误中恢复过来。如果是检测，那么程序可以像没有发生任何事一样继续运行，也可以退出。无论哪一种情况，都应该通知用户说检测到一个错误。
- **错误检测是主动还是被动的？**系统可以主动地预测错误，也可以在不能避免错误的时候，被动地响应错误。前者可以扫清障碍，后者可以清除混乱。无论哪种方案，都对用户界面有影响。
- **程序如何传播错误？**程序一旦检测到错误，它可以立即丢弃引发该错误的数据，也可以直接进入错误处理状态，或者可以等到所有处理完成，再通知用户在某个地方发生了错误。
- **错误消息的处理有什么约定？**架构应该建立一套有关错误消息的约定。
- **如何处理异常？**架构应该规定代码何时能够抛出异常，在什么地方捕获异常，如何记录(log)这些异常，以及如何在文档中描述异常等等。
- **在程序的什么层次上处理错误？**架构需要明确是在错误的地方处理，还是将错误传递到专门处理错误的类进行处理，或者是沿着函数调用域往上传递错误。
- **每个类在验证其输入数据的有效性方面需要负何种责任？**是每个类负责验证自己的数据的有效性，还是有一组类负责验证整个系统的数据的有效性？在某个层次上是否可以假设它接收的数据是干净的？
- **你是希望使用运行环境内建的错误处理机制，还是自己新建立的一套机制？**

##### 容错性 Fault tolerance
架构应该详细定义所期望的容错种类。容错是增强系统可靠性的一组技术，包括检测错误，如果可能的话从错误中恢复，如果不能从错误中恢复，则包容其不利影响。
##### 架构可行性 Architectural feasibility
架构应该论证系统的技术可行性。如果在任何一个方面不可行都会导致项目无法实施，那么架构应该说明这些问题是如何经过研究的，必须在全面展开构建之前解决掉这些风险。
##### 过度工程 Overengineering
健壮性(robustness，鲁棒性)是指系统在检测到错误后继续运行的能力。
**如果组成系统的各个部分都只能在最低限度上满足健壮性要求，那么系统整体上是达不到所要求的健壮程度的。在软件中，链条的强度不是取决于最薄弱的一环，而是等于所有薄弱环节的乘积。**
架构应该清楚地指出为了谨慎起见宁可进行过度工程，还是做出最简单的能工作的东西。
##### 关于“买”还是“造”的决策 Buy-vs.-Build decisions
如果架构不采用现货供应的组件，那么就应该说明自己定制的组件在哪些方面胜过现成的程序库和组件。
##### 关于复用的决策 Reuse decisions
如果开发计划提倡使用业已存在的软件、测试用例、数据格式或其他原料，架构应该说明：如何对复用的软件进行加工，使之符合其架构的目标。
##### 变更策略 Change strategy
架构应该清楚地描述处理变更的策略，让架构足够灵活，能够适应可能出现的变化。
**每一项变更都应该干净地融入整体概念**。
##### 架构的总体质量 General architectural quality
**优秀的架构规格书的特点在于：讨论了系统中的类，讨论了每个类背后的隐藏信息，讨论了“采取或排斥所有可能的设计替代方案”的根本理由。**
架构应该是带有少量特别附加物的精炼且完整的概念体系。大型系统的本质问题是维持其“概念完整性”，好的架构设计应该与待解决的问题和谐一致。
架构的目标应该清晰的表述：以系统的可更改性(modifiability)为首要目标的系统设计与以性能方面决不妥协为首要目标的系统设计肯定是不同的。
**架构应该描述所有主要决策的动机**。
**优秀的软件架构很大程度上是与机器和编程语言无关的。当然，你不能忽视构建的环境，但是要尽可能地独立于环境，这样就能抵抗对系统进行过度架构(overarchitect)的诱惑，也避免提前去做那些放到构建设计期间能做得更好的工作。**
架构应该踏在对系统欠描述(underspecifying)和过度描述(overspecifying)之间的那条分界线上。
架构应该明确指出有风险的区域，解释为什么是有风险的，并说明已经采取了哪些步骤以使风险最小化。
架构应该包含多个视角（视图），以帮助程序员完整地理解系统设计，也可以暴露隐藏的错误和不一致的地方。

### 花费在前期准备上的时间长度
一般来说，一个运作良好的项目会在需求、架构及其他前期计划方面投入 10%~20% 的工作量和 20%~30% 的时间。

## 第4章 关键的构建决策
### 选择编程语言
**一套好的符号系统能把大脑从所有非必要的工作中解脱出来，集中精力去对付更高级的问题**。
用来实现系统的编程语言与你的切身利益密切相关，因为从构建的开始到结束你都要沉浸在这种语言中。
- 有丰富的编程经验，使用熟悉的语言的程序员生产率明显要高。
- 使用高级语言的程序员比使用较低级语言的程序员生产率和质量要高。高级语言（C++、Java等）比低级语言（汇编和 C 语言）在生产率、可靠性、简洁性、易理解性都要高。
- 程序语言能表达编程中的各种概念。**你思考的能力取决于你是否知道能够表达该思想的词汇，如果你不知道这些词汇，就无法表达出这种思想，甚至可能不能形成这种思想**。编程语言影响程序员的思维的证据随处可见。
  - 汇编语言(Assembly Language)的每条语句对应一种特定机器的指令，大多数程序员避免使用汇编，除非是为了冲破“执行速度”或“代码大小”的限制。
  - C语言具有结构化的数据、结构化的控制流程、机器无关性以及一套丰富的运算符，具有低级的构建（如位操作），而且是弱类型(weakly typed)的。
  - C++ 是面向对象语言，兼容C，提供了类、多态、异常处理、模板、提供了比C更健壮的类型检查功能、还提供了一套内容广泛而强大的标准库。
  - Java设计为能在任何平台运行，将Java源码转变为字节码，然后在各个平台的虚拟机环境中运行。
  - JavaScript为解释执行的脚本，主要用于客户端编程。
  - SQL语言是查询、更新、管理关系数据库的事实标准，是声明式语言，即不是定义一系列操作，而是定义某些操作的结果。

### 编程约定 Programming conventions
架构的概念完整性与其底层实现之间是不可分割的，“实现”必须与指导该实现的“架构”保持一致，这种一致性是内在的、固有的。这正是变量名称、类名称、子程序名称、格式约定、注释约定等这些针对构建活动的指导方针的关键所在。
**在一个复杂的程序中，架构上的指导方针使得程序的结构平衡，针对构建活动的指导方针则提供了底层的协调，将每个类都衔接到一种完整的设计中，成为其可靠的部件。**
任何大型的程序都需要一个控制结构，该结构可以统一编程语言的细节。大型结构的部分魅力在于，各个具体部件都能反映整体架构的内涵。

### 在技术浪潮中的位置
**技术周期(技术浪潮)意味着不同的编程实践，编程实践取决于你在技术浪潮中的所处的位置。**
在成熟的技术环境下（浪潮的末尾），受益于丰富的软件开发基础设施，有大量的编程语言可供选择，拥有能对这些语言的代码进行完善错误检查的工具，强大的调试工具以及自动的可靠的性能优化工具等等。这样你就可以计划用大部分的时间稳定持续地编写新功能。
在技术浪潮的前期，则与之截然不同。你需要花很大一部分时间用来找出文档中未加说明的编程语言特性，调试程序库代码缺陷带来的错误，修订代码以适应厂商提供的新版本函数库等等。**一些最具创造力的应用程序就是从浪潮早期的程序中涌现出来的**。
**编程工具不应该决定你的编程思路。“在一种语言上编程(programming in a language)”的程序员将他们的思想限制于“语言直接支持的那些构件”，如果语言工具是初级的，那么程序员的思想也是初级的。“深入一种语言去编程(programming into a language)”的程序员首先要决定他要表达思想是什么，然后决定如何使用特定语言提供的工具去表达这些思想。**
大多数重要的编程原则并不依赖特定的语言，而依赖于你使用语言的方式。如果你使用的语言缺乏你希望用的构件，或者倾向于出现其他种类的问题，那么你就应该试着去弥补它，发明你自己的编码约定、标准、类库及其他改进措施。

### 选择主要的构建实践方法
构建实践核对表 Checklist: Major construction practices
#### 编码
- 是否规定了诸如名称、注释、代码格式等编码规定
- 是否规定了由软件架构确定的编码规范，比如如何处理错误条件、如何处理安全性事项、对于类接口有哪些规定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等
- 是否找到了自己在技术浪潮中的位置，并相应调整自己的措施？是否知道如何深入一种语言去编程，而不受限于语言本身

#### 团队工作
- 是否定义了一套集成工序，即规定一套特定的步骤，规定程序员在把代码 check in 到代码库之前，必须履行的步骤
- 程序员是结对编程，还是独自编程，或二者结合

#### 质量保证
- 程序员在编写代码之前，是否先为之编写测试用例
- 程序员会为自己代码写单元测试嘛（先写还是后写）
- 程序员在 check in 代码之前，是否会用调试器单步跟踪整个代码流程吗
- 程序员在 check in 代码之前，是否会进行集成测试
- 程序员会复审(review)或检查别人的代码吗

#### 工具
- 选用版本控制工具
- 选用编程语言及其版本或编译器版本
- 选用某个编程框架(framework)
- 是否决定允许使用非标准的语言特性
- 选用其他工具（编辑器、重构工具、调试器、测试框架、语法检查器）











## 参考
[1] Steve, McConnell 著, 金戈, 汤凌, 陈硕, & 张菲. (2011). 代码大全(第2版). 电子工业出版社.


