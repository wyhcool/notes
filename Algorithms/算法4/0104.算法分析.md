---
title: 算法分析
date: 2020-04-17 00:05:00
tags:
categories:
- 算法与数据结构
---

## 科学方法
理解自然世界的方法对于研究计算机程序的运行时间同样有效：
- 细致观察真实世界的特点，通常还要有精确的测量；
- 根据观察结果提出假设模型；
- 根据模型预测未来的事件；
- 继续观察并核实预测的准确性；
- 如此反复直到确认预测和观察一致。

科学方法的一条关键原则是我们所设计的实验必须是可重现的，这样他人也可以验证假设的真实性。

所有的假设必须是可证伪的，这样才能确认某个假设是错误的，并需要修正。

永远无法知道某个假设是否绝对正确，因为只能验证它和观察的一致性。


## 观察
### 计时器
```java
public class Stopwatch {
    private final long start;
    public Stopwatch() {
        // 返回以毫秒计数的当前时间
        start = System.currentTimeMillis();
    }
    public double elapsedTime() {
        long now = System.currentTimeMillis();
        return (now - start) / 1000.0;
    }
}
```

elapsed 美[ɪˈlæpst] v.(时间) 消逝，流逝;

### 实验数据的分析
根据图表提出关于运行时间的猜想


## 数学模型
一个程序运行的总时间主要和两点有关：
- 执行每条语句的耗时；
- 执行每条语句的频率。

前者取决于计算机、Java 编译器和操作系统，后者取决于程序本身和输入。

### 近似
使用约等于号(~)使我们能够用近似的方式忽略公式中那些非常复杂但幂次较低、且对最终结果的贡献无关紧要的项。

定义：用 ~f(N) 表示所有随着 N 的增大除以 f(N) 的结果趋于 1 的函数。我们用 g(N)~f(N) 表示 g(N)/f(N) 随着 N 的增大趋近于 1。

一般我们用到的近似方式都是 g(N)~af(N)，其中 f(N) = N<sup>b</sup>(logN)<sup>c</sup>，其中 a、b 和 c 均为常数。将 f(N) 称为 g(N) 的增长的数量级。

注意：一般不会指定底数，因为常数 a 能够弥补这些细节。

### 近似运行时间
执行最频繁的指令决定了程序执行的总时间 —— 将这些指令称为程序的内循环。

### 对增长数量级的猜想

### 算法的分析
增长数量级概念将程序和它实现的算法隔离开来，这使我们对算法性能的知识可以应用于任何计算机。

### 成本模型
成本模型定义了所研究算法中的基本操作。

### 总结
对于大多数程序，得到其运行时间的数学模型所需的步骤：
- 确定输入模型，定义问题的规模；
- 识别内循环；
- 根据内循环中的操作确定成本模型；
- 对于给定的输入，判断这些操作的执行频率。


## 增长数量级的分类
对增长数量级的常见假设的总结：

| 描述 | 增长的数量级 |  说明 | 举例 |
|:-|:-|:-|:-|
| 常数级别 | 1 | 普通语句 | 将两个数相加 |
| 对数级别 | logN | 二分策略 | 二分查找 |
| 线性级别 | N | 循环 | 找出最大元素 |
| 线性对数级别 |  N*logN | 分治 | 归并排序 |
| 平方级别 | N<sup>2</sup> | 双层循环 | 检查所有元素对 |
| 立方级别 | N<sup>3</sup> | 三层循环 | 检查所有三元组 |
| 指数级别 | 2<sup>N</sup> | 穷举查找 | 检查所有子集 |

### 常数级别
运行时间的增长数量级为常数的程序完成它的任务所需的操作次数一定，因此它的运行时间不依赖于 N。大多数的 Java 操作所需的时间均为常数。

### 对数级别
运行时间的增长数量级为对数的程序仅比常数时间的程序稍慢。

对数的底数和增长的数量级无关，因为不同的底数仅相当于一个常数因子。

### 线性级别
程序的增长数量级是线性的，它的运行时间和 N 成正比。

### 线性对数级别

### 平方级别

### 立方级别

### 指数级别


## 设计更快的算法
学习程序的增长数量级是为了帮助我们为同一个问题设计更快的算法。

### 下界
为算法在最坏情况下的运算时间给出一个下界的思想是非常有意义的。


## 倍率实验
倍率定理：如果 T(N)~aN<sup>b</sup>lgN，那么 T(2N)/T(N) ~ 2<sup>b</sup>。

证明：T(2N)/T(N) = a(2N)<sup>b</sup>lg(2N)/aN<sup>b</sup>lgN
                = 2<sup>b</sup>(1+l2/lgN)
                ~ 2<sup>b</sup>

### 评估它解决大型问题的可行性
了解程序的运行时间的增长数量级能够为你提供精确的信息，从而理解你能够解决的问题规模的上限。

### 评估使用更快的计算机所产生的价值


## 注意事项
### 大常数
在首项近似中，一般会忽略低级项中的常数系数，但这可能是错的。

要对可能的大常数保持敏感。

### 非决定性的内循环
错误的成本模型可能无法得到真正的内循环，问题的规模 N 也许没有大到对指令的执行频率的数学描述中首项大大超过其他低级项并可以忽略它们的程度。

### 指令时间
每条指令执行所需的时间总是相同的假设并不总是正确的。例如，大多数计算机系统会使用缓存技术来组织内存，在这种情况下访问大数组中的若干个并不相邻的元素所需的时间可能会很长。

### 系统因素
可能干扰到实验的因素必须是可重现的。

原则上来说，系统中运行的其他程序应该是可以忽略或可以控制的。

### 对输入的强烈依赖
在研究程序的运行时间的增长数量级时，首先作出的假设之一就是运行时间应该和输入相对无关。

### 多个问题参量


## 处理对于输入的依赖
### 输入模型
更加小心地对我们所要解决的问题所处理的输入建模。

### 对最坏情况下的性能的保证

### 随机化算法
为性能提供保证的一种重要方法是引入随机性。

### 操作序列
对于许多应用来说，算法的输入可能并不只是数据，还包括用例所进行的一系列操作的顺序。

### 均摊分析
提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊。

例子：基于动态调整数组大小的 Stack 数据结构。

算法分析者的任务就是尽可能地揭示关于某个算法的更多信息，而程序员的任务则是利用这些信息开发有效解决现实问题的程序。


## 内存
典型的 Java 实现使用 8 位表示字节，用 2 字节(16位)表示一个 char 值，用 4 字节(32位)表示一个 int 值，用 8 字节(64位)表示一个 double 或 long 值，用 1 字节表示一个 boolean 值(因为计算机访问内存的方式都是一次 1 字节)。

假设表示机器地址需要 8 字节，这是现在广泛使用的 64 位架构中的典型表示方式，许多老式的 32 位架构只使用 4 字节表示机器地址。

### 对象
一个对象所使用的内存量，需要将所有实例变量使用的内存与对象本身的开销(一般是 16 字节)相加，这些开销包括一个指向对象的类的引用、垃圾收集信息以及同步信息。另外一般内存的使用都会被填充为 8 字节(64位计算机中的机器字)的倍数。

例如，一个 Integer 对象使用 24 字节，其中 16 字节的对象开销，4 字节用于保存它的 int 值，以及 4 个填充字节。

类似地，一个 Date 对象会使用 32 字节，其中 16 字节的对象开销，3 个 int 实例变量各需要 4 字节，以及 4 个填充字节。

对象的引用一般都是一个内存地址，因此会使用 8 字节。

### 链表
嵌套的非静态内部类，还需要额外的 8 字节(用于一个指向外部类的引用)。

一个 Node 对象需要使用 40 字节，其中 16 字节的对象开销，指向 Item 和 Node 对象的引用各需要 8 字节，另外还有 8 字节的额外开销。

### 数组
Java 中的数组被实现为对象，它们一般都会因为记录长度而需要额外的内存。

一个原始数据类型的数组一般需要 24 字节的头信息，其中 16 字节的对象开销，4 字节用于保存长度以及 4 个填充字节，再加上保存值所需的内存。

一个对象的数组就是一个对象的引用的数组，所以应该在对象所需的内存之外加上引用所需的内存。

二维数组是一个数组的数组，每个数组都是一个对象。

### 字符串对象
String 的标准实现包含 4 个实例变量：一个指向字符数组的引用(8字节)和三个 int 值(各4字节)。第一个 int 值描述的是字符数组中的偏移量，第二个 int 值是一个计数器，记录字符串的长度，对象所表示的字符串由 `value[offset]` 到 `value[offset + count - 1]` 中的字符组成，第三个 int 值是一个散列值。

因此每个 String 对象除字符数组之外的所需的内存空间为 40 字节，其中 16 字节的对象开销，三个 int 实例变量各需要 4 字节，再加上数组引用 8 字节，以及 4 个填充字节。

因为 String 的 char 数组常常是在多个字符串之间共享的，因为 String 对象是不可变的，这种设计使 String 的实现能够在多个对象都含有相同的 `value[]` 数组时节省内存。 


### 字符串的值和子字符串
一个长度为 N 的 String 对象一般需要使用 40 字节(String 对象本身)加上(24+2N)字节(字符数组)，总共 (64+2N) 字节。

因为 Java 对字符串的表示希望能够避免复制字符串中的内容，当调用 `substring()` 方法时，就创建了一个新的 String 对象(40字节)，但它仍然重用了相同的 `value[]` 数组，因此该字符串的子字符串只会使用 40 字节的内存。

含有原始字符串的字符数组的别名存在于字符串中，子字符串对象中的偏移量和长度域标记了字符串的位置。换言之，一个子字符串所需的额外内存是一个常数，构造一个字符串所需的时间也是常数。

注意⚠️：确保子字符串的创建所需的空间以及时间和其长度无关是需要基础字符串算法的效率的关键所在。


当涉及函数调用时，内存的消耗就变成了一个复杂的动态过程。当程序调用一个方法时，系统会从内存中的一个特定区域为方法分配所需要的内存，用于保存局部变量，这个趋于叫做栈(Java 系统的下压栈)。当方法返回时，它所占用的内存也被返回给了系统栈。因此，在递归程序中创建数组或是其他大型对象时很危险的。

当通过 new 创建对象时，系统会从堆内存的另一块特定区域为该对象分配所需的内存。所有对象都会一直存在，知道对它的引用消失位置，此时系统的垃圾回收进程会将它所占用的内存收回到堆中。


## 展望
良好的性能是非常重要的，速度极慢的程序和不正确的程序一样无用，所以有必要在一开始就关注程序的运行成本，并时刻关注程序中的内循环代码的组成。

在编程领域中，最常见的错误或许就是过于关注程序的性能。你的首要任务应该是写出清晰正确的代码。仅仅为了提高运行速度而修改程序的事情常常会降低生产效率，因为它会产生复杂而且难以理解的代码。

“不成熟的优化是所有罪恶之源”。

在编程领域中，第二常见的错误或许是完全忽略了程序的性能。当我们需要处理大规模问题时，通常，除了寻找更好的算法之外我们别无选择。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10