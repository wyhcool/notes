---
title: 初级排序算法
date: 2020-04-29 00:30:00
tags:
categories:
- 算法与数据结构
---

排序就是将一组对象按照某种逻辑顺序重新排列的过程。

## 规则
我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键。排序算法的目标是将所有元素的主键按照某种方式排列。

在 Java 中，元素通常都是对象，对主键的抽象描述则是通过内置的机制(Comparable 接口)来完成的。

### 验证
验证排序算法是否都能成功地排序。

### 运行时间
评估算法的性能。

排序成本模型：在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。

### 额外的内存使用
排序算法可以分为两类：除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法，以及需要额外内存空间来存储另一份数组副本的其他排序算法。

### 数据类型
排序算法模版适用于任何实现了 Comparable 接口的数据类型。

在创建自己的数据类型时，只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 compareTo() 方法来定义目标类型对象的自然次序。

对于 v\<w、v=w 和 v>w 三种情况，Java 的习惯是在 v.compareTo(w) 被调用时返回一个负整数、零和一个正整数(一般是 -1、0 和 +1)。

如果 v 和 w 无法比较或者两者之一是 null，v.compareTo(w) 将会抛出一个异常。此外，compareTo() 必须实现一个完整的比较序列：
- 自反性：对于所有的 v，v=v；
- 反对称性：对于所有的 v 和 w，如果 v\<w 则 w>v，如果 v=w，则 w=v。
- 传递性：对于所有的 v、w 和 x，如果 v<=w 且 w<=x，则 v<=x。

compareTo() 实现了我们的主键抽象 —— 它给出了实现了 Comparable 接口的任意数据类型的对象的大小顺序的定义。需要注意的是 compareTo() 方法不一定会用到进行比较的实例的所有实例变量，毕竟数组元素的主键很可能只是每个元素的一小部分。


## 选择排序 Selection Sort
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么他就和自己交换)。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

对于长度为 N 的数组，选择排序需要大约 N<sup>2</sup>/2 次比较和 N 次交换。

选择排序的特点：
- 运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息，一个已经排序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长。
- 数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换，交换次数和数组的大小是线性关系。

*算法 2.1 选择排序*


## 插入排序 Insertion Sort
在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。

与选择排序一样，当前索引左侧的所有元素都是有序的，但是它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。

*算法 2.2 插入排序*

对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要 ~N<sup>2</sup>/4 次比较以及 ~N<sup>2</sup>/4 次交换。最坏情况下需要 ~N<sup>2</sup>/2 次比较以及 ~N<sup>2</sup>/2 次交换，最好情况下需要 N-1 次比较和 0 次交换。

对于一般的部分有序的数组，倒置指的是数组中的两个顺序颠倒的元素，如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。

几种典型的部分有序的数组：
- 数组中每个元素距离它的最终位置都不远；
- 一个有序的大数组接一个小数组；
- 数组中只有几个元素的位置不正确。

插入排序对这样的数组很有效，而选择排序则不然。

插入排序需要的交换次数和数组中倒置的数量相同，需要的比较次数大于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为 0 时，排序就完成了。

每次交换都意味着一次比较，且 1 到 N-1 之间的每个 i 都可能需要一次额外的比较(在 a\[i] 没有达到数组的左端时)。

要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不是总是交换两个元素，这样访问数组的次数就能减半。

总之，插入排序对于部分有序的数组十分高效，也很适合小规模数组。


## 排序算法的可视化

## 比较两种排序算法
对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

## 希尔排序 Shell Sort
基于插入排序的快速的排序算法。

对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。如果主键较小的元素正好在数组的尽头，要将它挪到正确的位置就需要 N-1 次移动。

希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的，这样的数组称为 h 有序数组。换言之，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。

在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用这种方式，对于任意以 1 结尾的 h 序列，我们都能够将数组排序，这就是希尔排序。

比如，算法的实现可以使用序列 1/2(3<sup>k</sup> -1)，从 N/3 开始递减至 1，这个序列被称为递增序列。递增序列可以实时计算，也可以将其存储在一个数组中。

实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是：对数组进行 h 排序时，将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一格类似于插入排序但使用不同增量的过程。

希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后的子数组都是部分有序的，这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。

*算法 2.3 希尔排序*

在插入排序中加入一个外循环来将 h 按照递增序列递减，就能得到一个简洁的希尔排序。增幅 h 的初始值是数组长度乘以一个常数因子，最小为 1。

如何选择递增序列呢？算法的性能不仅取决于 h、还取决于 h 之间的数学性质。

希尔排序对于中等大小的数组它的运行时间是可以接受的，它的代码量很小，且不需要使用额外的内存空间。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10