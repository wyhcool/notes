---
title: 快速排序
date: 2020-05-04 13:14:00
tags:
categories:
- 算法与数据结构
---

快速排序引人注目的特点包括它是原地排序(只需要一个很小的辅助栈)，且将长度为 N 的数组排序所需的时间和 NlgN 成正比。

## 基本算法
快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。

快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将整个数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前，在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分(partition)的位置取决于数组的内容。

快速排序递归地将子数组 a\[lo..hi] 排序，先用 partition() 方法将 a\[j] 放到一个合适位置，然后在用递归调用将其他位置的元素排序。

该方法的关键在于切分，这个过程使得数组满足下面三个条件：
- 对于某个 j，a\[j] 已经排定；
- a\[lo] 到 a\[j-1] 中的所有元素都不大于 a\[j]；
- a\[j+1] 到 a\[hi] 中到所有元素都不小于 a\[j]。

通过递归地调用切分来排序。

因为切分过程总是能排定一个元素，用归纳法来证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组(有序且没有任何元素大于切分元素)、切分元素和右子数组(有序且没有任何元素小于切分元素)组成的结果数组也一定是有序的。

实现切分方法，一般策略是先随意地取 a\[lo] 作为切分元素，然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素，然后交换它们的位置。如此继续，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，只需将切分元素 a\[lo] 和左子数组最右侧的元素 a\[j] 交换然后返回 j 即可。

*算法 2.5 快速排序*

### 原地切分

### 别越界
如果切分元素是数组中最小或最大的那个元素时，需要小心别让扫描指针跑出数组的边界。

### 保持随机性

### 终止循环
保证循环结束需要格外小心。

### 处理切分元素有重复的情况
左侧扫描最好是遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下，尽管这样可能会不必要地将一些等值的元素交换，但它能够避免算法的运行时间变为平方级别。

### 终止递归
保证递归总是能够结束也是需要小心的。


## 性能特点
快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较，这是快速排序的一个优点，而归并排序和希尔排序一般都比快速排序慢，其原因是它们还在内循环中移动数据。

快速排序的另一个速度优势在于它的比较次数较少，排序效率最终还是依赖切分数组的效果，而这依赖于切分元素的值。

快速排序的最好情况是每次都正好将数组对半分。在这种情况下，快速排序所用的比较次数正好满足分治递归的 C<sub>N</sub> = 2C<sub>N/2</sub> + N 公式，2C<sub>N/2</sub> 表示将两个子数组排序的成本，N 表示用切分元素和所有数组元素进行比较的成本。由归并命题的证明可知，这个递归公式的解 C<sub>N</sub>~NlgN。

但平均而言切分元素都能落在数组的中间，将每个切分位置的概率都考虑进去。

将长度为 N 的无重复数组排序，快速排序平均需要 ~2NlnN 次比较(以及 1/6 该次数的交换)。

令 C<sub>N</sub> 为将 N 个不同元素排序平均所需的比较次数，显然 C<sub>0</sub>=C<sub>1</sub>=0，对于 N>1，由递归程序可以得到以下的归纳关系：

C<sub>N</sub> = N + 1 + (C<sub>0</sub> + C<sub>1</sub> + ...C<sub>N-2</sub> + C<sub>N-1</sub>)/N + (C<sub>N-1</sub> + C<sub>N-2</sub> + ... + C<sub>0</sub>)/N

第一项是切分的成本(总是 N+1)，第二项是将左子数组(长度可能是 0 到 N-1)排序的平均成本，第三项是将右子数组(长度和左子数组相同)排序的平均成本。

将等式左右两边乘以 N 并整理各项得到：

NC<sub>N</sub> = N(N + 1) + 2(C<sub>0</sub> + C<sub>1</sub> + ...C<sub>N-2</sub> + C<sub>N-1</sub>)

将该等式减去 N-1 时的相同等式可得：

NC<sub>N</sub>-(N-1)C<sub>N-1</sub> = 2N + 2C<sub>N-1</sub>

整理等式并将两边除以 N(N+1) 可得：

C<sub>N</sub>/(N+1) = C<sub>N-1</sub>/N + 2/(N+1)

归纳法推导可得：

C<sub>N</sub> = 2(N+1)(1/3 + 1/4 + ... + 1/(N+1))

括号内的量是曲线 2/x 从 3 到 N 的离散近似面积，积分得到 C<sub>N</sub> ~ 2NlnN。

注意 2NlnN ≈ 1.39NlgN，也就是说平均比较次数只比最好情况多 39%。

ln10 × lgx = lnx 

ln10 = 2.302585092994

ln2 = 0.69314718055995

快速排序最多需要约 N<sup>2</sup>/2 次比较，但随机打乱数组能够预防这种情况下。

在每次切分后两个子数组之一总是空的情况下，比较次数为：

N + (N-1) + (N-2) + ... + 2 + 1 = (N+1)N/2


## 算法改进
### 切换到插入排序
和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：
- 对于小数组，快速排序比插入排序慢；
- 因为递归，快速排序的 sort() 方法在小数组中也会调用自己。

在小数组时切换到插入排序：
```java
if (hi <= lo + M) { Insertion.sort(a, lo, hi); return; }
```
转换参数 M 的最佳值是和系统相关的，5 ~ 15 之间的任意值在大多数情况下都能令人满意。

### 三取样切分
使用子数组的一小部分元素的中位数来切分数组，这样做得到的切分更好，但代价是需要计算中位数。

取样大小设置为 3 并用大小居中的元素切分效果最好。

可以将取样元素放在数组末尾作为“哨兵”来去掉 partition() 中的数组边界测试。

### 熵最优的排序
在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现。

将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素

Dijkstra 的荷兰国旗问题：荷兰国旗是由红、白、蓝三色组成的。现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。

Dijkstra /ˈdɛɪkstra/ 迪科斯彻

Dijkstra 的三向切分快速排序解法：它从左到右遍历数组一次，维护一个指针 lt 使得 a\[lo..lt-1] 中的元素都小于 v，一个指针 gt 使得 a\[gt+1..hi] 中的元素都大于 v，一个指针 i 使得 a\[lt..i-1] 中的元素都等于 v，a\[i..gt] 中的元素都还未确定。


一开始 i 和 lo 相等，使用 Comparable 接口对 a\[i] 进行三向比较来直接处理以下情况：
- a\[i] 小于 v，将 a\[lt] 和 a\[i] 交换，将 lt 和 i 加一；
- a\[i] 大于 v，将 a\[gt] 和 a\[i] 交换，将 gt 减一；
- a\[i] 等于 v，将 i 加一

这些操作都会保证数组元素不变且缩小 gt-i 的值，这样循环才会结束。另外，除非和切分元素相等，其他元素都会被交换。

给定包含 k 个不同值的 N 个主键，对于从 1 到 k 的每个 i，定义 f<sub>i</sub> 为第 i 个主键值出现的次数，p<sub>i</sub> 为 f<sub>i</sub>/N，即为随机抽取一个数组元素时第 i 个主键值出现的概率，那么所有主键的香农信息量可以定义为：

H = -(p<sub>1</sub>lgp<sub>1</sub> + p<sub>2</sub>lgp<sub>2</sub> + ... + p<sub>k</sub>lgp<sub>k</sub>)

给定任意一个待排序的数组，通过统计每个主键值出现的频率就可以计算出它包含的信息量。

对于包含大量重复元素的数组，三向切分的快速排序将排序时间从线性对数级别降低到了线性级别。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10