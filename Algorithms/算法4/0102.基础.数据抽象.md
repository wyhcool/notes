---
title: 数据抽象
date: 2020-04-09 23:18:00
tags:
categories:
- 算法与数据结构
---

数据类型指的是一组值和一组对这些值的操作的集合。

Java 编程的基础主要是使用 class 关键字构造被称为引用类型的数据类型，这种编程风格也称为面向对象编程，因为它的核心概念是对象，即保存了某个数据类型的值的实体。

抽象数据类型(ADT)是一种能够对使用者隐藏数据表示的数据类型。抽象数据类型的主要不同之处在于它将数据和函数的实现关联，并将数据的表示方式隐藏起来。

在使用抽象数据类型时，注意力集中在 API 描述的操作上而不会关心数据的表示；在实现抽象数据类型时，注意力集中在数据本身将实现对数据的各种操作。

## 使用抽象数据类型
### 抽象数据类型的 API
使用应用程序编程接口(API)来说明抽象数据类型的行为，它将列出所有构造函数和实例方法(即操作)，并简要描述它们的功用。

### 继承的方法
根据 Java 的约定，任意数据类型都能通过在 API 中包含特定的方法从 Java 的内在机制中获益。

### 对象
对象是能够承载数据类型的值的实体。

所有对象都有三大重要特性：状态、标识和行为。
- 状态即数据类型中的值。
- 标识即能够将一个对象区别于另一个对象，也就是在内存中的位置。
- 行为即数据类型的操作。

数据类型的实现的唯一职责就是维护一个对象的身份，这样在使用数据数据类型时只需遵守描述对象行为的 API 即可，而无需关注对象状态的表示方法。

对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变，但数据类型的值的表示细节与用例代码是无关的。

引用是访问对象的一种方式，可认为引用就是内存地址，Java 使用引用类型来和原始数据类型(变量和值相关联)区分。

### 创建对象
每种数据类型中的值都存储于一个对象中，要创建(或实例化)一个对象，用关键字 new 并紧跟类名及 ()(或在括号中指定一系列的参数)来触发它的构造函数。

构造函数没有返回值，因为它总是返回它的构造函数的对象的引用。每当调用 new() 时，系统都会：
- 为新的对象分配内存空间；
- 调用构造函数初始化对象中的值；
- 返回该对象的一个引用。

### 调用实例方法
实例方法的意义在于操作数据类型中的值。

实例方法的特别性质是：方法的每次触发都是和一个对象相关的。

静态方法的主要作用是实现函数；实例方法的主要作用是实现数据类型的操作。

### 使用对象
像使用原始类型的变量使用对象。

### 赋值语句
使用引用类型的赋值语句将会创建该引用的一个副本。赋值语句不会创建新的对象，而只是创建另一个指向某个已经存在的对象的引用。这种情况被称为别名：两个变量同时指向同一个对象。

如果 x 和 y 是原始数据类型的变量，那么赋值语句 x = y 会将 y 的值复制到 x 中。对于引用类型，复制的是引用，而非实际的值。

### 将对象作为参数
Java 将参数值的一个副本从调用端传递给了方法，这种方式称为按值传递。这种方式的一个重要后果是方法无法改变调用端变量的值。

对于原始数据类型来说，这种策略正是我们所期望(两个变量互相独立)。

对于使用引用类型作为参数时，我们创建的都是别名，这种约定会传递引用的值，那么方法虽然无法改变原始的引用，但能够改变对象的值。

### 将对象作为返回值
Java 中的方法只能有一个返回值 —— 有了对象，我们的代码实际上就能返回多个值。

### 数组也是对象
在 Java 中，所有非原始数据类型的值都是对象。

### 对象的数组
创建一个对象的数组需要以下两个步骤：
- 使用方括号语法调用数组的构造函数创建数组；
- 对于每个数组元素调用它的构造函数创建相应的对象。


运用数据抽象的思想编写代码(定义和使用数据类型，将数据类型的值封装在对象中)的方式称为面向对象编程。


## 抽象数据类型举例
Java 语言内置了上千种抽象数据类型，可以被分为以下几类：
- java.lang.* 中的标准系统抽象数据类型，可以被任意 Java 程序调用。
- java 标准库中的抽象数据类型，如 java.awt、java.net 和 java.io，它们也可以被任意 Java 程序调用，但需要 import 语句。
- I/O 处理类抽象数据类型，允许处理多个输入输出流。
- 面向数据类抽象数据类型，它们的主要用途是通过封装数据的表示简化数据的组织和处理。
- 集合类抽象数据类型，它们的主要用途是简化对同一类的一组数据的操作。
- 面向操作的抽象数据类型，可以用它们来分析各种算法。
- 图算法相关的抽象数据类型，它们包括一些用来封装各种图的表示的面向数据的抽象数据类型，和一些提供图的处理算法的面向操作的抽象数据类型。

### 几何对象

### 信息处理

### 字符串
一个 String 值是一串可以由索引访问的 char 值。

字符数组能够通过 Java 语言的内置语法访问每个字符，String 则为索引访问、字符串长度以及其他许多操作准备了实例方法，同时，Java 语言为 String 的初始化和连接提供了特别的支持：可以使用字符串字面量而非构造函数来创建并初始化一个字符串，可以直接使用 + 运算符代替 concat() 方法。

### 输入输出


## 抽象数据类型的实现
使用 Java 的类(class)实现抽象数据类型并将所有代码放入一个和类名相同并带有 .java 扩展名的文件中。

文件的第一部分语句会定义表示数据类型的值的实例变量，之后是实现对数据类型的值的操作的构造函数和实例方法。实例方法可以是公共的(在 API 中说明)或是私有的(用于辅助计算，用例无法使用)。

一个数据类型的定义中可能包含有多个构造函数，而且有可能含有静态方法，特别是单元测试用例 main()，它通常在调试和测试中很实用。

### 实例变量
要定义数据类型的值(即每个对象的状态)，需要声明实例变量。

实例变量与静态方法或是某个代码段中的局部变量最关键的区别在于：每一时刻每个局部变量只会有一个值，但每个实例变量则对应这无数值（数据类型但每个实例对象都会有一个）。

每个实例变量的声明都需要一个可见性修饰符。使用 private 来保证向使用者隐藏抽象数据类型的数据表示。如果该值在初始化后不应该再被改变，使用 final 修饰符。

### 构造函数
每个 Java 类都至少有一个构造函数以创建一个对象的标识。

一般来说，构造函数的作用是初始化实例变量，每个构造函数都将创建一个对象并向调用者返回一个该对象的引用。

构造函数的名称总是和类名相同，可以重载这个名称并定义签名不同的多个构造函数。

如果没有定义构造函数，类将会隐式定义一个默认情况下不接受任何参数的构造函数并将所有实例变量初始化为默认值：
- 原始数字类型的实例变量默认值为 0；
- 布尔类型变量为 false；
- 引用类型变量为 null。

### 实例方法
每个实例方法都有一个返回值类型、一个签名（它指定了方法名、返回值类型和所有参数变量的名称）和一个主体（它由一系列语句组成，包括一个返回语句来将一个返回类型的值传递给调用者）。

面向对象编程为 Java 程序增加了另一种使用变量的重要方式：通过触发一个实例方法来操作该对象的值。

### 作用域
在实例方法的 Java 代码中使用了三种变量：
- 参数变量；
- 局部变量；
- 实例变量。

方法的签名定义了参数变量，在方法被调用时参数方法会被初始化为调用者提供的值。参数变量的作用域是整个方法。

局部变量的声明和初始化都是在方法的主体中。局部变量的作用域是当前代码段中它的定义之后的所有语句。

实例变量为该类的对象保存了数据类型的值，它的作用域是整个类（如果出现二义性，可以使用 this 前缀来区别）。

### API、用例与实现
定义抽象数据类型的步骤：
- 定义一份 API：API 的作用是将使用与实现分离，以实现模块化编程。
- 用一个 Java 类实现 API 的定义：选择适当的实例变量，然后编写构造函数和实例方法。
- 实现多个测试用来验证前两步做出的设计决定。


## 更多抽象数据类型的实现
在实现中使用数据抽象的一个关键优势是我们可以将一种实现替换为另一种而无需改变用例的任何代码。

### 日期
将 d 日、m 月和 y 年的一个日期表示为一个混合制的整数：512y + 32m + d。

### 维护多个实现
命名约定：
- 通过前缀的描述性修饰符区别同一份 API 的不同实现。
- 维护一个没有前缀的参考实现，它应该适合大多数用例的需求。

### 累加器

### 可视化的累加器


## 数据类型的设计
抽象数据类型是一种向用例隐藏内部表示的数据类型。

### 封装
面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发。

封装实现了模块化编程，它允许我们：
- 独立开发用例和实现的代码；
- 切换至改进的实现而不会影响用例的代码；
- 支持尚未编写的程序

封装同时也隔离数据类型的操作，这使我们可以：
- 限制潜在的错误；
- 在实现中添加一致性检查等调试工具；
- 确保用例代码更明晰。

模块化编程成功的关键在于保持模块的独立性。

坚持将 API 作为用例和实现之间唯一的依赖点来做到这一点⬆️，并不需要直到一个数据类型是如何实现的才能使用它，实现数据类型时也应该假设使用者除了 API 什么也不知道。

### 设计 API
理想情况下，一份 API 应该能够清楚地说明所有可能的输入和副作用，然后我们应该先写出检查实现是否与 API 相符的程序。

只为用例提供它们需要的，仅此而已。


### 算法与抽象数据类型
数据抽象天生适合算法研究。

### 接口继承 Interface inheritance
Java 语言为定义对象之间的关系提供了支持，称为接口。

第一种继承机制叫做子类型(subtyping)，它允许我们通过指定一个含有一组公共方法的接口为两个本来没有关系的类建立一种联系，这两个类都必须实现这些方法。

接口继承使得程序能够通过调用接口中的方法操作实现该接口的任意类型的对象（甚至是还未创建的类型）。

### 实现继承 Implementation inheritance
第二种继承机制叫做子类(subclassing)，它使我们不需要重写整个类就能改变它的行为或者为它添加新的功能。

它的主要思想是定一个新类(子类、或称为派生类 subclass, or derived class)来继承另一个类(父类，或称为基类 superclass, or base class)的所有实例方法和实例变量。

子类包含的方法比父类更多，同时子类可以重新定义或这重写父类的方法。

子类继承会破坏封装，但这种机制是 Java 的一部分，因此它的残余是无法避免的：每个类都是 Java 的 Object 类的子类，这种结构意味着每个类都含有 getClass()、toString()、equals()、hashCode() 等方法。

### 字符串表示的习惯
每个 Java 类型都会从 Object 类继承 toString() 方法，因此任何用例都能够调用任意对象的 toString() 方法。

当连接运算符的一个操作数是字符串时，Java 会自动将另一个操作数也转换为字符串，这个约定是自动转换的基础。

如果一个对象的数据类型没有实现 toString() 方法，那么转换会调用 Object 的默认实现，默认它会返回一个含有该对象内存地址的字符串，一般没有多大的实用价值。

通常为每个类实现并重写默认的 toString() 方法。

### 封装类型
Java 提供了一些内置的引用类型，称为封装类型。每种原始数据类型都有一个对应的封装类型：
- Boolean -> boolean
- Byte -> byte
- Character -> char
- Double -> double
- Float -> float
- Integer -> int
- Long -> long
- Short -> short

在需要的时候，Java 会自动将原始数据类型转换为封装类型。

### 等价性
Java 约定 equals() 必须是一种等价关系，它必须具有：
- 自反性：x.equals(x) 为 true。
- 对称性：当且仅当 y.equals(x) 为 true 时，x.equals(y) 返回 true。
- 传递性：如果 x.equals(y) 和 y.equals(x) 均为 true，x.equals(z) 也将返回 true。

另外，它必须接受一个 Object 为参数并满足以下性质：
- 一致性：当两个对象均未被修改时，反复调用 x.equals(y) 总是会返回相同的值。
- 非空性：x.equals(null) 总是返回 false。

比如 Date 类覆盖 equals() 方法实现的步骤：
- 如果该对象的引用和参数对象的引用相同，返回 true。这项测试在成立时能够免去其他所有测试工作。
- 如果参数为空(null)，根据约定返回 false。还可以避免在之后的代码中使用空引用。
- 如果两个对象的类不同，返回 false。要得到一个对象的类，可以使用 getClass() 方法。注意使用 == 来判断 Class 类型的对象是否相等，因为同一种类型的所有对象的 getClass() 方法一定能够返回相同的引用。
- 将参数对象的类型从 Object 转换到 Date。因为前一项测试已经通过，这种转换必然成功。
- 比较实例域。如果任意实例变量的值不相同，返回 false。

### 内存管理
Java 最重要的一个特性就是自动内存管理，它通过记录孤儿(orphaned)对象并将它们的内存释放到内存池中，将程序员从管理内存的责任中解放出来。这种回收内存的方式叫做垃圾回收。

### 不可变性
不可变数据类型指的是该类型的对象中的值在创建之后就无法再被改变。与此相反，可变数据类型能够操作并改变对象中的值。

Java 语言通过 final 修饰符来强制保证不可变性。将一个变量声明为 final 时，也就保证了只会对它赋值一次。试图改变 final 变量的值的代码将会产生一个编译错误。

可变数据类型，必须时刻关注它们的值会在何时何地发生改变。

不可变的数据类型更容易使用，缺点在于需要为每个值创建一个新对象。

final 只能用来保证原始数据类型的实例变量的不可变性，而无法用于引用类型的变量。如果一个引用类型的实例变量含有修饰符 final，该实例变量的值就永远无法改变了 —— 它将永远指向同一个对象，但对象的值本身仍然是可变的。

<font color="green">任何数据类型的设计都需要考虑到不可变性，而数据类型是否不可变的则应该在 API 中说明。</font>

### 契约式设计
Java 语言能够在程序运行时检验程序状态的机制：
- 异常(Exception)，一般用于处理不受我们控制的不可预见的错误；
- 断言(Assertion)，验证我们在代码中做出的一些假设。

### 异常与错误
异常和错误都是在程序运行中出现的破坏性事件。

Java 采取的行动是抛出异常或是抛出错误。

快速出错的编程实践：一旦出错就立刻抛出异常，使定位出错位置更容易。

### 断言
断言是一条需要在程序的某处确认为 true 的布尔表达式。如果表达式的值为 false，程序将会终止并报告一条出错信息。使用断言来确定程序的正确性并记录我们的意图。

默认设置没有启用断言，可以在命令行下使用 `-enableassertions`(-ea) 标志启用断言。

断言的作用是调试：程序在正常操作中不应该依赖断言，因为它们可能会被禁用。

数据类型的设计者需要说明：
- 前提条件（用例在调用某个方法时必须满足的条件）；
- 后置条件（实现在方法返回时必须达到的要求）；
- 副作用（方法可能对对象状态产生的任何其他变更）。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10