---
title: union-find 算法
date: 2020-04-22 23:55:00
tags:
categories:
- 算法与数据结构
---

## 动态连通性
问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数 p 和 q 可以被理解为 p 和 q 是相连的。我们假设相连是一种对等的关系，这也就意味着它具有：
- 自反性：p 和 p 是相连的；
- 对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的；
- 传递性：如果 p 和 q 是相连的，且 q 和 r 是相连的，那么 p 和 r 也是相连的。

对等关系能够将对象分为多个等价类，当前仅当两个对象相连时它们才属于同一个等价类。

设计一个数据结构来保存程序已知的所有整数对的足够多的信息，并用它们来判断一对新对象是否相连，这就是动态连通性问题。

在更高的抽象层次上，可以将输入的所有整数看作属于不同的数学集合，在处理一个整数对 p 和 q 时，我们是在判断它们是否属于相同的集合。如果不是，则将 p 所属的集合和 q 所属的集合归并，最终所有的整数属于同一个集合。

为了进一步限定话题，使用网络方面的术语：将对象称为触点，将整数对称为连接，将等价类称为连通分量或是简称分量。

在设计算法时面对的第一个任务就是精确地定义问题。

连通性问题只要求判别给定的整数对 p q 是否连通，但并没有要求给出两者之间的通路上的所有连接。

设计一份 API 来封装所需的操作：
```java
public class UF {
    UF(int N); // 以整数标识(0 到 N-1)初始化 N 个触点
    void union(int p, int q); // 在 p 和 q 之间添加一条连接
    int find(int p); // p 所在的分量的标识符 (0 到 N-1)
    boolean connected(int p, int q); // 判断两个触点是否存在于同一个分量中
    int count(); // 连通分量的数量
}
```
- 如果两个触点在不同的分量中，union() 操作会将两个分量归并。
- find() 操作会返回给定触点所在的连通分量的标识符。
- connected() 操作能够判断两个触点是否存在于同一个分量之中。
- count() 方法会返回所有连通分量的数量。
- 一开始我们有 N 个连通分量，将两个分量归并的每次 union() 操作都会使分量总数减一。

数据结构的性质将直接影响到算法的效率，因此数据结构和算法的设计是紧密相关的。

## 实现
根据以触点为索引的 `id[]` 数组来确定两个触点是否存在于相同的连通分量中。

### quick-find 算法
一种方法是保证当且仅当 `id[p]` 等于 `id[q]` 时 p 和 q 是相通的。换言之，在同一个连通分量中的所有触点在 `id[]` 中的值必须全部相同。

这意味着 connected(p, q) 只需要判断 `id[p] == id[q]`，当且仅当 p 和 q 在同一连通分量中时该语句才会返回 true。

为了调用 union(p, q) 确保这一点，首先要检查它们是否已经存在于同一个连通分量中。如果是则不需要采取任何行动，否则面对的情况是 p 所在的连通分量中的所有触点的 `id[]` 值均为同一个值，而 q 所在的连通分量中的所有触点的 `id[]` 值均为另一个值，要将这两个分量合二为一，必须将两个集合中的所有触点对应的 `id[]` 元素变为同一个值。为此，需要遍历整个数组，将所有和 `id[p]` 相等的元素的值变为 `id[q]` 的值，或者将所有和 `id[q]` 相等的元素的值变为 `id[p]` 的值。

```java
public int find(int p) {
    return id[p];
}
public void union(int p, int q) {
    int pID = find(p);
    int qID = find(q);

    if (pID == qID) return;

    for (int i = 0; i < id.length; i++) {
        if (id[i] == pID) id[i] = qID;
    }
    count--;
}
```

### quick-find 算法分析
find() 操作的速度显然是很快的，因为它只需要访问 `id[]` 数组一次，但是 quick-find 算法一般无法处理大型问题，因为对于每一对输入 union() 都需要扫描整个 `id[]` 数组。

在 quick-find 算法中，每次 find() 调用只需要访问数组一次，而归并两个分量 union() 操作访问数组的次数在 (N+3) 到 (2N+1) 之间。

假设使用 quick-find 算法来解决动态连通性问题并且最后只得到了一个连通分量，那么至少需要调用 N-1 次 union()，即至少 (N+3)(N-1) ~ N<sup>2</sup> 次数组访问，那么 quick-find 算法是平方级别的。

### quick-union 算法
每个触点所对应的 `id[]` 元素都是同一个分量中的另一个触点的名称(也可能是它自己)，这种联系称为链接。

在实现 find() 方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，如此继续跟随着链接直到到达一个根触点，即链接指向自己的触点。

当且仅当分别由两个触点开始的这个过程到达了同一个根触点时它们存在于同一个连通分量之中。

为了保证这个过程的有效性，需要 union(p, q) 来保证这一点，由 p 和 q 的链接分别找到它们的根触点，然后只需要将一个根触点链接到另一个，即可将一个分量重命名为另一个分量，因此这个算法叫做 quick-union。

```java
public int find(int p) {
    // 找出分量的名称
    while (p != id[p]) p = id[p]
    return p;
}
public void union(int p, int q) {
    int pRoot = find(p);
    int qRoot = find(q);

    if (pRoot == qRoot) return;

    id[pRoot] = qRoot;

    count--;
}

```
### 森林的表示
从技术上说，`id[]` 数组用父链接的形式表示了一片森林。

无论我们从任何触点所对应的节点开始跟随链接，最终都将到达含有该节点的树的根节点。

是用归纳法证明上述性质的正确性：
- 在数组初始化之后，每个节点的链接都指向它自己；
- 如果在某次 union() 操作之前这条性质成立，那么操作之后它比如也成立。

quick-union 中的 find() 方法能够返回根节点对应的触点的名称，这样 connected() 才能判断两个触点是否在同一棵树中。

### quick-union 算法分析
在最好的情况下，find() 只需要访问一次就能够得到一个触点所在的分量的标识符；而在最坏的情况下，这需要 (2N-1) 次数组访问。由此不难构造一个最佳情况的输入使得解决动态连通性问题的用例的运行时间是线性级别的；另一方面也可以构造一个最坏情况的输入，此时它的运行时间是平方级别的。

可以将 quick-union 算法看作是 quick-find 算法的一种改良，因为它解决了 quick-find 算法中最主要的问题，union() 操作总是线性级别的。

一棵树的大小是它的节点的数量，树中的一个节点的深度是它到根节点的路径上的链接数。数的高度是它的所有节点中的最大深度。

### 加权 quick-union 算法
与其在 union() 中随意地将一棵树连接到另一个棵树，现在我们会记录每一棵树的大小并总是将较小的树连接到较大的树上。需要添加一个数组和一些代码来记录树中的节点数。

*算法 1.5 union-find 算法(加权 quick-union)的实现*

### 加权 quick-union 算法分析
加权 quick-union 算法的最坏情况，其中将要被归并的树的大小总是相等的，且总是 2 的幂。这些树均含有 2<sup>n</sup> 个节点，因此高度都正好是 n。另外，当归并两个含有 2<sup>n</sup> 个节点的树时，我们得到的树含有 2<sup>n+1</sup> 个节点，由此树的高度增加到了 (n+1)，由此可以证明加权 quick-union 算法能够保证对数级别的性能。

证明：对于 N 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 lgN。

在原始情况下，当 k 等于 1 时树的高度为 0。根据归纳法，假设大小为 i 的树的高度最多为 lgi，其中 i < k。设 i <= j，且 i + j = k，当我们将大小为 i 的树和大小为 j 的树归并时，小树中的所有节点的深度增加了 1，但它们现在所在的树的大小为 i + j = k, 而 1 + lgi = lg(i+i) <= lg(i+j) = lgk，性质成立。

加权 quick-union 算法处理 N 个触点和 M 条连接时最多访问数组 cMlgN 次，其中 c 为常数，能够保证在合理的时间范围内极倔实际中的大规模动态连通性问题。

### 最优算法
理想情况下，我们希望每个节点都直接链接到它的根节点上，但是又不能向 quick-find 那样通过大量修改链接来做到这一点。

我们接近这种理想状态的方式很简单，就是在检查节点的同时将它们直接链接到根节点。要实现路径压缩，只需要为 find() 添加一个循环，将在路径上遇到的所有节点都直接链接到根节点，那么我们得到的结果是几乎完全扁平化的树。


## 展望
研究各种基础问题时都会遵循的基本步骤：
- 完整而详细地定义问题，找出解决问题所必需的基本抽象操作并定义一份 API。
- 简洁地实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入。
- 当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃。
- 逐步改进实现，通过经验性分析或数学分析验证改进后的效果。
- 用更高层析的抽象表示数据结构或算法来设计更高级的改进版本。
- 如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能。
- 在适当的时候将更细致的深入研究留给有经验的研究者并继续解决下一个问题。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10