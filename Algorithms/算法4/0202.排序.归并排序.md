---
title: 归并排序
date: 2020-05-03 18:10:00
tags:
categories:
- 算法与数据结构
---

要将一个数组排序，可以先递归地将它分成两半分别排序，然后将结果归并起来。

归并排序最吸引人的性质是它能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；它的主要缺点则是它所需的额外空间和 N 成正比。

## 原地归并的抽象方法
实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素应该都实现了 Comparable 接口。

但是，当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。因此我们希望有能够在原地归并的方法，这样可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。

将原地归并抽象化，与之对应的方法签名 merge(a, lo, mid, hi)，它会将子数组 a\[lo..mid] 和 a\[mid+1..hi] 归并成一个有序的数组并将结果存放在 a\[lo..hi] 中。

利用辅助数组，将涉及的所有元素复制到一个辅助数组中，在把归并的结果放回到原数组中：
```java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
    // 将 a[lo..mid] 和 a[mid+1..hi] 归并
    int i = lo, j = mid + 1;
    // 将 a[lo..hi]复制到 aux[lo..hi]
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k];
    }
    // 归并回到 a[lo..hi]
    for (int k = lo; k <= hi; k++) {
        if (i > mid) { // 左半边用尽, 取右半边元素
            a[k] = aux[j++];
        } else if (j > hi) { // 右半边用尽, 取左半边元素
            a[k] = aux[i++];
        } else if (less(aux[j], aux[i])) { // 右半边小于左半边当前元素, 取右半边元素
            a[k] = aux[j++];
        } else { // 右半边大于等于左半边元素, 取左半边元素
            a[k] = aux[i++];
        }
    }
}
```

## 自顶向下的归并排序
分治思想。

基于原地归并的抽象实现了的递归归并，这段递归代码是归纳证明算法能够正确地将数组排序的基础：如果它能够将两个子数组排序，它就能够通过归并两个子数组来将整个数组排序。

*算法 2.4 自顶向下的归并排序*

通过树状图来表示时，每个结点都表示一个 sort() 方法通过 merge() 方法归并而成的子数组，这棵树正好有 n 层。对于 0 到 n-1 之间的任意 k，自顶向下的第 k 层有 2<sup>k</sup> 个子数组，每个数组的长度为 2<sup>n-k</sup>，归并最多需要 2<sup>n-k</sup> 次比较，因此每层的比较次数为 2<sup>k</sup> * 2<sup>n-k</sup> = 2<sup>n</sup>，n 层总共为 n*2<sup>n</sup> = NlgN。

对于长度为 N 的任意数组，自顶向下的归并排序需要 (1/2)NlgN 至 NlgN 次比较。

证明：令 C(N) 表示将一个长度为 N 的数组排序时所需要的比较次数，我们有 C(0)=C(1)=0。对于 N>0，通过递归的 sort() 方法可以由归纳关系得到比较次数的上限：

C(N) <= C(\[N/2]) + C(\[N/2]) + N

右边的第一项是将数组左半部分排序所用的比较次数，第二项是将数组的右半部分排序所用的比较次数，第三项是归并所用的比较次数。

因为归并所需的比较次数最少为 \[N/2]，比较次数的下限是：

C(N) >= C(\[N/2]) + C(\[N/2]) + \[N/2]

当 N 为 2 的幂(即 N=2<sup>n</sup>)且等号成立时我们能够得到一个解。

首先，因为 \[N/2] = 2<sup>n-1</sup>，可以得到：

C(2<sup>n</sup>) = 2C(2<sup>n-1</sup>) + 2<sup>n</sup>

将两边同时除以 2<sup>n</sup> 可得：

C(2<sup>n</sup>)/2<sup>n</sup>= C(2<sup>n-1</sup>)/2<sup>n-1</sup> + 1

将这个公式替换右边的第一项可得：

C(2<sup>n</sup>)/2<sup>n</sup>= C(2<sup>n-2</sup>)/2<sup>n-2</sup> + 1 + 1

将上一步重复 n-1 遍可得：

C(2<sup>n</sup>)/2<sup>n</sup>= C(2<sup>0</sup>)/2<sup>0</sup> + n

将两边同乘以 2<sup>n</sup> 就可以解得：

C(N) = C(2<sup>n</sup>) = n2<sup>n</sup> = NlgN


对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。

证明：每次归并最多需要访问数组 6N 次（2N 次用来复制，2N 次用来将排好序的元素移动回去，另外最多比较 2N 次）。


归并排序所需的时间和 NlgN 成正比，可以使用归并排序处理数百万甚至更大规模的数组。归并排序的主要缺点是辅助数组所使用的额外空间和 N 的大小成正比。

可以通过一些细致的思考来大幅度缩短归并排序的运行时间。

### 对小规模子数组使用插入排序
用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归回收小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。

使用插入排序处理小规模的子数组（比如长度小于 15）。

### 测试数组是否已经有序
添加一个判断条件，如果 a\[mid] 小于等于 a\[mid+1]，我们就认为数组已经是有序的并跳过 merge() 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性的了。

### 不将元素复制到辅助数组
我们可以节省将数组元素复制到用于归并的辅助数组所用的时间（但空间不行）。

要做到这一点我们要调用两种排序方法，一种是将数据从输入数组排序到辅助数组，一种是将数据从辅助数组排序到输入数组。我们要在递归调用的每个层次交换输入数组和辅助数组的角色。


## 自底向上的归并排序
实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并并得到子数组，如此这般，直到我们将整个数组归并在一起。

注意，在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小，如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。

自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 初始值为 1，每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数被时才会等于 sz，否则它会比 sz 小。

对于长度为 N 的任意数组，自底向上的归并排序需要 (1/2)NlgN 至 NlgN 次比较，最多访问数组 6NlgN 次。

自底向上的归并排序比较适合用链表组织的数据。这种方法只需要重新组织链表链接就能将链表原地排序，不需要创建任何新的链表结点。

用自顶向下或是自底向上的方式实现任何分治类的算法都很自然。归并排序告诉我们：当能够用其中一种方法解决一个问题时，你都应该试试另一种。

化整为零 <-> 循序渐进


## 排序算法的复杂度
研究复杂度的第一步是建立一个计算模型。一般来说，研究者会尽量寻找一个和问题相关的最简单的模型。对排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方式是由主键的比较决定的。一个基于比较的算法在两次比较之间可能会进行任意规模的计算，但它只能通过主键之间的比较得到关于某个主键的信息。

没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN 次比较将长度为 N 的数组排序。

首先，假设没有重复的主键，因为任何排序算法都必须能够处理这种情况。

使用二叉树来表示所有的比较，树中的结点要么是一片叶子 i<sub>0</sub> i<sub>1</sub> ... i<sub>N-1</sub>，表示排序完成且原输入的排列顺序是 a\[i<sub>0</sub>], a\[i<sub>1</sub>],...a\[i<sub>N-1</sub>]，要么是一个内部结点 i:j，表示 a\[i] 和 a\[j] 之间进行的一次比较操作，它的左子树表示 a\[i] 小于 a\[j] 时进行的其他比较，右子树表示 a\[i] 和大于 a\[j]  进行的其他比较。从根节点到叶子结点每一条路径都对应着算法在建立叶子结点所示的顺序时进行的所有比较。

从比较树观察得到第一个重要结论是：这棵树应该至少有 N! 个叶子结点，因为 N 个不同的主键会有 N! 种不同的排列。

从根节点到叶子结点的一条路径上的内部结点的数量即是某种输入下算法进行比较的次数，我们关注的是这种路径能有多长(也就是树的高度)，因为这也是算法比较次数的最坏情况。二叉树的一个基本的组合学性质就是高度为 h 的树最多只可能有 2<sup>k</sup> 个叶子结点，拥有 2<sup>k</sup> 个结点的树是完美平衡的，或称为完全树。

任意基于比较的排序算法都对应着一棵高 h 的比较树，其中 

N! <= 叶子结点的数量 <= 2<sup>h</sup>

h 的值就是最坏情况下的比较次数，因此对不等式两边取对数即可得到任意算法的比较次数至少是 lgN!。

斯特林公式(Stirling)取 N 阶乘近似值，ln(n!) = ln1 + ln2 + ... + lnn。

根据斯特林公式对阶乘函数对近似可得 lg(N!) ~ NlgN。

这个结论告诉我们在设计排序算法的时候能够达到的最佳效果。

归并排序是一种渐进最优的基于比较排序的算法。更准确地说，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~NlgN。

计算复杂度的概念可能会很抽象，但解决可计算问题内在困难的基础性研究则不管怎么说都是非常必要的。而且，在适当的情况下，关键在于计算复杂度会影响软件的开发：
- 首先，准确的上界为保证性能提供了空间；
- 其次，准确的下界为我们节省了时间，避免因不可能的性能改进而投入资源。


但归并排序的最优性并不是结束。例如：
- 归并排序的空间复杂度不是最优的；
- 在实践中不一定会遇到最坏情况；
- 除了比较，算法的其他操作(例如访问数组)也可能比较重要；
- 不进行比较也能将某些数据排序。


## 参考
[1] 算法(第4版).Sedgwick,Wayne.人民邮电出版社,2012.10