---
title: 动态规划
date: 2022-08-08 21:26:00
tags:
categories:
- 算法
---

## “一个模型三个特征”理论
动态规划适合解决的问题模型：多阶段决策最优模型。

我们一般是用动态规划来解决最优问题，而解决问题的过程，需要经历多个决策阶段，每个决策阶段都对应着一组状态，然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

特征一：最优子结构。最优子结构指的是，问题的最优解包含子问题的最优解。也就是说，我们可以通过子问题的最优解，推导出问题的最优解。也就是说，后面阶段的状态可以通过前面阶段的状态推导出来。

特征二：无后效性。第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。

特征三：重复子问题。不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

## “一个模型三个特征”实例
假设我们有一个 n 乘以 n 的矩阵 `w[n][n]`。矩阵存储的都是正整数。棋子开始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那么从左上角到右下角的最短路径长度是多少呢？

从(0,0)走到(n-1,n-1)，总共要走2*(n-1)步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右或者向下走两种决策，并且每个阶段都会对应一个状态集合。

我们把状态定义为 min_dist(i,j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0,0) 到达 (i,j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解的问题，符合动态规划的模型。

## 两种动态规划解题思路
### 状态转移表法
一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，去发现是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能动态规划解决。

找到重复子问题之后，我们有两种处理思路，第一种是直接用回溯加备忘录的方法，来避免重复子问题。第二种是使用动态规划的解决办法，状态转移表法。

我们先画出一个状态表。状态表一般都是二维的，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。

```javascript
function minDistDP(matrix) {
    var n = matrix.length
    var states = Array(n).fill().map(() => Array(n).fill(0))
    var sum = 0
    // 初始化 states 第一行数据
    for (var i = 0; i < n; i++) {
        sum += matrix[0][i]
        states[0][i] = sum
    }
    sum = 0
    // 初始化 states 第一列数据
    for (var i = 0; i < n; i++) {
        sum += matrix[i][0]
        states[i][0] = sum
    }
    for (var i = 1; i < n; i++) {
        for (var j = 1; j < n; j++) {
            var minState = states[i][j-1]
            if (minState > states[i-1][j]) {
                minState = states[i-1][j]
            }
            states[i][j] = matrix[i][j] + minState
        }
    }
    return states[n-1][n-1]
}

var matrix = [
    [1, 3, 5, 9],
    [2, 1, 3, 4],
    [5, 2, 6, 7],
    [6, 8, 4, 3]
]
console.log(minDistDP(matrix))
```

### 状态转移方程
状态转移方程法有点类似递归的解题思路，我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出状态转移方程。

```
min_dist(i,j) = w[i][j] + min(min_dist(i,j-1), min_dist(i-1,j))
```

状态转移方程是解决动态规划问题的关键。

## 四种算法思想比较
贪心、回溯、动态规划，分治


## 参考
[1] https://time.geekbang.org/column/intro/100017301?tab=catalog

[2] https://github.com/wangzheng0822/algo