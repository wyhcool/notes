---
title: 排序-冒泡插入选择
date: 2022-07-24 09:39:00
tags:
categories:
- 算法
---

排序算法的执行效率分析：
- 最好情况、最快情况、平均情况时间复杂度。
- 时间复杂度的系数、常数、低阶
- 比较次数和交换(移动)次数

排序算法的内存消耗：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

排序算法的稳定性：稳定性指的是，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。


## 冒泡排序 Buble Sort
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换，一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排列工作。
```javascript
function bubbleSort(array) {
    if (array.length <= 1) {
        return
    }

    for (var i = 0; i < array.length; i++) {
        // 提前退出冒泡循环的标识位
        var flag = false
        for (var j = 0; j < array.length - i - 1; j++) {
            if (array[j] > array[j+1]) {
                // 交换
                var tmp = array[j]
                array[j] = array[j+1]
                array[j+1] = tmp
                // 表示有数据交换
                flag = true
            }
        }
        // 无数据交换时，提前退出
        if (!flag) break;
    }
}
```

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度是 O(1)，是一个原地排序算法。

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

冒泡排序的时间复杂度：最好情况下，要排序的数据已经是有序了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)；而最坏情况是，要排序的数据刚好是倒序排列，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度是 O(n^2)。

有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示为：
```
有序元素对：a[i] <= a[j], 如果 i < j
```

对于一个倒序排列的数组，有序度是 0；对于一个完全有序的数组，有序度是 n*(n-1)/2。完全有序的数组的有序度称为满有序度。

逆序度是数组中具有逆序关系的元素对的个数。逆序元素对用数学表达式表示为：
```
逆序元素对：a[i] > a[j], 如果 i < j
```

逆序度 = 满有序度 - 有序度

我们排序的过程就是一种增加有序度，减少逆序度度过程，最终达到满有序度，就说明排序完成了。

冒泡排序包含两个操作原子：比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的。

对于包含 n 个数据的数组进行冒泡排序，最坏情况下，初始有序度是 0，所以要进行 n*(n-1)/2 次交换；最好情况下的有序度是 n*(n-1)/2，就不需要进行交换；因此我们可以取中间值，有序度 n*(n-1)/4 来表示平均情况，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度是 O(n^2)。


## 插入排序 Insertion Sort
首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序包含两个操作：比较和移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。
```javascript
function insertionSort(array) {
    if (array.length <= 1) {
        return
    }

    for (var i = 1; i < array.length; i++) {
        var value = a[i]
        var j = i - 1
        // 查找插入位置
        for (; j >= 0; j--) {
            if (array[j] > value) {
               array[j+1] = array[j]
            } else {
                break
            }
        }
        array[j+1] = value
    }
}
```

插入排序不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。

在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数组里面查找插入位置，每次只需比较一个数据就能确定插入的位置，这种情况下，最好的时间复杂度是 O(n)。

如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，最坏的时间复杂度是 O(n^2)。

在数组中插入一个数据的平均时间复杂度是 O(n)，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度是 O(n^2)。


## 选择排序 Selection Sort
选择排序也分已排序区间和未排序区间，每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
```javascript
function selectionSort(array) {
    if (array.length <= 1) {
        return
    }

    // 需要注意这里的边界, 因为需要在内层进行 i+1后的循环，所以外层需要 数组长度-1
    for (var i = 0; i < array.length - 1; i++) {
        var min = i
        for (var j = i + 1; j < array.length; j++) {
            if (array[j] < array[min]) {
                // 找到整个数组的最小 index
                min = j
            }
        }
        var tmp = array[i]
        array[i] = array[min]
        array[min] = tmp
    }
}
```

选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好、最坏、和平均情况时间复杂度都为 O(n^2)。

选择排序是一种不稳定的排序算法，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。


## 参考
[1] https://time.geekbang.org/column/intro/100017301?tab=catalog

[2] https://github.com/wangzheng0822/algo

