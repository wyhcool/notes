---
title: 字符串匹配
date: 2022-08-06 13:31:00
tags:
categories:
- 算法
---

## KMP 算法 Knuth-Morris-Pratt
KMP 算法的核心思想是，假设主串是 a，模式串是 b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。

在模式串和主串的匹配过程中，把不能匹配的字符叫做坏字符，把已经匹配的字符串叫做好前缀。

当遇到坏字符的时候，我们就要模式串往后滑动，在滑动的过程，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。

KMP 算法就是在寻找一种规律，在模式串与主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能够找到一种规律，将模式串一次性滑动很多位。

我们只会需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是 `{v}`，长度是 k。我们把模式串一次性往后滑动 `j-k` 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k， i 不变，然后再继续比较。

把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。

提前构建一个数组，用来存储模式串中每个后缀的最长可匹配前缀子串的结尾字符下标，这个数组定义为 next 数组（也叫失效函数 failure function)。

数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。

实现，放弃😢

## 参考
[1] https://time.geekbang.org/column/intro/100017301?tab=catalog

[2] https://github.com/wangzheng0822/algo