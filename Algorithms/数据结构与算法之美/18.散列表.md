---
title: 散列表
date: 2022-07-28 23:10:00
tags:
categories:
- 算法
---

## 散列思想
散列表(Hash Table)用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

原始值称为键(key)或者关键字，将原始值转化为数组下标的映射方法就叫做散列函数(哈希函数)，而散列函数计算得到的值就叫作散列值(哈希值)。

散列表用的就是数组支持下标随机访问，时间复杂度是 O(1) 的特性，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。

## 散列函数
散列函数设计的三点基本要求：
- 散列函数计算得到的散列值是一个非负整数；
- 如果 key1==key2，那 hash(key1)==hash(key2)；
- 如果 key1!=key2，那 hash(key1)!=hash(key2)。

## 散列冲突
再好的散列函数也无法避免散列冲突。我们常用的散列冲突解决方法有两类，开放寻址法(open addressing)和链表法(chaining)。

### 开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

线性探测(Linear probing)：当我们往散列表插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

probing \[ˈproʊbɪŋ] adj.探查性的; 追根究底的; 逼视的; 仔细观察的;v.盘问; 追问; 探究; (用细长工具)探查，查看;

在散列表中查找元素的过程与插入过程类似。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要查找的元素；否则就顺序王后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。

我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。

线性探测法存在的问题是：当散列表中插入的数据越来越多时，散列冲突发生的可能性就越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。

为了尽可能保证散列表的操作效率，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子(load factor)来表示空位的多少。

散列表的装载因子 = 填入表中的元素个数 / 散列表的长度

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 链表法
在散列表中，每个桶(bucket)或者槽(slot)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后通过遍历链表查找或者删除。对于散列比较均匀的散列函数来说，理论上，链表的长度 k = n/m，其中 n 表示散列表中数据的个数，m 表示散列表中槽的个数，操作的时间复杂度是 O(k)。

散列表来源于数组，它借助散列函数对数组进行扩展， 利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也决定了散列表的性能。

## 参考
[1] https://time.geekbang.org/column/intro/100017301?tab=catalog

[2] https://github.com/wangzheng0822/algo
