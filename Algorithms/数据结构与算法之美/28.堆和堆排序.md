---
title: 堆和堆排序
date: 2022-07-31 19:10:00
tags:
categories:
- 算法
---

## 理解堆
堆(Heap)是一种特殊的树，只要满足以下两点的树才是堆：
- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。

第一点，堆必须是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。

第二点，堆中的每个节点的值都必须大于等于(或者小于等于)其子树每个节点的值。换言之，堆中每个节点的值都大于等于(或小于等于)其左右子节点的值。

大顶堆：每个节点的值都大于或者等于它的左右子节点的值。

小顶堆：每个节点的值都小于或者等于它的左右子节点的值。

## 实现堆
完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的，因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

从 0 开始索引，

对于大顶堆：`arr[i]>=arr[2*i+1] && arr[i]>=arr[2*i+2]`。

对于小顶堆：`arr[i]<=arr[2*i+1] && arr[i]<=arr[2*i+2]`。

### 往堆中插入一个元素
往堆中插入一个元素后，我们需要继续满足堆的两个特性。这个调整的过程叫做堆化(heapify)。

堆化实际上有两种，从下往上和从上往下。堆化就是顺着节点所在的路径，向上或者向下，对比，然后交换。

我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足大小关系。

### 删除堆顶元素
从堆的定义的第二条中，任何节点的值都大于等于(或小于等于)子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。

假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。但是这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。

换一种思路，我们可以把最后一个元素放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系位置，这就是从上往下的堆化方法。

因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的空洞，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。

一个包含 n 个节点的完全二叉树，树的高度不会超过 log2(n)。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

## 基于堆实现排序
借助堆这种数据结构实现的排序算法，就叫做堆排序。这种排序方法的时间复杂度非常稳定，适合 O(nlogn)，并且它还是原地排序算法。

推排序的过程大致分解为两个大的步骤：建堆和排序。

堆排序的基本思想是：
- 1、将待排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；
- 2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；
- 3、重复步骤2；

如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。

### 建堆
首先将数组原地建成一个堆。所谓原地，就是不借助另一个数组，就在原数组上操作。

建堆的过程，有两种思路：
- 第一种就是借助在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个元素，就是下标为 1 的数据。然后调用插入操作，将下标从 2 到 n 的苏剧依次插入到堆中，这样我们就将包含 n 个数据的数组，组织成了堆。
- 第二种思路，跟第一种截然相反。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。

根据大顶堆的性质，每个节点的值都大于或者等于它的左右子节点的值。所以我们需要找到所有包含子节点的节点，也就是非叶子节点，然后调整他们的父子关系，非叶子节点遍历的顺序应该是从下往上，这比从上往下的顺序遍历次数少很多，因为，大顶堆的性质要求父节点的值要大于或者等于子节点的值，如果从上往下遍历，当某个节点即是父节点又是子节点并且它的子节点仍然有子节点的时候，因为子节点还没有遍历到，所以子节点不符合大顶堆性质，当子节点调整后，必然会影响其父节点需要二次调整。

从下往上的方式不需要考虑父节点，因为当前节点调整完之后，当前节点必然比它的所有子节点都大，所以，只会影响到子节点二次调整。相比之下，从下往上的遍历方式比从上往下的方式少了父节点的二次调整。

那么，该如何知道最后一个非叶子节点的位置，也就是索引值？

对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量一定是之前所有层节点总数+1，所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是 `(arr.length/2)-1`。

### 排序
建堆结束之后，数组中的数据已经是按照大顶堆的特性组织起来的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。

这个过程类似于删除堆顶元素的操作，当堆顶元素删除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n-1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n-1 的位置，一直重复这个过程，直到最后堆中只剩下下标为 1 的一个元素，排序工作就完成了。

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序的增提时间复杂度是 O(nlogn)。

堆排序不是稳定的排序算法，因为在排序过程中，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

如果从 0 开始存储，如果节点的下标是 i，那左子节点的下标就是 `2*i+1`，右子节点的下标就是 `2*i+2`，父节点的下标就是 `(i-1)/2`。

## 堆排序 vs. 快速排序
在实际开发中，为什么快速排序要比堆排序性能好？
- 第一点，堆排序数据访问的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的；而对于堆排序来说，数据是跳着访问的，这样对 CPU 缓存是不友好的。
- 第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换。快速排序数据交换的次数不会比逆序度高。

但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

堆排序代码实现：
```javascript
var swapCount = 0
function swap(array, i, j) {
  swapCount++
  var tmp = array[i]
  array[i] = array[j]
  array[j] = tmp
}

// 堆排序
// 堆元素是从数组下标 0 开始
function HeapSort() {}

// 排序
HeapSort.prototype.sort = function (array) {
  if (array.length <= 1) {
    return
  }

  swapCount = 0

  // 构建大顶推
  this.buildMaxHeap(array)

  // 排序
  var k = array.length - 1
  while (k > 0) {
    // 将堆顶元素(最大)与最后一个元素交换位置
    swap(array, 0, k)
    --k
    this.heapify(array, k, 0)
  }
}

// 建堆
HeapSort.prototype.buildMaxHeap = function (array) {
  // (array.length-1)/2 为最后一个叶子结点的父节点
  // 从最后一个非叶子节点开始向前遍历，调整节点性质，使其成为大顶堆
  for (var i = ((array.length - 1) / 2) | 0; i >= 0; i--) {
    this.heapify(array, array.length - 1, i)
  }
}

/**
 * 堆化
 * @param {*} array 要堆化的数组
 * @param {*} n 最后堆元素下标
 * @param {*} i 要堆化的元素下标
 */
HeapSort.prototype.heapify = function (array, n, i) {
  while (true) {
    // 先根据堆性质，找出它的左右子节点的索引
    var left = 2 * i + 1
    var right = 2 * i + 2
    // 默认当前节点(父节点)是最大值
    var maxPos = i
    if (left <= n && array[maxPos] < array[left]) {
      // 如果有左节点，并且左节点的值更大，更新最大值的索引
      maxPos = left
    }
    if (right <= n && array[maxPos] < array[right]) {
      // 如果有右节点，并且右节点的值更大，更新最大值的索引
      maxPos = right
    }
    // 最大值是当前位置结束循环
    if (maxPos === i) {
      break
    }
    // 如果最大值不是当前节点，那就把当前节点和最大值的子节点交换值
    swap(array, i, maxPos)
    // 互换之后，子节点的值改变，如果该子节点也有自己的子节点，仍需要再次调整
    i = maxPos
  }
}

var array = [1, 3, 2, 5, 6, 4, 8, 5, 61, 3]
var heapSort = new HeapSort()
heapSort.sort(array)
console.log(array)
console.log(swapCount)
```

## 参考
[1] https://time.geekbang.org/column/intro/100017301?tab=catalog

[2] https://github.com/wangzheng0822/algo

[3] https://blog.csdn.net/qq_28063811/article/details/93034625/
