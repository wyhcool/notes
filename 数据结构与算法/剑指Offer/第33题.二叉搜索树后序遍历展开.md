---
title: 二叉搜索树的后序遍历序列
date: 2019-02-01 00:17:00
tags:
categories:
- 算法与数据结构
---

## 题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
[nowcoder](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


## JavaScript解法

由二叉搜索树的后序遍历可知，后序序列最后一个值为root；二叉搜索树左子树值都比root小，右子树值都比root大。

以根结点划分左右两个子树的结点，比根大的且连续的结点为右子树，比根小且连续的结点为左子树。递归处理子树情况。

为了验证连续性，直接存储索引，等遍历完成后进行连续性判断，让代码分离清晰。

```javascript
function VerifySquenceOfBST(sequence)
{
    // write code here
    var length = sequence.length,
        root = sequence[length-1],
        leftSequence = [],
        rightSequence = [],
        value;
    
    if (length === 0) {
        return false;
    }
    
    for (i = 0; i < length-1; i++) {
        value = sequence[i];
        if (value < root) {
            leftSequence.push(i);
        } else {
            rightSequence.push(i);
        }
    }
    
    for (i = 0; i < leftSequence.length; i++) {
        if (typeof leftSequence[i+1] !== "undefined") {
            if (leftSequence[i] + 1 === leftSequence[i+1]) {
                leftSequence[i] = sequence[leftSequence[i]];
            } else {
                return false;
            }
        } else {
            leftSequence[i] = sequence[leftSequence[i]];
        }
    }
    
    for (i = 0; i < rightSequence.length; i++) {
        if (typeof rightSequence[i+1] !== "undefined") {
            if (rightSequence[i] + 1 === rightSequence[i+1]) {
                rightSequence[i] = sequence[rightSequence[i]];
            } else {
                return false;
            }
        } else {
            rightSequence[i] = rightSequence[leftSequence[i]];
        }
    }
    
    if (leftSequence.length !== 0) {
        if (!VerifySquenceOfBST(leftSequence)) {
            return false;
        }
    }
    
    if (rightSequence.length !== 0) {
        if (!VerifySquenceOfBST(rightSequence)) {
            return false
        }
    }
    
    return true;
}
```
