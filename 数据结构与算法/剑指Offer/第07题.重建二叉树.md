---
title: 重建二叉树
date: 2019-01-28 21:12:00
tags:
categories:
- 算法与数据结构
---

## 题目描述
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
[nowcoder](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


## JavaScript解法

### 利用前序遍历和中序遍历的规律

利用递归（或循环）处理子树。

```javascript
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function reConstructBinaryTree(pre, vin)
{
    var parse = function(pre, vin) {
        var node = null,
            pos,
            leftPre, leftVin,
            rightPre, rightVin;
        
        if (pre.length !== 0) {
            node = {};
            node.val = pre[0];
            
            pos = vin.indexOf(node.val);
            leftPre = pre.slice(1, pos+1);
            leftVin = vin.slice(0, pos);
            node.left = parse(leftPre, leftVin);
            rightPre = pre.slice(pos+1);
            rightVin = vin.slice(pos+1);
            node.right = parse(rightPre, rightVin);
        }
        return node;
    };
    
    return parse(pre, vin);
}
```

涉及：

Array.prototype.slice()

slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end，<font color="red">左闭右开</font>）决定的原数组的浅拷贝。原始数组不会被改变。