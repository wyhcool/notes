---
title: 包含min函数的栈
date: 2019-01-30 23:33:00
tags:
categories:
- 算法与数据结构
---

## 题目描述
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
[nowcoder](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


## JavaScript解法

看网上的题目描述，完全被蒙掉了。以为每次压栈时用一个有序链表来存储节点状态就好了，结果各种问题随之而来。看了书中完整表述：

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用 min、push、pop 的时间复杂度都是 O(1)。

### 压栈时，与最小元素比较，较小时入栈，否则将最小元素入栈

```javascript
var data_stack = [];
var min_stack = [];

function push(node)
{
    // write code here
    data_stack.push(node);
    if (min_stack.length === 0) {
        min_stack.push(node);
    } else {
        var min = min_stack[min_stack.length-1];
        if (node < min) {
            min_stack.push(node);
        } else {
            min_stack.push(min);
        }
    }
    
}
function pop()
{
    // write code here
    min_stack.pop();
    return data_stack.pop();
}
function top()
{
    // write code here
}
function min()
{
    return min_stack[min_stack.length-1];
}
```

### 压栈时，与最小元素比较，较小时入栈，出栈需要判断是否为当前元素

```javascript
var data_stack = [];
var min_stack = [];

function push(node)
{
    // write code here
    data_stack.push(node);
    if (min_stack.length === 0) {
        min_stack.push(node);
    } else {
        var min = min_stack[min_stack.length-1];
        //NOTICE: 小于等于
        if (node <= min) {
            min_stack.push(node);
        }
    }
    
}
function pop()
{
    // write code here
    var val = data_stack.pop();
    if (val === min_stack[min_stack.length-1]) {
        min_stack.pop();
    }
    return val;
}
function top()
{
    // write code here
}
function min()
{
    return min_stack[min_stack.length-1];
}
```