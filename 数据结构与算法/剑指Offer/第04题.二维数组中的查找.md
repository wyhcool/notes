---
title: 二维数组中的查找
date: 2019-01-26 23:54:00
tags:
categories:
- 算法与数据结构
---

## 题目描述
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[nowcoder](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)


## JavaScript解法

### 左下角（右上角）开始

利用矩阵是有序的规律，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时。右移；要查找数字比左下角数字小时，上移。

```javascript
function Find(target, array)
{
    var width,
        height,
        x,
        y;

    width = array.length;
    //二维数组第一维为空时
    if (width === 0) {
        return false;
    }
    height = array[0].length;
    //二维数组第二维为空时
    if (height === 0) {
        return false;
    }
    //从(0, y-1)开始
    x = 0;
    y = height - 1;
    while (x < width && y > -1) {
        if (array[x][y] === target) {
            return true;
        } else if (array[x][y] < target) {
            x++;
        } else {
            y--;
        }
    }
    return false;
}
```

### 左上角(右下角)开始

从右上角开始查找时，对于向右和向下会产生一个岔路，利用深度优先搜索（回溯法）来实现查找。

```javascript
function Find(target, array)
{
    var width,
        height,
        x,
        y,
        map;

    width = array.length;
    //二维数组第一维为空时
    if (width === 0) {
        return false;
    }
    height = array[0].length;
    //二维数组第二维为空时
    if (height === 0) {
        return false;
    }

    //构造地图
    //路0，墙1
    map = [];
    array.forEach(function(col, index) {
        map[index] = [];
        col.forEach(function(row){
            map[index].push(0);
        })
    });

    //从(0,0)位置开始走
    var track = function(x, y) {
        //设置该点为已走
        map[x][y] = 1;

        //如果该点是目标
        if (array[x][y] === target) {
            return true;
        } else if (array[x][y] > target) {
            //该位置比目标大，则判断上左是否可走
            if ((y-1) > 0 && map[x][y-1] === 0) { //上存在且可走
                if (track(x, y-1)) { 
                    return true;
                }
            }
            if ((x-1) > 0 && map[x-1][y] === 0) { //左存在且可走
                if (track(x-1, y)) {
                    return true;
                }
            }
        } else {
            //该位置比目标小，则判断下右是否可走
            if ((y+1) < height && map[x][y+1] === 0) { //下存在且可走
                if (track(x, y+1)) {
                    return true;
                }
            }
            if ((x+1) < width && map[x+1][y] === 0) { //右存在且可走
                if (track(x+1, y)) {
                    return true;
                }
            }
        }
        return false;
    };

    return track(0, 0);

};
```
搜索就是用问题的所有可能去试探，按照一定的顺序、规则，不断去试探，直到找到问题的解，试完了也没有找到解，那就是无解，试探时一定要试探完所有的情况（实际上就是穷举）。

深度优先搜索用一个数组存放产生的所有状态：
- 把初始状态放入数组中，设为当前状态；
- 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；
- 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；
- 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。
- 如果数组为空，说明无解。

<em>备注：这个方法真的是麻烦，但我在看到题的那一霎那，就一头钻进这个思路里了，可能是贪吃蛇玩多了，在迷宫里走散了的人吧。😂</em>


### 类型转换
利用 Array.prototype.toString() 方法。

```javascript
function Find(target, array)
{
    return array.toString().split(",").indexOf(""+target) !== -1;
}
```

Array对象覆盖了Object的 toString 方法。对于数组对象，toString 方法连接数组并返回一个字符串，其中包含用逗号分隔的每个数组元素。

当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。







