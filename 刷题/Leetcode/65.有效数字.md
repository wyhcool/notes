---
title: 有效数字
date: 2022-10-02 20:13:00
tags:
categories:
- 刷题
---

## 两层判断：
- s 中没e|E, 则直接判断 s 是否是整数或小数 
- s 有e|E,则 s = s1 + e|E + s2，判断 s1 是否是小数或者整数，再判断 s2 是否是整数即可
```javascript
/**
 * @param {number[][]} isConnected
 * @return {number}
 */
var findCircleNum = function(isConnected) {
    var n = isConnected.length
    var ans = 0
    var visited = new Array(n).fill(false)

    var dfs = function(i) {
        for (var j = 0; j < n; j++) {
            if (isConnected[i][j] === 1 && visited[j] === false) {
                visited[j] = true
                dfs(j)
            }
        }
    }

    for (var i = 0; i < n; i++) {
        if (visited[i] === false) {
            ans++
            visited[i] = true
            dfs(i)
        }
    }
    
    return ans
};
```

## 确定有限状态自动机 Deterministic Finite Automata (DFA)
对于给定的输入符号，机器将移动到可以确定下一个状态的位置，因此将其称为确定性自动机。状态的数量是有限的，因此称为有限自动机。 将这两个特征结合起来称为确定性有限自动机。

确定有限状态自动机是一类计算模型。它包含一系列状态，这些状态中：
- 有一个特殊的状态，被称作「初始状态」。
- 还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
- 起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

### 问题描述：
描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：
- 符号位，即 +、- 两种符号
- 整数部分，即由若干字符 0-9 组成的字符串
- 小数点
- 小数部分，其构成与整数部分相同
- 指数部分，其中包含开头的字符 e（大写小写均可）、可选的符号位，和整数部分

在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：
- 如果符号位存在，其后面必须跟着数字或小数点。
- 小数点的前后两侧，至少有一侧是数字。

### 思路与算法
根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：
- 0 初始状态
- 1 符号位
- 2 整数部分
- 3 左侧有整数的小数点
- 4 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
- 5 小数部分
- 6 字符 e
- 7 指数部分的符号位
- 8 指数部分的整数部分

下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 0，而「接受状态」的集合则为状态 2、状态 3、状态 5 以及状态 8。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。

最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程表示出来。

在实际代码中，我们需要处理转移失败的情况。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。

对于每一个状态接收的下一个字符，DFA 能确定唯一一条转换路径，所以使用简单的表驱动的一些方法就可以实现。

这里面多了一个状态 9，是用于处理串后面的若干个多余空格的。所以，所有的终止态都要跟上一个状态 9。其中，有一些状态标识为-1，是表示遇到了一些意外的字符，可以直接停止后续的计算。状态跳转表如下：

| state | blank |  +/-  |  0-9  |   .   |   e   | other |
|  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |  :-:  |
|   0   |   0   |   1   |   2   |   4   |   -1  |   -1  |
|   1   |  -1   |  -1   |   2   |   4   |   -1  |   -1  |
|   2   |   9   |  -1   |   2   |   3   |   6   |   -1  |
|   3   |   9   |  -1   |   5   |   -1  |   6   |   -1  |
|   4   |  -1   |  -1   |   5   |   -1  |   -1  |   -1  |
|   5   |   9   |  -1   |   5   |   -1  |   6   |   -1  |
|   6   |  -1   |   7   |   8   |   -1  |   -1  |   -1  |
|   7   |  -1   |  -1   |   8   |   -1  |   -1  |   -1  |
|   8   |   9   |  -1   |   8   |   -1  |   -1  |   -1  |
|   9   |   9   |  -1   |  -1   |   -1  |   -1  |   -1  |

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    var finals = [0, 0, 1, 1, 0, 1, 0, 0, 1, 1]
    var transfer = [
        [0, 1, 2, 4, -1, -1],
        [-1, -1, 2, 4, -1, -1],
        [9, -1, 2, 3, 6, -1],
        [9, -1, 5, -1, 6, -1],
        [-1, -1, 5, -1, -1, -1],
        [9, -1, 5, -1, 6, -1],
        [-1, 7, 8, -1, -1, -1],
        [-1, -1, 8, -1,-1,-1],
        [9,-1,8,-1,-1,-1],
        [9,-1,-1,-1,-1,-1]
    ]
    var make = function(char) {
        switch(char) {
            case ' ': return 0;
            case '+':
            case '-': return 1;
            case '.': return 3;
            case 'e':
            case 'E': return 4;
            default:
                var code = char.charCodeAt(0)
                if (code >= 47 && code <= 57) {
                    return 2
                }
                return 5
        }
    }
    var state = 0
    for (var i = 0; i < s.length; i++) {
        state = transfer[state][make(s[i])]
        // console.log(s[i], state)
        if (state < 0) {
            return false
        }
    }
    return finals[state]
};
```
## 参考
[1] https://leetcode.cn/problems/valid-number/

[2] https://leetcode.cn/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/