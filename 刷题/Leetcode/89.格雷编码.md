---
title: 格雷编码
date: 2022-10-05 15:26:00
tags:
categories:
- 刷题
---

## 格雷编码
格雷码是一个二进制数系，其中两个相邻数的二进制位只有一位不同. 3 位二进制数的格雷码序列为 000,001,011,010,110,111,101,100，（可以看成一个环，第一个格雷码 000 与最后一个格雷码 001 也只有一位不同）.

## 构造格雷码
通过观察找规律，可以得到以下两种手动构造格雷码的方法.

### 交替构造
从全 0 格雷码开始构造 k 位格雷码：
- 翻转最低位得到下一个格雷码，如 000 变成 001
- 把最右边的 1 左边的位翻转得到下一个格雷码，如 001 变成 011.
交替按照上述步骤进行 2^{k-1} 次，即可得到所有的 k 位格雷码.

### 镜像构造
k 位格雷码可以根据 k-1 位格雷码以上下镜射后加上新位的方式快速的得到：
- 首先，一个位的编码就是自然的格雷码。0-0,1-1。
- 假设我们已经生成了 k 位的格雷码，那么生成 k+1 位的格雷码可以采用如下方式：
  - 前半部分就采用 k 位的格雷码，这显然是满足相邻两个数字只相差一个位的条件的。
  - 后半部分采用 k 位的格雷码的倒序，并且将每个码的最高位置为1。显然，后半部分也是满足格雷码的条件的。

那么前半部分的最后一个数字，和后半部分的第一个数字，由于是同一个码变过来的，差距只有后半部分的是最高位置为1了，那么也只要一个位的差距。同理，后半部分的最有一个格雷码和前本部分的第一个格雷码，也是只有一个位的差距（也就是最高位）。

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    var ans = [0, 1]
    var len = 2
    var bit = 1
    for (var i = 1; i < n; i++) {
        var nextLen = len * 2
        var nextAns = new Array(nextLen)
        bit *= 2
        for (var i = 0; i < len; i++) {
            nextAns[i] = ans[i]
            nextAns[nextLen-i-1] = ans[i] + bit
        }
        ans = nextAns
        len = nextLen
    }

    return ans
};
```

## 参考
[1] https://leetcode.cn/problems/gray-code/