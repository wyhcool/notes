---
title: Pow(x, n)
date: 2022-08-31 23:44:00
tags:
categories:
- 刷题
---

原始解法：
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    var memset = {
        0: 1,
        1: x,
    }

    // n >= 0
    var helper = function(x, n) {
        var ldivide = n >> 1
        var rdivide = n - ldivide
        if (memset[ldivide] && memset[rdivide]) {
            memset[n] = memset[ldivide] * memset[rdivide]
            return memset[n]
        }
        return helper(x, ldivide) * helper(x, rdivide)
    }

    if (x === 0) {
        if (n === 0) {
            return 1
        }
        return 0
    }
    if (n === 0) {
        return 1
    } else if (n < 0) {
        // 如果是16位的int，表示数的范围是-32768~+32767。
        // 如果是32位的int，表示数的范围是-2147483648~+2147483647。
        return 1 / helper(x, -(n+1)) * 1/x
    } else {
        return helper(x, n)
    }
};
```

分治思想：当 n 是偶数的时候，对 n 进行分治，拆解为 x*x 的 n/2 的次方，当 n 为奇数的时候拆分成 x * myPow(x,n-1)，注意当 n 是负数或者是 0 的特殊情况。

复杂度分析：时间复杂度：O(logn)， n是进行二进制拆分的时间复杂度。空间复杂度：O(logn), n为递归深度
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if (n === 0 || x === 1) {
        return 1
    }
    if (x === 0) {
        return 0
    }
    if (n < 0) {
        // 拆分一个出来，这样做是为了防止 n 为 -int 最小值时的溢出
        return (1/x) * (1 / myPow(x, -(n+1)))
    } else {
        var a = n >> 1
        var b = n & 1
        if (b === 1) {
            //偶次幂
            //return myPow(x,a) * myPow(x,a); 这种写法会把 myPow(x,a) 计算两次
            return myPow(x*x,a);//优化
        } else {
            //奇次幂
            //return x*myPow(x,a)*myPow(x,a);
            return x * myPow(x*x, a);//优化
        }
    }
};
```


## 参考
[1] https://leetcode.cn/problems/powx-n/