---
title: 继承
date: 2020-01-03 22:44:00
update:
tags:
categories:
- Java
---

利用继承(inheritance)，可以基于已存在的类构造一个新类，继承已存在的类就是复用这些类的方法和域，在此基础上，还可以添加一些新的方法和域，以满足新的需求。

## 类、超类和子类
`is-a` 关系是继承的一个明显特征。

### 定义子类
关键字 extends 表示继承，代替了 C++中的冒号(:)，在 Java 中，所有的继承都是公有继承，而没有 C++ 中的私有继承和保护继承。

关键字 extends 表明正在构造的新类派生于一个已存在的类。已存在的类称为超类(superclass)、基类(base class)或父类(parent class)；新类称为子类(subclass)、派生类(derived class)或孩子类(child class)。

子类比超类拥有的功能更加丰富，在通过扩展超类定义子类时，仅需要指出子类与超类的不同之处，因此，在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

### 覆盖方法
超类中的有些方法对子类不一定适用，子类需要提供一个新的方法来覆盖(override)超类中的方法。

调用超类中的被覆盖方法时，可以使用特定的关键字 `super`。

注意：super 与 this 引用截然不同，super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。

在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。

在 C++ 中采用超类名加 :: 操作符的形式调用超类的方法。

### 子类构造器
在子类的构造器中使用 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。

如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报错。

🌿对比：关键字 this 有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器时，调用构造器的语句只能作为另一个构造器的第一条语句出现，构造参数既可以传递给本类(this)的其他构造器，也可以传递给超类(super)的构造器。

一个对象变量可以指示多种实际类型的现象称为多态(polymorphism,\[ˌpɑˌliˈmɔrfɪzm])，在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamic binding)。

在 Java 中，不需要将方法声明为虚拟方法，动态绑定是默认的处理方式。如果不希望一个方法具有虚拟特征，可以将其标记为 final。

### 继承层次
继承并不仅限于一个层次，由一个公共超类派生出来的所有类的集合被称为继承层次(inheritance hierarchy,\[ˈhaɪərɑːrki])。

在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链(inheritance chain)。通常，一个祖先类可以拥有多个子孙继承链。

Java 不支持多继承。

### 多态
`is-a` 规则的另一种表述法是置换法则，它表明程序中出现超类对象的任何地方都可以用子类对象置换。例如，将一个子类对象赋给超类变量。

在 Java 程序设计语言中，对象变量是多态的。一个 Employee 变量既可以引用一个 Employee 类对象，也可以引用 Employee 类的任何一个子类的对象。
```java
Manager boss = new Manager("Yakui Wang", 10_000, 2019, 4, 28);
boss.setBonus(2000); // OK

Employee[] staff = new Employee[3];
staff[0] = boss;

staff[0].setBonus(2000); // ❌
// 变量 staff[0] 与 boss 引用同一个对象，
// 但编译器将 staff[0] 视为 Employee 对象
```
然而，不能将一个超类的引用赋给子类变量。

注意⚠️：在 Java 中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。
```java
Manager[] managers = new Manager[10];
Employee[] staff = managers; //OK managers 和 staff 引用的是同一个数组

staff[0] = new Employee("Bob", 30_000,2019,3,2); 
//编译器竟然接纳了这个赋值操作
//此时 staff[0] 和 managers[0] 引用的是同一个对象

//运行时异常：ArrayStoreException

managers[0].setBonus(2000);
```
为了确保不发生此类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

### 理解方法调用
假设要调用 `x.f(args)`，隐式参数 x 声明为类 C 的一个对象，调用过程如下：

1) 编译器查看对象的声明类型和方法名。有可能存在多个名为 f 但参数类型不一样的方法，编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法(超类的私有方法不可访问)。至此，编译器已获得所有可能被调用的候选方法。

2) 编译器将查看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析(overloading resolution)。如果编译器没有找到与之参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。至此，编译器已获得需要调用的方法名字和参数类型。

注意⚠️：方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。

注意⚠️：返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。

3) 如果是 private 方法、static 方法、final 方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定(static binding)。对应地，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。

4) 当程序运行，并且采用动态绑定调用方法时，虚拟机一定要调用与 x 所引用对象的实际类型最合适的那个类的方法。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表(method table)，其中列出了所有方法的签名和实际调用的方法。在真正调用方法时，虚拟机仅查找这个表即可。

动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。

警告⚠️：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是 public，子类方法一定要声明为 public。

### 阻止继承：final 类和方法
不允许扩展的类被称为 final 类。在定义类的时候使用 final 修饰符就表明这个类是 final 类。

类中的特定方法也可以被声明为 final。这样，子类就不能覆盖这个方法(final 类中的所有方法自动地成为 final 方法)。

注意⚠️：域也可以被声明为 final，对于 final 域而言，构造对象之后就不允许改变它们的值了。不过，<strong>如果将一个类声明为 final，只有其中的方法自动得成为 final，而不包括域。</strong>

将方法或类声明为 final 主要目的是：确保它们不会在子类中改变语义。

有些程序员认为：除非有足够的理由使用多态性，应该将所有的方法都声明为 final。事实上，在 C++ 中，如果没有特别地说明，所有的方法都不具有多态性。因此，在设计类层次时，仔细地考虑应该将哪些方法和类声明为 final。

在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对他进行优化处理，这个过程称为内联化(inlining)。然而，如果方法在另一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。

幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多，可以准确地知道类之间的继承关系，并能够检测出来类中是否真正地存在覆盖给定的方法。如果方法很简短，被频繁调用且没有真正地被覆盖，那么即时编译器就会对这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么优化器将取消对覆盖方法的内联。

### 强制类型转换
Java 程序设计语言提供了一种专门用于进行类型转换的表示法，对象引用的转换语法与基本类型的转换类似，仅需要用一对圆括号将目标类括起来，并放置在需要转换的对象引用之前就可以了。

进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。

在 Java 中，每个对象变量都属于一个类型，类型描述了这个变量所引用的以及能够引用的对象类型。

将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。

如果试图在继承链上进行向下的类型转换，并且“谎报”有关对象包含的内容，将会发生错误，产生一个 `java.lang.ClassCastException` 异常。

因此，在进行类型转换之前，先查看以下是否能够成功地转换，使用 `instanceof` 操作：
```java
if (staff[1] instanceof Manager) {
    boss = (Manager) staff[1];
}

// 如果 x 为 null
if (x instanceof C) {

}
// 不会产生异常，只是返回 false，因为 null 没有引用任何对象。
// 
```
综上所述：
- 只能在继承层次内进行类型转换；
- 在将超类转换成子类之前，应该使用 instanceof 进行检查。

通过类型转换调整对象的类型并不是一个好的做法。大多数情况下，并不需要将 `Employee` 对象转换为 `Manager` 对象，两个类的对象都能够正确地使用 `getSalary` 方法，这是因为实现多态性的动态绑定机制能够自动地找到相应的方法。

只有在使用 `Manager` 中特有的方法时才需要类型转换。需注意，只要没有捕获 `ClassCastException` 异常，程序就会终止执行。应该尽量少用类型转换和 `instanceof` 运算符。




## Object: 所有类的超类

## 泛型数组列表

## 对象包装器和自动装箱

## 参数数量可变的方法

## 枚举类

## 反射

## 继承的设计技巧

## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


