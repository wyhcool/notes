---
title: Java 面向对象程序设计
date: 2019-12-22 22:26:00
update: 
tags:
categories:
- Java
---

## 面向对象程序设计(OOP)概述
面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

在 OOP 中，不必关心对象的具体实现，只要能够满足用户的需求即可。

传统的结构化程序设计通过设计一系列的过程(即算法)来求解问题。一旦确定了这些过程，就要开始考虑存储数据的方式。Pascal 语言的设计者 Niklaus Wirth 将其著作命名为《算法 + 数据结构 = 程序》(Algorithms + Data Structures = Programs, 1975)，其中算法是第一位的，数据结构是第二位的，这明确地表述了程序员的工作方式，首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而 OOP 却调换了这个次序，将数据放在第一位，然后再去考虑操作数据的算法。

### 类
类(class)是构造对象的模板或蓝图，由类构造(construct)对象的过程称为创建类的实例(instance)。

封装(encapsulation，或称数据隐藏)是与对象有关的一个重要概念。从形式上看，封装是将数据和行为组合到一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域(instance field)，操纵数据的过程称为方法(method)。对于每个特定的类实例(对象)都有一组特定的实例域值，这些值的集合就是这个对象的当前状态(state)。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

实现封装的关键是绝对不能让类中的方法直接访问其他类的实例域，程序仅通过对象的方法与对象数据进行交互，这是提高重用性和可靠性的关键！这意味这一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道所发生的变化。

### 对象
使用 OOP 前一定要清楚对象的三个主要特性：
- 对象的行为(behavior)，可以对对象施加哪些操作，或可以对对象施加哪些方法？
- 对象的状态(state)，当施加那些方法时，对象如何响应？
- 对象标识(identity)，如何辨别具有相同行为与状态的不同对象？

同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性，对象的行为是由可调用的方法定义的。

每个对象都保存着描述当前特征的信息，这就是对象的状态。对象的状态可能会随着时间发生变化，但这种改变不会是自发的。<strong>对象状态的改变必须通过调用方法来实现</strong>(不经过方法调用就可以改变对象的状态，只能说明封装性遭到了破坏)。

对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份(identity)。作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异。

对象的这些关键特性在彼此之间相互影响着。

### 识别类
面向对象的程序设计首先从设计类开始，然后再往每个类中添加方法。

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。

### 类之间的关系
#### 依赖 dependence
依赖即 `uses-a` 关系，如果一个类的方法操纵另一个类的对象时，就认为一个类依赖于另一个类。

应该尽可能地将相互依赖的类减至最少，让类之间的耦合度最小。

#### 聚合 aggregation
聚合即 `has-a` 关系，聚合关系意味着类 A 的对象包含类 B 的对象。

#### 继承 inheritance
继承即 `is-a` 关系，用于表示特殊与一般的关系。


## 使用预定义类
### 对象与对象变量
要想使用对象，就必须首先构造对象，并指定其初始状态，然后，对对象应用方法。

在 Java 中，使用构造器(constructor)构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。

构造器的名字与类名相同，在构造器前面加上 new 操作符，可以构造一个新对象。

在对象与对象变量之间存在着一个重要区别：
```java
Date date; //date doesn't refer to any object
```
变量 date 不是一个对象，实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变量上。

必须首先初始化变量 date，可以用新构造的对象初始化这个变量，也可以让这个变量引用一个已存在的变量。

注意⚠️：一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象。在 Java 中，任何对象变量的值都是对存储在另一个地方的一个对象的引用。new 操作符的返回值也是一个引用。

可以显式地将对象变量设置为 null，表明这个对象目前没有引用任何对象。如果讲一个方法应用于一个值为 null 的对象上，那么就会产生运行时错误。

🌿局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。


在 C++ 中没有空引用，而且引用不能被赋值，可以将 Java 的对象变量看作 C++ 的对象指针：
```c++
Date birthday; //Java
//等同于
Date* birthday; //C++
```
一个 Date* 指针只能通过调用 new 进行初始化。如果把一个变量的值赋给另一个变量，两个变量就指向同一个地址，即它们是同一个对象的指针。在 Java 中的 null 引用对应着 C++ 中的 NULL 指针。

所有的 Java 对象都存储在堆中，当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

C++ 通过拷贝型构造器和复制操作符来实现对象的自动拷贝，在 Java 中，必须使用 clone 方法获得对象的完整拷贝。

### Java 类库中的 LocalDate 类
Date 类的实例有一个状态，即特定的时间点，时间是用距离一个固定时间点的毫秒数(可正可负)表示的，这个点就是所谓的纪元(epoch, \[ˈepək])，它是 UTC (Coordinated Universal Time)时间 1970 年 1 月 1 日 00:00:00，另外有 GMT(Greenwich Mean Time，格林威治时间)也是一种具有实践意义的科学标准时间。

但是 Date 类所提供的日期处理并没有太大用途，不同的地区采用不同的日期表示法。

类库的设计者将保存时间与给时间点命名分开，所以标准 Java 类库分别包含了两个类：一个用来表示时间点的 Date 类，另一个用来表示日历表示法的 LocalDate 类。

将时间与日历分开是一种很好的面向对象设计，通常，最好使用不同的类表示不同的概念。

不要使用构造器来构造 LocalDate 类的对象，应当使用静态工厂方法(factory method)来调用构造器：
```java
LocalDate.now()

//提供年、月和日来构造一个特定日期的对象
LocalDate.of(1999, 12, 31);
```
对于 LocalDate 对象，可以用方法 getYear、getMonthValue 和 getDayOfMonth 得到年、月和日，通过 plusDays 方法会得到一个新的 LocalDate，这个新日期对象是距当前对象指定天数的一个新日期。

LocalDate 类封装了实例域来维护所设置的日期。

注意⚠️：Date 类还有 getDay、getMonth 以及 getYear 等方法，然后并不推荐使用这些方法。当类库设计者意识到某个方法不应该存在时，就把它标记为不鼓励使用。

### 更改器方法和访问器方法
访问对象并修改对象的方法是一个更改器方法(mutator method)，而只访问对象而不修改对象的方法称为访问器方法(accessor method)。

注意：C++ 中带有 const 后缀的方法是访问器方法，默认为更改器方法。但是在 Java 中，访问器方法与更改器方法在语法上没有明显的区分。

java.time.LocalDate API 列表：
- static LocalTime now()，构造一个表示当前日期的对象。
- static LocalTime of(int year, int month, int day)，构造一个表示给定日期的对象。
- int getYear()，得到当前日期的年。
- int getMonthValue()，得到当前日期的月。
- int getDayOfMonth()，得到当前日期的日。
- DayOfWeeek getDayOfWeek()，得到当前日期为星期几，作为 DayOfWeek 类的一个实例返回。调用 getValue 来得到 1 ~ 7 之间的一个数，1 表示星期一，7 表示星期日。
- LocalDate plusDays(long n)，生成当前日期之后 n 天的日期。
- LocalDate minusDays(long n)，生成当前日期之前 n 天的日期。

## 用户自定义类

## 静态域与静态方法

## 方法参数

## 对象构造

## 包

## 类路径

## 文档注释

## 类设计技巧

## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


