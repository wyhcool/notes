---
title: 集合
date: 2019-02-09 12:56:00
tags:
categories:
- Java
---

## Java 集合框架
### 将集合的接口与实现分离
Java 集合类库将接口(interface)与实现(implementation)分离。

以队列(queue)为例，队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象时，并按照“先进先出”的规则检索对象时就应该使用队列。
```java
public interface Queue<E> { // a simplified form of the interface in the standard library
    void add(E element);
    E remove();
    int size();
}
```
接口并没有说明队列是如何实现的，队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。

每一个实现都可以通过一个实现了 `Queue` 接口的类表示：
```java
public class CircularArrayQueue<E> implements Queue<E> { // not an actual library class
    private int head;
    private int tail;
    private E[] elements;

    CircularArrayQueue(int capacity) { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}

public class LinkedListQueue<E> implements Queue<E> { // not an actual library class
    private Link head;
    private Link tail;

    LinkedListQueue() { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}
```
当在程序中使用队列时，一旦构建了集合，就无需知道实际使用了哪种实现。因此，只有在构造集合对象时，使用具体的类才有意义。可以使用接口类型来保存集合引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
当使用 `LinkedListQueue` 是个更好的选择时，只需要对调用构造器的地方作出修改：
```java
Queue<Customer> expressLane = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

### Collection 接口
在 Java 类库中，集合类的基本接口是 `Collection` 接口，这个接口有两个基本方法：
```java
package java.util;

public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
    Iterator<E> iterator();
    ...
}
```
`add` 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 `true`，如果集合没有发生变化就返回 `false`。

`iterator` 方法用于返回一个实现了 `Iterator` 接口的对象，可以使用这个迭代器对象依次访问集合中的元素。

### 迭代器
`Iterator` 接口包含 4 个方法：
```java
package java.util;

public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
通过反复调用 `next` 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，`next` 方法将抛出一个 `NoSuchElementException`。因此，需要在调用 `next` 之前调用 `hasNext` 方法。如果迭代器对象还有可供访问的元素，这个方法就返回 `true`。

如果想要查看集合中的所有元素，就请求一个迭代器：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext) {
    String elem = iter.next();
    // do something with elem
}
```

或者使用 `for each` 循环可以更加简练地表示同样的循环操作，编译器将 `for each` 循环翻译为带有迭代器的循环：
```java
Collection<String> c = ...;
for (String elem : c) {
     // do something with elem
}
```
`for each` 循环可以与任何实现了 `Iterable` 接口的对象一起工作，这个接口设计为：
```java
package java.lang;

public interface Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
`Collection` 接口扩展了 `Iterable` 接口，因此，对于标准类库中的任何集合都可以使用 `for each` 循环。

在 Java SE 8 中，甚至可以不用写循环。可以调用 `forEachRemaining` 方法并提供一个 `lambda` 表达式，将对迭代器的每一个元素调用这个 `lambda` 表达式，直到再没有元素为止：
```java
iterator.forEachRemaing(elem -> do something with elem);
```
元素被访问的顺序取决于集合类型。如果对 `ArrayList` 进行迭代，迭代器将从索引 0 开始，每迭代一次，索引值加 1；然后，如果访问 `HashSet` 中的元素，每个元素将会按照某种随机的次序出现，虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

Java 迭代器查找一个元素的唯一方法是调用 `next`，而在执行查找操作的同时，迭代器的位置随之向前移动。因此，可以将 Java 迭代器认为是两个元素之间。当调用 `next`时，迭代器就会越过下一个元素，并返回刚刚越过的那个元素的引用。

注意⚠️：可以将 `Iterator.next` 与 `InputStream.read` 看作为等效的。从数据流中读取一个字节，就会自动地消耗掉这个字节。下一次调用 `read` 将会消耗并返回输入的下一个字节。

`Iterator` 接口的 `remove` 方法将会删除上次调用 `next` 方法时返回的元素。在决定删除元素之前，需要先查看元素。但是，要删除特定位置的元素，则仍然需要跳过该元素：
```java
Iterator<String> it = c.iterator();
it.next(); // skip over the first element
it.remove(); // now remove it
```
更重要的是，对 `next` 方法和 `remove` 方法的调用具有互相依赖性。如果调用 `remove` 之前没有调用 `next` 将是不合法的。如果这样做，将会抛出一个 `IllegalStateException` 异常。

### 泛型实用方法
由于 `Collection` 与 `Iterator` 都是泛型接口，可以编写操作任何集合类型的实用方法。Java 类库设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用，这样，类库的使用者就不必自己重新构建这些方法了。

事实上，`Collection` 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
...
```
当然，如果每个实现 `Collection` 接口的类都必须提供这么多常规方法，那将是一件麻烦事。为了使实现者的工作更加轻松，Java 库提供了一个 `AbstractCollection` 类，该类保留基本方法 `size` 和 `iterator` 的抽象，但根据它们来实现常规方法。例如：
```java
public abstract class AbstractCollection<E>
    implements Collection<E> 
{
    ...
    public abstract Iterator<E> iterator();

    public boolean contains(Object obj) {
        for (E element: this) { // call iterator()
            if (element.equals(obj)) {
                return true;
            }
        }
        return false;
    }
    ...
}
```
此时，一个具体的集合类可以扩展 `AbstractCollection`，现在只需要由具体的集合类提供 `iterator` 方法，而 `contains` 方法已经由 `AbstractCollection` 超类提供了，但是如果子类有更加有效的方式实现 `contains` 方法，也可以由子类提供。

java.util.Collection\<E> 用到的方法：
- Iterator\<E> iterator()：返回一个用于访问集合中每个元素的迭代器。
- int size()：返回当前存储在集合中的元素个数。
- boolean isEmpty()：如果集合中没有元素，返回 `true`。
- boolean contains(Object obj)：如果集合中包含一个与 obj 相等的对象，返回 `true`。
- boolean containsAll(Collection\<?> other)：如果集合中包含 other 集合中的所有元素，返回 `true`。
- boolean add(Object element)：将一个元素添加到集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean addAll(Collection\<? extends E> other)：将 other 集合中的所有元素添加到这个集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean remove(Object obj)：从这个集合中删除等于 obj 的对象，如果有匹配的对象被删除，返回 `true`。
- boolean removeAll(Collection\<?> other)：从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 `true`。
- default boolean removeIf(Predicate<? super E> filter)：从这个集合中删除 filter 返回 `true` 的所有元素。如果由于这个调用改变了集合，返回 `true`。
- void clear()：从这个集合中删除所有的元素。
- boolean retainAll(Collection\<?> other)：从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 `true`。
- Object\[] toArray()：返回这个集合的对象数组。
- \<T> T\[] toArray(T\[] arrayToFill)：返回这个集合的对象数组。如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null；否则，分配一个新数组，其成员类型与 arrayToFill 的成员类型相同，其长度等于集合的大小，并填充集合元素。

java.util.Iterator\<E> 用到的方法：
- boolean hasNext()：如果存在可访问的元素，返回 `true`。
- E next()：返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`。
- void remove()：删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`。

### 集合框架中的接口
Java 集合框架为不同类型的集合定义了大量接口：
```java
       Iterable
          |
     Collection               Map          Iterator     RandomAccess
__________|__________          |              |
|         |         |          |              |
List     Set     Queue     SortedMap      ListIterator
          |                    |
      SortedSet           NavigableMap
          | 
      NavigableSet
```
集合有两个基本接口：`Collection` 和 `Map`。

由于映射包含键 / 值对，要用 `put` 方法来插入：
```java
V put(K key, V value)
```
从映射中读取值则要使用 `get` 方法：
```java
V get(K key)
```

`List` 是一个有序集合(ordered collection)，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问(random access)，因为这样可以按照任意顺序访问元素。与之不同的是，使用迭代器访问时，必须顺序地访问元素。

`List` 接口定义了多个用于随机访问的方法：
```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

`ListIterator` 接口是 `Iterator` 的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素：
```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用 `List` 方法并提供一个整数索引来访问。与之不同的是，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。

为了避免对链表完成随机访问操作，Java SE 1.4 引入一个标记接口 `RandomAccess`，这个接口不包含任何方法，可以用它来测试一个特定的集合是否支持高效的随机访问：
```java
if (c instanceof RandomAccess) {
    // use random access algorithm
} else {
    // use sequential access algorithm
}
```

`Set` 接口等同于 `Collection` 接口，不过其方法的行为有更严谨的定义。集(Set)的 `add` 方法不允许添加重复的元素。要适当地定义集的 `equals` 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。`hashCode` 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

`SortedSet` 和 `SortedMap` 接口会提供用于排序的比较器对象，这两个接口定义了可到集合子集视图的方法。

Java SE 6 引入了接口 `NavigableSet` 和 `NavigableMap`，其中包含一些用于搜索和遍历有序集和映射的方法。`TreeSet` 和 `TreeMap` 类实现了这些接口。


## 具体的集合
除了以 Map 结尾的类之外，其他类都实现了 `Collection` 接口，而以 Map 结尾的类实现了 `Map` 接口。

| 集合类型 | 描述 |
|:-|:-|
| ArrayList | 一种可以动态增长和缩减的索引序列 |
| LinkedList | 一种可以在任何位置进行高效地插入和删除操作的有序序列 |
| ArrayDeque | 一种用循环数组实现的双端队列 |
| HashSet | 一种没有重复元素的无序集合 |
| TreeSet | 一种有序集 |
| EnumSet | 一种包含枚举类型值的集 |
| LinkedHashSet | 一种可以记住元素插入次序的集 |
| PriorityQueue | 一种允许高效删除最小元素的集合 |
| HashMap | 一种存储键／值关联的数据结构 |
| TreeMap | 一种键值有序排列的映射表 |
| EnumMap | 一种键值属于枚举类型的映射表 |
| LinkedHashMap | 一种可以记住键／值添加次序的映射表 |
| WeakHashMap | 一种其值无用武之地可以被垃圾回收器回收的映射表 |
| IdentityHashMap | 一种用 == 而不是用 equals 比较键值的映射表 |

### 链表
数组以及动态的 `ArrayList` 数组列表类都有一个重大的缺陷：当从中间位置删除/插入一个元素要付出很大的代价，其原因是数组中处于被删除/插入元素之后的所有元素都要向数组的前端/后端移动。

尽管数组在连续的存储位置上存放对象引用，但链表(linked list)却将每个对象存放在独立的结点中，每个结点还存放着下一个结点的引用。在 Java 程序设计语言中，所有链表实际上都是双向链接的(double linked) —— 即每个结点还存放着指向前驱结点的引用。

从链表中间删除一个元素只需要更新被删除元素附近的链接。

先添加 3 个元素，然后再将第 2 个元素删除：
```java
List<String> staff = new LinkedList<>(); // LinkedList implements list
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next(); // visit first element
String second = iter.next(); // visit second element
iter.remove(); // remove last visited element
```

链表与泛型集合之间的重要区别：链表是一个有序集合(ordered collection)，每个对象的位置十分重要。`LinkedList.add` 方法将对象添加到链表的尾部，但是常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖位置的 `add` 方法由迭代器负责，只有对自然有序的集合使用迭代其添加元素才有实际意义。

比如，集(set)类型，其中的元素完全无序，因此，在 `Iterator` 接口中就没有 `add` 方法。相反地，集合类库提供了子接口 `ListIterator`，其中包含 `add` 方法。
```java
package java.util;

public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}
```
与 `Collection.add` 不同，这个方法不返回 `boolean` 类型的值，它假定添加操作总会改变链表。

另外，`ListIterator` 接口有两个方法，可以用来反向遍历链表：
```java
boolean hasPrevious();
E previous();
```
与 `next` 方法一样，`previous` 方法返回越过的对象。

`LinkedList` 类的 `listIterator` 方法返回一个实现了 `ListIterator` 接口的迭代器对象，`add` 方法在迭代器位置之前添加一个新对象：
```java
List<String> staff = new LinkedList<>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next(); // skip pass first element
iter.add("Juliet"); // 在第二个元素之前添加
```
如果多次调用 `add` 方法，将按照提供的次序把元素添加到链表中，它们被依次添加到迭代器当前位置之前。

当用一个刚刚由 `listIterator` 方法返回，并且指向链表表头的迭代器调用 `add` 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即 `hasNext` 返回 `false`)，添加的元素将变成列表的新表尾。如果链表有 n 个元素，有 n+1 个位置可以添加新元素，这些位置与迭代器的 n+1 个可能的位置相对应。

注意⚠️：在调用 `next` 之后，`remove` 方法确实会删除迭代器左侧的元素。但是，如果调用 `previous` 之后，，`remove` 方法会删除迭代器右侧的元素，且不能连续调用两次 `remove`。

`add` 方法只依赖于迭代器的位置，而 `remove` 方法依赖于迭代器的状态。

`set` 方法用一个新元素取代调用 `next` 或 `previous` 方法返回的上一个元素。

如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状态。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个 `ConcurrentModificationException` 异常。

为了避免发生并发修改的异常，请遵循：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

检测到并发修改的问题的方法：集合可以跟踪改写操作（诸如添加或删除元素）的次数，每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己已经改写操作的计数值是否与集合的改写操作计数值一致，如果不一致，抛出一个 `ConcurrentModificationException` 异常。

注意⚠️：对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。`set` 方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用 `set` 方法对现有的结点的内容进行修改。

在 Java 类库中，还提供了许多在理论上存在一定争议的方法。比如链表不支持快速随机访问，如果要查看链表中第 n 个元素，就必须从头开始，越过 n-1 个元素，没有捷径可走。尽管如此，`LinkedList` 类还是提供了一个用来访问某个特定元素的 `get` 方法。

绝对不应该使用这种让人误解的随机访问方法来遍历链表。每次查找一个元素都要从列表的头部重新开始搜索，`LinkedList` 对象根本不做任何缓存位置信息的操作。

列表迭代器接口还有一个方法，可以告之当前为位置的索引。由于 Java 迭代器指向两个元素之间的位置，所以可以同时产生两个索引：`nextIndex` 方法返回下一次调用 `next` 方法时返回元素的整数索引；`previousIndex` 方法返回下一次调用 `previous` 方法时返回元素的整数索引。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。

如果有一个整数索引 n，那么 `list.listIterator(n)` 将返回一个迭代器，这个迭代器指向索引为 n 的元素前面的位置，也就是说，调用 `next` 与调用 `list.get(n)` 会产生同一个元素，只是获得这个迭代器的效率比较低。

如果链表中只有很少几个元素，就完全没有必要为 `get` 方法和 `set` 方法的开销而烦恼。

使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用 `ArrayList`。

避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就是用数组或 `ArrayList`，而不要使用链表。

java.util.List\<E> 用到的方法：
- ListIterator\<E> listIterator()：返回一个列表迭代器，以便用来访问列表中的元素。
- ListIterator\<E> listIterator(int index)：返回一个列表迭代器，以便用来访问列表中的元素，这个元素是第一次调用 `next` 返回的给定索引的元素。
- void add(int i, E element)：在给定位置添加一个元素。
- void addAll(int i, Collection\<? extends E> elements)：将某个集合中的所有元素添加到给定位置。
- E remove(int i)：删除给定位置的元素并返回这个元素。
- E get(int i)：获取给定位置的元素。
- E set(int i, E element)：用新元素取代给定位置的元素，并返回原来那个元素。
- int indexOf(Object element)：返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回 -1。
- int lastIndexOf(Object element)：返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回 -1。

java.util.ListIterator\<E> 用到的方法：
- void add(E newElement)：在当前位置前添加一个元素。
- void set(E newElement)：用新元素取代 `next` 或 `previous` 上次访问的元素。如果在 `next` 或 `privious` 上次调用之后列表结构被修改了，将抛出一个 `IllegalStateException`。
- boolean hasPrevious()：当反向迭代列表时，还有可供访问的元素，返回 `true`。
- E previous()：返回前一个对象。如果已经到达了列表的头部，就抛出一个 `NoSuchElementException` 异常。
- int nextIndex()：返回下一次调用 `next` 方法时将返回的元素索引。
- int previousIndex()：返回下一次调用 `previous` 方法时将返回的元素索引。

java.util.LinkedList\<E> 用到的方法：
- LinkedList()：构造一个空链表。
- LinkedList(Collection\<? extends E> elements)：构造一个链表，并将集合中的所有元素添加到这个链表中。
- void addFirst(E element)
- void addLast(E element)：将某个元素添加到链表的头部或尾部。
- E getFirst()
- E getLast()：返回链表的头部或尾部的元素。
- E removeFirst()
- E removeLast()：删除并返回链表的头部或尾部的元素。

### 数组列表
`List` 接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。

有两种访问元素的协议：
- 迭代器
- `get` 和 `set` 方法随机访问

后者不适合链表，但对数组有用。

集合类库提供了 `ArrayList`，封装了一个动态再分配的对象数组。

注意⚠️：在需要动态数组时，可能会使用 `Vector` 类，`Vector` 类的所有方法都是同步的，可以由两个线程安全地访问一个 `Vector` 对象。但是，如果由一个线程访问 `Vector`，代码要在同步操作上耗费大量时间。而 `ArrayList` 方法不是同步的，因此，建议在不需要同步时使用 `ArrayList`。

### 散列集
散列表(hash table)为每个对象计算一个整数，称为散列码(hash code)，散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

如果自定义类，就需要负责实现这个类的 `hashCode` 方法。注意，自己实现的 `hashCode` 方法应该与 `equals` 方法兼容，即如果 `a.equals(b)` 为 `true`，a 与 b 必须具有相同的散列码。

最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。

在 Java 中，散列表用链表数组(arrays of linked lists)实现。每个列表被称为桶(bucket)。要向查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。

当计算出的桶中没有其他元素时，此时将元素直接插入桶中就可以了。当然，有时候会遇到桶被占满的情况，这也是不可避免的，这种现象被称为散列冲突(hash collision)。这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。
```
collision \[kəˈlɪʒn]n.碰撞(或相撞)事故; (两人之间或对立意见、看法等之间的) 冲突，抵触
```
如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。

在 Java SE 8 中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个相同散列码的值，这样就能提高性能。

如果想更多地控制散列表的性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果大致知道最终会有多少个元素要插入散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75% ~ 150%。另外，建议将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是 2 的幂，默认值是 16（为表大小提供的任何值都将被自动地转换为 2 的下一个幂）。

如果散列表太满，就需要再散列(rehashed)。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子(load factor)决定何时对散列表进行再散列。

如果装填因子是 0.75(默认值)，而表中超过 75% 的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。

散列表可以用于实现几个重要的数据结构。其中最简单的是 `set` 类型。`set` 是没有重复元素的元素集合，`set` 的 `add` 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

Java 集合类库提供了一个 `HashSet` 类，它实现了基于散列表的集。可以用 `add` 方法添加元素，`contains` 方法已经被重新定义，用来快速查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。

散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用 `HashSet`。

警告：在更改集中的元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。

java.util.HashSet\<E> 用到的方法：
- HashSet()：构造一个空散列集。
- HashSet(Collection\<? extends E> elements)：构造一个散列集，并将集合中的所有元素添加到这个散列集中。
- HashSet(int initialCapacity)：构造一个空的具有指定容量(桶数)的散列集。
- HashSet(int initialCapacity, float loadFactor)：构造一个具有指定容量和装填因子(一个介于 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集。

java.util.Object 用到的方法：
- int hashCode()：返回这个对象的散列码。散列码可以是任何整数，包括正数和负数。`equals` 和 `hashCode` 的定义必须兼容，即如果 `x.equals(y)` 为 `true`，`x.hashCode()` 必须等于 `y.hashCode()`。

### 树集
`TreeSet` 类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合(sorted collection)，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地敖着排序后的顺序呈现。

正如 `TreeSet` 类名所示，排序是用树结构完成的（当前实现使用的是红黑树(red-black tree)），每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比还是快很多。如果树中包含 n 个元素，查找新元素的正确位置平均需要 log<sub>2</sub>n 次比较。

要使用树集，必须能够比较元素。这些元素必须实现 `Comparable` 接口，或者构造集时必须提供一个 `Comparator`。

是否总是应该使用树集取代散列集？毕竟添加一个元素所话费的时间看上去并不是很长，而且元素是自动排序的。到底应该怎样做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。

java.util.TreeSet\<E> 用到的方法：
- TreeSet()
- TreeSet(Comparator\<? super E> comparator)：构造一个空树集。
- TreeSet(Collection\<? extends E> elements)
- TreeSet(SortedSet\<E> s)：构造一个树集，并增加一个集合或有序集中的所有元素。

java.util.SortedSet\<E> 用到的方法：
- Comparator\<? super E> comparator()：返回用于对元素进行排序的比较器。如果元素使用 `Comparable` 接口的 `compareTo` 方法进行比较则返回 `null`。
- E first()
- E last()：返回有序集中的最小元素或最大元素。

java.util.NavigableSet\<E> 用到的方法：
- E higher(E value)
- E lower(E value)：返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E ceiling(E value)
- E floor(E value)：返回大于等于 value 的最小元素或小于等于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E pollFirst()
- E pollLast()：删除并返回这个集中的最大元素或最小元素，这个集为空时返回 `null`。
- Iterator\<E> descendingIterator()：返回一个按照递减顺序遍历集中元素的迭代器。

### 队列与双端队列
队列可以在尾部添加一个元素，在头部删除一个元素。

有两个端头的队列，即双端队列，可以在头部和尾部同时添加或删除元素。

不支持在队列中间添加元素。

在 Java SE 6 中引入了 `Deque` 接口，并由 `ArrayDeque` 和 `LinkedList` 类实现，这两个类都提供了双端队列，而且在必要时可以增加队列的长度。

java.util.Queue\<E> 用到的方法：
- boolean add(E element)
- boolean offer(E element)：如果队列未满，则将给定元素添加到此双端队列的末尾并返回 `true`。 如果队列已满，则第一个方法将引发 `IllegalStateException`，而第二个方法将返回 `false`。
- E remove()
- E poll()：假设队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 `null`。
- E element()
- E peek()：如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 `null`。

java.util.Deque\<E> 用到的方法：
- void addFirst(E element)
- void addLast(E element)
- boolean offerFirst(E element)
- boolean offerLast(E element)：将给定的对象添加到双端队列的头部或尾部。如果队列已满，则前两个方法将引发 `IllegalStateException`，而后两个方法将返回 `false`。
- E removeFirst()
- E removeLast()
- E pollFirst()
- E pollLast()：假设队列不空，删除并返回这个双端队列头部或尾部的元素。如果队列是空的，前两个方法抛出 `NoSuchElementException`，而后两个方法返回 `null`。
- E getFirst()
- E getLast()
- E peekFirst()
- E peekLast()：如果队列不空，返回这个双端队列头部或尾部的元素，但不删除。如果队列空，前两个方法抛出 `NoSuchElementException`，而后两个方法返回 `null`。

java.util.ArrayDeque\<E> 用到的方法：
- ArrayDeque()
- ArrayDeque(int initialCapacity)：用初始容量 16 或给定的初始容量构造一个无限双端队列。

### 优先级队列
优先级队列(priority queue)中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用 `remove` 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆(heap)。堆是一个可以自我调整的二叉树，对树执行添加(add)和删除(remove)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。

与 `TreeSet` 一样，一个优先级队列既可以保存实现了 `Comparable` 接口的类对象，也可以保存在构造器中提供的 `Comparator` 对象。

使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除。(由于习惯上将 1 设为最高优先级，所以会将最小的元素删除)。

与 `TreeSet` 中的迭代不同，这里的迭代并不是按照元素的排列顺序访问的，而删除元素却总是删除掉剩余元素中优先级数最小的那个元素。

java.util.PriorityQueue 用到的方法：
- PriorityQueue()
- PriorityQueue(int initialCapacity)：构造一个用于存放 `Comparable` 对象的优先级队列。
- PriorityQueue(int initialCapacity, Comparator<? super E> c)：构造一个优先级队列，并用指定的比较器对元素进行排序。


## 映射
映射(map)用来存放键／值对。

### 基本映射操作
Java 类库为映射提供了两个通用的实现：`HashMap` 和 `TreeMap`，这两个类都实现了 `Map` 接口。

散列映射对键进行散列，树映射用键的整体顺序进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键相关的值不能进行散列或比较。

如何选择散列映射或树映射呢？与集一样，散列稍微快一些，如果不需要按照排列顺序访问键，就最好选择散列。

每当往映射中添加对象时，必须同时提供一个键。

要检索一个对象，必须使用一个键。

如果在映射中没有与给定键对应的信息，`get` 将返回 `null`。`null` 返回值可能并不方便，有时可以有一个好的默认值，用作映射中不存在的键，然后使用 `getOrDefault` 方法。

键必须是唯一的，不能对同一个键存放两个值，如果对同一个键两次调用 `put` 方法，第二个值就会取代第一个值，实际上，`put` 将返回用这个键参数存储的上一个值。

`remove` 方法用于从映射中删除给定键对应的元素。

`size` 方法用于返回映射中的元素数。

要迭代处理映射的键和值，最容易的方法是使用 `forEach` 方法，可以提供一个接收键和值的 lambda 表达式，映射中的每一项会依序调用这个表达式。

java.util.Map\<K, V> 用到的方法：
- V get(Object key)：获取与键对应的值，返回与键对应的对象，如果在映射中没有这个对象则返回 `null`，键可以为 `null`。
- default V getOrDefault(Object key, V defaultValue)：获得与键关联的值，返回与键关联的对象，或者如果未在映射中找到这个键，则返回 defaultValue。
- V put(K key, V value)：将键与对应的值插入映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象。这个方法将返回键对应的旧值，如果这个键以前没有出现过则返回 `null`。键可以为 null，但值不能为 `null`。
- void putAll(Map<? extends K, ? extends V> entries)：将给定映射中的所有条目添加到这个映射中。
- boolean containsKey(Object key)：如果映射中已经有这个键，返回 `true`。
- boolean containsValue(Object value)：如果映射中已经有这个值，返回 `true`。
- default void forEach(BiConsumer<? super K, ? super V> action)：对这个映射中的所有键／值对应用这个动作。

java.util.HashMap<K, V> 用到的方法：
- HashMap()
- HashMap(int initialCapacity)
- HashMap(int initialCapacity, float loadFactor)：用给定的容量和装填因子构造一个空散列映射。

java.util.TreeMap<K, V>  用到的方法：
- TreeMap()：为实现 `Comparable` 接口的键构造一个空的树映射。
- TreeMap(Comparator<? super K> c)：构造一个树映射，并使用一个指定的比较器对键进行排序。
- TreeMap(Map<? extends K, ? extends V> entries)：构造一个树映射，并将某个映射中的所有条目添加到树映射中。
- TreeMap(SortedMap<? extends K, ? extends V> entries)：构造一个树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器。

java.util.SortedMap<K, V> 用到的方法：
- Comparator<? super K> comparator()：返回对键进行排序的比较器，如果键是用 `Comparable` 接口的 `compareTo` 方法进行比较的，返回 `null`。
- K firstKey()
- K lastKey()：返回映射中最小键和最大键。

### 更新映射项
正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。

需注意，当键第一次出现时，`get` 方法会返回 `null`，因此会出现一个 `NullPointerException` 异常。作为一个简单的补救，可以使用 `getOrDefault` 方法：
```java
counts.put(word, counts.getOrDefault(word, 0) + 1);
```

另一种方法是首先调用 `putIfAbsent`，只有当键原先不存在时，才会放入一个值。
```java
counts.putIfAbsent(word, 0);
counts.put(word, counts.get(word) + 1);
```

更好的方式是使用 `merge` 方法来简化操作：
```java
counts.merge(word, 1, Integer::sum);
```
将把 word 与 1 关联，否则使用 `Integer::sum` 函数将原值与 1 求和。

java.util.Map<K, V> 用到的方法：
- default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：如果 key 与一个非 `null` 值 v 关联，将函数应用到 v 和 value，将 key 与结果关联，或者如果结果为 `null`，则删除这个键，否则将 key 与 value 关联，返回 `get(key)`。
- defualt V compute(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：将函数应用到 key 和 get(key)，将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default V computeIfPresent(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：如果 key 与一个非 `null` 值 v 关联，将函数应用到 key 和 v，将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default V computeIfAbsent(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：将函数应用到 key，除非 key 与一个非 `null` 值关联。将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default void replaceAll(BiFunction<? super V, ? super V, ? extends V> remappingFunction)：在所有映射项上应用函数。将键与非 `null` 结果关联，对于 `null` 结果，则将相应的键删除。

### 映射视图
集合框架不认为映射本身是一个集合，不过，可以得到映射的视图(view)，这是实现了 `Collection` 接口或某个子接口的对象。

有 3 种视图：键集，值集合，以及键／值对集，键和键／值对可以构成一个集，因为映射中一个键只能有一个副本：
```java
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet() //条目集的元素是实现 Map.Entry 接口的类的对象
```
注意⚠️：`keySet` 不是 `HashSet` 或 `TreeSet`，而是实现了 `Set` 接口的另外某个类的对象，`Set` 接口扩展了 `Collection` 接口，因此，可以像使用集合一样使用 `keySet`。

枚举一个映射的所有键：
```java
Set<String> keys = map.keySet();
for (String key : keys) {
    // do something with key
}
```

同时查看键和值，可以通过枚举条目来避免查找值：
```java
for (Map.Entry(String, Employee) entry : staff.entrySet()) {
    String k = entry.getKey();
    Employee v = entry.getValue();
    // do something with k, v
}

// 原先这是访问所有映射条目的最高效的方法，但是，现在只需要使用 forEach 方法
```

如果在键集视图上调用迭代器的 `remove` 方法，实际上会从映射中删除这个键和与它关联的值，但是，不能向键集视图增加元素。另外，如果增加一个键而没有同时增加值也是没有意义的，如果试图调用 `add` 方法，它会抛出一个 `UnsupportedOperationException`。

对于条目集视图也有同样的限制。

java.util.Map\<K, V> 用到的方法：
- Set\<Map.Entry<K, V>> entrySet()：返回 `Map.Entry` 对象（映射中的键／值对）的一个集视图，可以从这个集合中删除元素，它们将从映射中删除，但是不能增加任何元素。
- Set\<K> keySet()：返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但是不能增加任何元素。
- Collection\<V> values()：返回映射中所有值的一个集合视图，可以从这个集合中删除元素，所删除的值及相应的键从映射中删除，但是不能增加任何元素。

java.util.Map.Entry\<K, V> 用到的方法：
- K getKey()
- V getValue()：返回这一条目的键或值。
- V setValue(V newValue)：将相关映射中的值改为新值，并返回原来的值。

### 弱散列映射
设计 `WeakHashMap` 类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了，将会出现什么情况？假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现过这个键，所以，这个键／值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？难道删除无用的对象不是垃圾回收器的工作吗？

遗憾的是，垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。因此，需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用 `WeakHashMap` 完成这件事情。当对键的唯一引用来自散列条目时，这一数据结构将于垃圾回收器协同工作一起删除键／值对。

`WeakHashMap` 使用弱引用(weak references)保存键。`WeakReference` 对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。

通常垃圾回收器发现某个特定的对象已经没有其他引用了，就将其回收。然而，如果某个对象只能由 `WeakReference` 引用，垃圾回收器仍然要回收它，但是要将引用这个对象的弱引用放入队列中。`WeakHashMap` 将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来，然后，`WeakHashMap` 将删除对应的条目。

### 链接散列集与映射
`LinkedHashSet` 和 `LinkedHashMap` 类用来记住插入元素项的顺序，这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。

链接散列映射将使用访问顺序，而不是插入顺序，对映射条目进行迭代。每次调用 `get` 或 `put`，受到影响的条目将从当前的位置删除，并放到条目链表的尾部（只有条目在链表中的位置会受影响，而散列表中的桶不会受影响，一个条目总位于与键散列码对应的桶中）。

访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取，当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉，这些是近期最少使用的几个元素。

存放 100 个元素的高速缓存，每当方法返回 `true` 时，就添加一个新条目，从而导致删除 `eldest` 条目：
```java
Map<K, V> cache = new LinkedHashMap<>(128, 0.75F, true) {
    protected boolean removeEldestEntry(Map.Entry(K, V) eldest) {
        return size() > 100;
    }
};
```

### 枚举集与映射
`EnumSet` 是一个枚举类型元素集的高效实现，由于枚举类型只有有限个实例，所以 `EnumSet` 内部用位序列实现。如果对应的值在集中，则相应的位置被置为 1。

`EnumSet` 类没有公共的构造器，可以使用静态工厂方法构造这个集：
```java
enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };

public static void main(String[] args) {

    EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
    EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
    EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
    EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);

}
```
可以使用 `Set` 接口的常用方法来修改 `EnumSet`。

`EnumMap` 是一个键类型为枚举类型的类型，它可以直接且高效地使用一个值数组实现，在使用时，需要在构造器中指定键类型：
```java
EnumMap<Weekday, Employee> personInCharge = new EnumMap<>(Weekday.class);
```

注意：`E extends Enum<E>` 这样的类型参数表示 E 是一个枚举类型，所有的枚举类型都扩展于泛型 `Enum` 类。

### 标识散列映射
类 `IdentityHashMap` 有特殊的作用，在这个类中，键的散列值不是用 `hashCode` 函数计算的，而是用 `System.identityHashCode` 方法计算的，这是 `Object.hashCode` 方法根据对象的内存地址来计算散列码时所使用的方式，而且，在对两个对象进行比较时，`IdentityHashMap` 类使用 `==`，而不使用 `equals`。

也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。

在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。


## 视图与包装器



## 算法


## 遗留的集合


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8