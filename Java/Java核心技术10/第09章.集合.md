---
title: 集合
date: 2019-02-09 12:56:00
tags:
categories:
- Java
---

## Java 集合框架
### 将集合的接口与实现分离
Java 集合类库将接口(interface)与实现(implementation)分离。

以队列(queue)为例，队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象时，并按照“先进先出”的规则检索对象时就应该使用队列。
```java
public interface Queue<E> { // a simplified form of the interface in the standard library
    void add(E element);
    E remove();
    int size();
}
```
接口并没有说明队列是如何实现的，队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。

每一个实现都可以通过一个实现了 `Queue` 接口的类表示：
```java
public class CircularArrayQueue<E> implements Queue<E> { // not an actual library class
    private int head;
    private int tail;
    private E[] elements;

    CircularArrayQueue(int capacity) { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}

public class LinkedListQueue<E> implements Queue<E> { // not an actual library class
    private Link head;
    private Link tail;

    LinkedListQueue() { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}
```
当在程序中使用队列时，一旦构建了集合，就无需知道实际使用了哪种实现。因此，只有在构造集合对象时，使用具体的类才有意义。可以使用接口类型来保存集合引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
当使用 `LinkedListQueue` 是个更好的选择时，只需要对调用构造器的地方作出修改：
```java
Queue<Customer> expressLane = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

### Collection 接口
在 Java 类库中，集合类的基本接口是 `Collection` 接口，这个接口有两个基本方法：
```java
package java.util;

public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
    Iterator<E> iterator();
    ...
}
```
`add` 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 `true`，如果集合没有发生变化就返回 `false`。

`iterator` 方法用于返回一个实现了 `Iterator` 接口的对象，可以使用这个迭代器对象依次访问集合中的元素。

### 迭代器
`Iterator` 接口包含 4 个方法：
```java
package java.util;

public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
通过反复调用 `next` 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，`next` 方法将抛出一个 `NoSuchElementException`。因此，需要在调用 `next` 之前调用 `hasNext` 方法。如果迭代器对象还有可供访问的元素，这个方法就返回 `true`。

如果想要查看集合中的所有元素，就请求一个迭代器：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext) {
    String elem = iter.next();
    // do something with elem
}
```

或者使用 `for each` 循环可以更加简练地表示同样的循环操作，编译器将 `for each` 循环翻译为带有迭代器的循环：
```java
Collection<String> c = ...;
for (String elem : c) {
     // do something with elem
}
```
`for each` 循环可以与任何实现了 `Iterable` 接口的对象一起工作，这个接口设计为：
```java
package java.lang;

public interface Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
`Collection` 接口扩展了 `Iterable` 接口，因此，对于标准类库中的任何集合都可以使用 `for each` 循环。

在 Java SE 8 中，甚至可以不用写循环。可以调用 `forEachRemaining` 方法并提供一个 `lambda` 表达式，将对迭代器的每一个元素调用这个 `lambda` 表达式，直到再没有元素为止：
```java
iterator.forEachRemaing(elem -> do something with elem);
```
元素被访问的顺序取决于集合类型。如果对 `ArrayList` 进行迭代，迭代器将从索引 0 开始，每迭代一次，索引值加 1；然后，如果访问 `HashSet` 中的元素，每个元素将会按照某种随机的次序出现，虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

Java 迭代器查找一个元素的唯一方法是调用 `next`，而在执行查找操作的同时，迭代器的位置随之向前移动。因此，可以将 Java 迭代器认为是两个元素之间。当调用 `next`时，迭代器就会越过下一个元素，并返回刚刚越过的那个元素的引用。

注意⚠️：可以将 `Iterator.next` 与 `InputStream.read` 看作为等效的。从数据流中读取一个字节，就会自动地消耗掉这个字节。下一次调用 `read` 将会消耗并返回输入的下一个字节。

`Iterator` 接口的 `remove` 方法将会删除上次调用 `next` 方法时返回的元素。在决定删除元素之前，需要先查看元素。但是，要删除特定位置的元素，则仍然需要跳过该元素：
```java
Iterator<String> it = c.iterator();
it.next(); // skip over the first element
it.remove(); // now remove it
```
更重要的是，对 `next` 方法和 `remove` 方法的调用具有互相依赖性。如果调用 `remove` 之前没有调用 `next` 将是不合法的。如果这样做，将会抛出一个 `IllegalStateException` 异常。

### 泛型实用方法
由于 `Collection` 与 `Iterator` 都是泛型接口，可以编写操作任何集合类型的实用方法。Java 类库设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用，这样，类库的使用者就不必自己重新构建这些方法了。

事实上，`Collection` 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
...
```
当然，如果每个实现 `Collection` 接口的类都必须提供这么多常规方法，那将是一件麻烦事。为了使实现者的工作更加轻松，Java 库提供了一个 `AbstractCollection` 类，该类保留基本方法 `size` 和 `iterator` 的抽象，但根据它们来实现常规方法。例如：
```java
public abstract class AbstractCollection<E>
    implements Collection<E> 
{
    ...
    public abstract Iterator<E> iterator();

    public boolean contains(Object obj) {
        for (E element: this) { // call iterator()
            if (element.equals(obj)) {
                return true;
            }
        }
        return false;
    }
    ...
}
```
此时，一个具体的集合类可以扩展 `AbstractCollection`，现在只需要由具体的集合类提供 `iterator` 方法，而 `contains` 方法已经由 `AbstractCollection` 超类提供了，但是如果子类有更加有效的方式实现 `contains` 方法，也可以由子类提供。

java.util.Collection\<E> 用到的方法：
- Iterator\<E> iterator()：返回一个用于访问集合中每个元素的迭代器。
- int size()：返回当前存储在集合中的元素个数。
- boolean isEmpty()：如果集合中没有元素，返回 `true`。
- boolean contains(Object obj)：如果集合中包含一个与 obj 相等的对象，返回 `true`。
- boolean containsAll(Collection\<?> other)：如果集合中包含 other 集合中的所有元素，返回 `true`。
- boolean add(Object element)：将一个元素添加到集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean addAll(Collection\<? extends E> other)：将 other 集合中的所有元素添加到这个集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean remove(Object obj)：从这个集合中删除等于 obj 的对象，如果有匹配的对象被删除，返回 `true`。
- boolean removeAll(Collection\<?> other)：从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 `true`。
- default boolean removeIf(Predicate<? super E> filter)：从这个集合中删除 filter 返回 `true` 的所有元素。如果由于这个调用改变了集合，返回 `true`。
- void clear()：从这个集合中删除所有的元素。
- boolean retainAll(Collection\<?> other)：从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 `true`。
- Object\[] toArray()：返回这个集合的对象数组。
- \<T> T\[] toArray(T\[] arrayToFill)：返回这个集合的对象数组。如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null；否则，分配一个新数组，其成员类型与 arrayToFill 的成员类型相同，其长度等于集合的大小，并填充集合元素。

java.util.Iterator\<E> 用到的方法：
- boolean hasNext()：如果存在可访问的元素，返回 `true`。
- E next()：返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`。
- void remove()：删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`。

### 集合框架中的接口
Java 集合框架为不同类型的集合定义了大量接口：
```java
       Iterable
          |
     Collection               Map          Iterator     RandomAccess
__________|__________          |              |
|         |         |          |              |
List     Set     Queue     SortedMap      ListIterator
          |                    |
      SortedSet           NavigableMap
          | 
      NavigableSet
```
集合有两个基本接口：`Collection` 和 `Map`。

由于映射包含键 / 值对，要用 `put` 方法来插入：
```java
V put(K key, V value)
```
从映射中读取值则要使用 `get` 方法：
```java
V get(K key)
```

`List` 是一个有序集合(ordered collection)，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问(random access)，因为这样可以按照任意顺序访问元素。与之不同的是，使用迭代器访问时，必须顺序地访问元素。

`List` 接口定义了多个用于随机访问的方法：
```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

`ListIterator` 接口是 `Iterator` 的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素：
```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用 `List` 方法并提供一个整数索引来访问。与之不同的是，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。

为了避免对链表完成随机访问操作，Java SE 1.4 引入一个标记接口 `RandomAccess`，这个接口不包含任何方法，可以用它来测试一个特定的集合是否支持高效的随机访问：
```java
if (c instanceof RandomAccess) {
    // use random access algorithm
} else {
    // use sequential access algorithm
}
```

`Set` 接口等同于 `Collection` 接口，不过其方法的行为有更严谨的定义。集(Set)的 `add` 方法不允许添加重复的元素。要适当地定义集的 `equals` 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。`hashCode` 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

`SortedSet` 和 `SortedMap` 接口会提供用于排序的比较器对象，这两个接口定义了可到集合子集视图的方法。

Java SE 6 引入了接口 `NavigableSet` 和 `NavigableMap`，其中包含一些用于搜索和遍历有序集和映射的方法。`TreeSet` 和 `TreeMap` 类实现了这些接口。


## 具体的集合
除了以 Map 结尾的类之外，其他类都实现了 `Collection` 接口，而以 Map 结尾的类实现了 `Map` 接口。

| 集合类型 | 描述 |
|:-|:-|
| ArrayList | 一种可以动态增长和缩减的索引序列 |
| LinkedList | 一种可以在任何位置进行高效地插入和删除操作的有序序列 |
| ArrayDeque | 一种用循环数组实现的双端队列 |
| HashSet | 一种没有重复元素的无序集合 |
| TreeSet | 一种有序集 |
| EnumSet | 一种包含枚举类型值的集 |
| LinkedHashSet | 一种可以记住元素插入次序的集 |
| PriorityQueue | 一种允许高效删除最小元素的集合 |
| HashMap | 一种存储键／值关联的数据结构 |
| TreeMap | 一种键值有序排列的映射表 |
| EnumMap | 一种键值属于枚举类型的映射表 |
| LinkedHashMap | 一种可以记住键／值添加次序的映射表 |
| WeakHashMap | 一种其值无用武之地可以被垃圾回收器回收的映射表 |
| IdentityHashMap | 一种用 == 而不是用 equals 比较键值的映射表 |

### 链表
数组以及动态的 `ArrayList` 数组列表类都有一个重大的缺陷：当从中间位置删除/插入一个元素要付出很大的代价，其原因是数组中处于被删除/插入元素之后的所有元素都要向数组的前端/后端移动。

尽管数组在连续的存储位置上存放对象引用，但链表(linked list)却将每个对象存放在独立的结点中，每个结点还存放着下一个结点的引用。在 Java 程序设计语言中，所有链表实际上都是双向链接的(double linked) —— 即每个结点还存放着指向前驱结点的引用。

从链表中间删除一个元素只需要更新被删除元素附近的链接。

先添加 3 个元素，然后再将第 2 个元素删除：
```java
List<String> staff = new LinkedList<>(); // LinkedList implements list
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next(); // visit first element
String second = iter.next(); // visit second element
iter.remove(); // remove last visited element
```

链表与泛型集合之间的重要区别：链表是一个有序集合(ordered collection)，每个对象的位置十分重要。`LinkedList.add` 方法将对象添加到链表的尾部，但是常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖位置的 `add` 方法由迭代器负责，只有对自然有序的集合使用迭代其添加元素才有实际意义。

比如，集(set)类型，其中的元素完全无序，因此，在 `Iterator` 接口中就没有 `add` 方法。相反地，集合类库提供了子接口 `ListIterator`，其中包含 `add` 方法。
```java
package java.util;

public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}
```
与 `Collection.add` 不同，这个方法不返回 `boolean` 类型的值，它假定添加操作总会改变链表。

另外，`ListIterator` 接口有两个方法，可以用来反向遍历链表：
```java
boolean hasPrevious();
E previous();
```
与 `next` 方法一样，`previous` 方法返回越过的对象。

`LinkedList` 类的 `listIterator` 方法返回一个实现了 `ListIterator` 接口的迭代器对象，`add` 方法在迭代器位置之前添加一个新对象：
```java
List<String> staff = new LinkedList<>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next(); // skip pass first element
iter.add("Juliet"); // 在第二个元素之前添加
```
如果多次调用 `add` 方法，将按照提供的次序把元素添加到链表中，它们被依次添加到迭代器当前位置之前。

当用一个刚刚由 `listIterator` 方法返回，并且指向链表表头的迭代器调用 `add` 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即 `hasNext` 返回 `false`)，添加的元素将变成列表的新表尾。如果链表有 n 个元素，有 n+1 个位置可以添加新元素，这些位置与迭代器的 n+1 个可能的位置相对应。

注意⚠️：在调用 `next` 之后，`remove` 方法确实会删除迭代器左侧的元素。但是，如果调用 `previous` 之后，，`remove` 方法会删除迭代器右侧的元素，且不能连续调用两次 `remove`。

`add` 方法只依赖于迭代器的位置，而 `remove` 方法依赖于迭代器的状态。

`set` 方法用一个新元素取代调用 `next` 或 `previous` 方法返回的上一个元素。

如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状态。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个 `ConcurrentModificationException` 异常。

为了避免发生并发修改的异常，请遵循：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

检测到并发修改的问题的方法：集合可以跟踪改写操作（诸如添加或删除元素）的次数，每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己已经改写操作的计数值是否与集合的改写操作计数值一致，如果不一致，抛出一个 `ConcurrentModificationException` 异常。

注意⚠️：对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。`set` 方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用 `set` 方法对现有的结点的内容进行修改。

在 Java 类库中，还提供了许多在理论上存在一定争议的方法。比如链表不支持快速随机访问，如果要查看链表中第 n 个元素，就必须从头开始，越过 n-1 个元素，没有捷径可走。尽管如此，`LinkedList` 类还是提供了一个用来访问某个特定元素的 `get` 方法。

绝对不应该使用这种让人误解的随机访问方法来遍历链表。每次查找一个元素都要从列表的头部重新开始搜索，`LinkedList` 对象根本不做任何缓存位置信息的操作。

列表迭代器接口还有一个方法，可以告之当前为位置的索引。由于 Java 迭代器指向两个元素之间的位置，所以可以同时产生两个索引：`nextIndex` 方法返回下一次调用 `next` 方法时返回元素的整数索引；`previousIndex` 方法返回下一次调用 `previous` 方法时返回元素的整数索引。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。

如果有一个整数索引 n，那么 `list.listIterator(n)` 将返回一个迭代器，这个迭代器指向索引为 n 的元素前面的位置，也就是说，调用 `next` 与调用 `list.get(n)` 会产生同一个元素，只是获得这个迭代器的效率比较低。

如果链表中只有很少几个元素，就完全没有必要为 `get` 方法和 `set` 方法的开销而烦恼。

使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用 `ArrayList`。

避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就是用数组或 `ArrayList`，而不要使用链表。

java.util.List\<E> 用到的方法：
- ListIterator\<E> listIterator()：返回一个列表迭代器，以便用来访问列表中的元素。
- ListIterator\<E> listIterator(int index)：返回一个列表迭代器，以便用来访问列表中的元素，这个元素是第一次调用 `next` 返回的给定索引的元素。
- void add(int i, E element)：在给定位置添加一个元素。
- void addAll(int i, Collection\<? extends E> elements)：将某个集合中的所有元素添加到给定位置。
- E remove(int i)：删除给定位置的元素并返回这个元素。
- E get(int i)：获取给定位置的元素。
- E set(int i, E element)：用新元素取代给定位置的元素，并返回原来那个元素。
- int indexOf(Object element)：返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回 -1。
- int lastIndexOf(Object element)：返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回 -1。

java.util.ListIterator\<E> 用到的方法：
- void add(E newElement)：在当前位置前添加一个元素。
- void set(E newElement)：用新元素取代 `next` 或 `previous` 上次访问的元素。如果在 `next` 或 `privious` 上次调用之后列表结构被修改了，将抛出一个 `IllegalStateException`。
- boolean hasPrevious()：当反向迭代列表时，还有可供访问的元素，返回 `true`。
- E previous()：返回前一个对象。如果已经到达了列表的头部，就抛出一个 `NoSuchElementException` 异常。
- int nextIndex()：返回下一次调用 `next` 方法时将返回的元素索引。
- int previousIndex()：返回下一次调用 `previous` 方法时将返回的元素索引。

java.util.LinkedList\<E> 用到的方法：
- LinkedList()：构造一个空链表。
- LinkedList(Collection\<? extends E> elements)：构造一个链表，并将集合中的所有元素添加到这个链表中。
- void addFirst(E element)
- void addLast(E element)：将某个元素添加到链表的头部或尾部。
- E getFirst()
- E getLast()：返回链表的头部或尾部的元素。
- E removeFirst()
- E removeLast()：删除并返回链表的头部或尾部的元素。

### 数组列表
`List` 接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。

有两种访问元素的协议：
- 迭代器
- `get` 和 `set` 方法随机访问

后者不适合链表，但对数组有用。

集合类库提供了 `ArrayList`，封装了一个动态再分配的对象数组。

注意⚠️：在需要动态数组时，可能会使用 `Vector` 类，`Vector` 类的所有方法都是同步的，可以由两个线程安全地访问一个 `Vector` 对象。但是，如果由一个线程访问 `Vector`，代码要在同步操作上耗费大量时间。而 `ArrayList` 方法不是同步的，因此，建议在不需要同步时使用 `ArrayList`。

### 散列集
散列表(hash table)为每个对象计算一个整数，称为散列码(hash code)，散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

如果自定义类，就需要负责实现这个类的 `hashCode` 方法。注意，自己实现的 `hashCode` 方法应该与 `equals` 方法兼容，即如果 `a.equals(b)` 为 `true`，a 与 b 必须具有相同的散列码。

最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。

在 Java 中，散列表用链表数组(arrays of linked lists)实现。每个列表被称为桶(bucket)。要向查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。

当计算出的桶中没有其他元素时，此时将元素直接插入桶中就可以了。当然，有时候会遇到桶被占满的情况，这也是不可避免的，这种现象被称为散列冲突(hash collision)。这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。
```
collision \[kəˈlɪʒn]n.碰撞(或相撞)事故; (两人之间或对立意见、看法等之间的) 冲突，抵触
```
如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。

在 Java SE 8 中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个相同散列码的值，这样就能提高性能。

如果想更多地控制散列表的性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果大致知道最终会有多少个元素要插入散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75% ~ 150%。另外，建议将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是 2 的幂，默认值是 16（为表大小提供的任何值都将被自动地转换为 2 的下一个幂）。

如果散列表太满，就需要再散列(rehashed)。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子(load factor)决定何时对散列表进行再散列。

如果装填因子是 0.75(默认值)，而表中超过 75% 的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。

散列表可以用于实现几个重要的数据结构。其中最简单的是 `set` 类型。`set` 是没有重复元素的元素集合，`set` 的 `add` 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

Java 集合类库提供了一个 `HashSet` 类，它实现了基于散列表的集。可以用 `add` 方法添加元素，`contains` 方法已经被重新定义，用来快速查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。

散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用 `HashSet`。

警告：在更改集中的元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。

java.util.HashSet\<E> 用到的方法：
- HashSet()：构造一个空散列集。
- HashSet(Collection\<? extends E> elements)：构造一个散列集，并将集合中的所有元素添加到这个散列集中。
- HashSet(int initialCapacity)：构造一个空的具有指定容量(桶数)的散列集。
- HashSet(int initialCapacity, float loadFactor)：构造一个具有指定容量和装填因子(一个介于 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集。

java.util.Object 用到的方法：
- int hashCode()：返回这个对象的散列码。散列码可以是任何整数，包括正数和负数。`equals` 和 `hashCode` 的定义必须兼容，即如果 `x.equals(y)` 为 `true`，`x.hashCode()` 必须等于 `y.hashCode()`。

### 树集
`TreeSet` 类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合(sorted collection)，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地敖着排序后的顺序呈现。

正如 `TreeSet` 类名所示，排序是用树结构完成的（当前实现使用的是红黑树(red-black tree)），每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比还是快很多。如果树中包含 n 个元素，查找新元素的正确位置平均需要 log<sub>2</sub>n 次比较。

要使用树集，必须能够比较元素。这些元素必须实现 `Comparable` 接口，或者构造集时必须提供一个 `Comparator`。

是否总是应该使用树集取代散列集？毕竟添加一个元素所话费的时间看上去并不是很长，而且元素是自动排序的。到底应该怎样做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。

java.util.TreeSet\<E> 用到的方法：
- TreeSet()
- TreeSet(Comparator\<? super E> comparator)：构造一个空树集。
- TreeSet(Collection\<? extends E> elements)
- TreeSet(SortedSet\<E> s)：构造一个树集，并增加一个集合或有序集中的所有元素。

java.util.SortedSet\<E> 用到的方法：
- Comparator\<? super E> comparator()：返回用于对元素进行排序的比较器。如果元素使用 `Comparable` 接口的 `compareTo` 方法进行比较则返回 `null`。
- E first()
- E last()：返回有序集中的最小元素或最大元素。

java.util.NavigableSet\<E> 用到的方法：
- E higher(E value)
- E lower(E value)：返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E ceiling(E value)
- E floor(E value)：返回大于等于 value 的最小元素或小于等于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E pollFirst()
- E pollLast()：删除并返回这个集中的最大元素或最小元素，这个集为空时返回 `null`。
- Iterator\<E> descendingIterator()：返回一个按照递减顺序遍历集中元素的迭代器。





## 映射


## 视图与包装器


## 算法


## 遗留的集合


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8