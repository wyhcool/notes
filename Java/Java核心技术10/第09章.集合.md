---
title: 集合
date: 2019-02-09 12:56:00
tags:
categories:
- Java
---

## Java 集合框架
### 将集合的接口与实现分离
Java 集合类库将接口(interface)与实现(implementation)分离。

以队列(queue)为例，队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象时，并按照“先进先出”的规则检索对象时就应该使用队列。
```java
public interface Queue<E> { // a simplified form of the interface in the standard library
    void add(E element);
    E remove();
    int size();
}
```
接口并没有说明队列是如何实现的，队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。

每一个实现都可以通过一个实现了 `Queue` 接口的类表示：
```java
public class CircularArrayQueue<E> implements Queue<E> { // not an actual library class
    private int head;
    private int tail;
    private E[] elements;

    CircularArrayQueue(int capacity) { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}

public class LinkedListQueue<E> implements Queue<E> { // not an actual library class
    private Link head;
    private Link tail;

    LinkedListQueue() { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}
```
当在程序中使用队列时，一旦构建了集合，就无需知道实际使用了哪种实现。因此，只有在构造集合对象时，使用具体的类才有意义。可以使用接口类型来保存集合引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
当使用 `LinkedListQueue` 是个更好的选择时，只需要对调用构造器的地方作出修改：
```java
Queue<Customer> expressLane = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

### Collection 接口
在 Java 类库中，集合类的基本接口是 `Collection` 接口，这个接口有两个基本方法：
```java
package java.util;

public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
    Iterator<E> iterator();
    ...
}
```
`add` 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 `true`，如果集合没有发生变化就返回 `false`。

`iterator` 方法用于返回一个实现了 `Iterator` 接口的对象，可以使用这个迭代器对象依次访问集合中的元素。

### 迭代器
`Iterator` 接口包含 4 个方法：
```java
package java.util;

public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
通过反复调用 `next` 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，`next` 方法将抛出一个 `NoSuchElementException`。因此，需要在调用 `next` 之前调用 `hasNext` 方法。如果迭代器对象还有可供访问的元素，这个方法就返回 `true`。

如果想要查看集合中的所有元素，就请求一个迭代器：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext) {
    String elem = iter.next();
    // do something with elem
}
```

或者使用 `for each` 循环可以更加简练地表示同样的循环操作，编译器将 `for each` 循环翻译为带有迭代器的循环：
```java
Collection<String> c = ...;
for (String elem : c) {
     // do something with elem
}
```
`for each` 循环可以与任何实现了 `Iterable` 接口的对象一起工作，这个接口设计为：
```java
package java.lang;

public interface Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
`Collection` 接口扩展了 `Iterable` 接口，因此，对于标准类库中的任何集合都可以使用 `for each` 循环。

在 Java SE 8 中，甚至可以不用写循环。可以调用 `forEachRemaining` 方法并提供一个 `lambda` 表达式，将对迭代器的每一个元素调用这个 `lambda` 表达式，直到再没有元素为止：
```java
iterator.forEachRemaing(elem -> do something with elem);
```
元素被访问的顺序取决于集合类型。如果对 `ArrayList` 进行迭代，迭代器将从索引 0 开始，每迭代一次，索引值加 1；然后，如果访问 `HashSet` 中的元素，每个元素将会按照某种随机的次序出现，虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

Java 迭代器查找一个元素的唯一方法是调用 `next`，而在执行查找操作的同时，迭代器的位置随之向前移动。因此，可以将 Java 迭代器认为是两个元素之间。当调用 `next`时，迭代器就会越过下一个元素，并返回刚刚越过的那个元素的引用。

注意⚠️：可以将 `Iterator.next` 与 `InputStream.read` 看作为等效的。从数据流中读取一个字节，就会自动地消耗掉这个字节。下一次调用 `read` 将会消耗并返回输入的下一个字节。

`Iterator` 接口的 `remove` 方法将会删除上次调用 `next` 方法时返回的元素。在决定删除元素之前，需要先查看元素。但是，要删除特定位置的元素，则仍然需要跳过该元素：
```java
Iterator<String> it = c.iterator();
it.next(); // skip over the first element
it.remove(); // now remove it
```
更重要的是，对 `next` 方法和 `remove` 方法的调用具有互相依赖性。如果调用 `remove` 之前没有调用 `next` 将是不合法的。如果这样做，将会抛出一个 `IllegalStateException` 异常。

### 泛型实用方法
由于 `Collection` 与 `Iterator` 都是泛型接口，可以编写操作任何集合类型的实用方法。Java 类库设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用，这样，类库的使用者就不必自己重新构建这些方法了。

事实上，`Collection` 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
...
```
当然，如果每个实现 `Collection` 接口的类都必须提供这么多常规方法，那将是一件麻烦事。为了使实现者的工作更加轻松，Java 库提供了一个 `AbstractCollection` 类，该类保留基本方法 `size` 和 `iterator` 的抽象，但根据它们来实现常规方法。例如：
```java
public abstract class AbstractCollection<E>
    implements Collection<E> 
{
    ...
    public abstract Iterator<E> iterator();

    public boolean contains(Object obj) {
        for (E element: this) { // call iterator()
            if (element.equals(obj)) {
                return true;
            }
        }
        return false;
    }
    ...
}
```
此时，一个具体的集合类可以扩展 `AbstractCollection`，现在只需要由具体的集合类提供 `iterator` 方法，而 `contains` 方法已经由 `AbstractCollection` 超类提供了，但是如果子类有更加有效的方式实现 `contains` 方法，也可以由子类提供。

java.util.Collection\<E> 用到的方法：
- Iterator\<E> iterator()：返回一个用于访问集合中每个元素的迭代器。
- int size()：返回当前存储在集合中的元素个数。
- boolean isEmpty()：如果集合中没有元素，返回 `true`。
- boolean contains(Object obj)：如果集合中包含一个与 obj 相等的对象，返回 `true`。
- boolean containsAll(Collection\<?> other)：如果集合中包含 other 集合中的所有元素，返回 `true`。
- boolean add(Object element)：将一个元素添加到集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean addAll(Collection\<? extends E> other)：将 other 集合中的所有元素添加到这个集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean remove(Object obj)：从这个集合中删除等于 obj 的对象，如果有匹配的对象被删除，返回 `true`。
- boolean removeAll(Collection\<?> other)：从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 `true`。
- default boolean removeIf(Predicate<? super E> filter)：从这个集合中删除 filter 返回 `true` 的所有元素。如果由于这个调用改变了集合，返回 `true`。
- void clear()：从这个集合中删除所有的元素。
- boolean retainAll(Collection\<?> other)：从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 `true`。
- Object\[] toArray()：返回这个集合的对象数组。
- \<T> T\[] toArray(T\[] arrayToFill)：返回这个集合的对象数组。如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null；否则，分配一个新数组，其成员类型与 arrayToFill 的成员类型相同，其长度等于集合的大小，并填充集合元素。

java.util.Iterator\<E> 用到的方法：
- boolean hasNext()：如果存在可访问的元素，返回 `true`。
- E next()：返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`。
- void remove()：删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`。

### 集合框架中的接口
Java 集合框架为不同类型的集合定义了大量接口：
```java
       Iterable
          |
     Collection               Map          Iterator     RandomAccess
__________|__________          |              |
|         |         |          |              |
List     Set     Queue     SortedMap      ListIterator
          |                    |
      SortedSet           NavigableMap
          | 
      NavigableSet
```
集合有两个基本接口：`Collection` 和 `Map`。

由于映射包含键 / 值对，要用 `put` 方法来插入：
```java
V put(K key, V value)
```
从映射中读取值则要使用 `get` 方法：
```java
V get(K key)
```

`List` 是一个有序集合(ordered collection)，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问(random access)，因为这样可以按照任意顺序访问元素。与之不同的是，使用迭代器访问时，必须顺序地访问元素。

`List` 接口定义了多个用于随机访问的方法：
```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

`ListIterator` 接口是 `Iterator` 的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素：
```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用 `List` 方法并提供一个整数索引来访问。与之不同的是，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。

为了避免对链表完成随机访问操作，Java SE 1.4 引入一个标记接口 `RandomAccess`，这个接口不包含任何方法，可以用它来测试一个特定的集合是否支持高效的随机访问：
```java
if (c instanceof RandomAccess) {
    // use random access algorithm
} else {
    // use sequential access algorithm
}
```

`Set` 接口等同于 `Collection` 接口，不过其方法的行为有更严谨的定义。集(Set)的 `add` 方法不允许添加重复的元素。要适当地定义集的 `equals` 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。`hashCode` 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

`SortedSet` 和 `SortedMap` 接口会提供用于排序的比较器对象，这两个接口定义了可到集合子集视图的方法。

Java SE 6 引入了接口 `NavigableSet` 和 `NavigableMap`，其中包含一些用于搜索和遍历有序集和映射的方法。`TreeSet` 和 `TreeMap` 类实现了这些接口。


## 具体的集合


## 映射


## 视图与包装器


## 算法


## 遗留的集合


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8