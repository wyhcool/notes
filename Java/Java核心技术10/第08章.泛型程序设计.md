---
title: 泛型程序设计
date: 2019-02-01 12:35:00
tags:
categories:
- Java
---

使用泛型机制编写的程序代码要比那些杂乱地使用 `Object` 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。

## 为什么要使用泛型程序设计
泛型程序设计(Generic programming)意味着编写的代码可以被很多不同类型的对象所重用。

### 类型参数的好处
在 Java 增加泛型类之前，泛型程序设计是用继承实现的，`ArrayList` 类只维护一个 `Object` 引用的数组：
```java
public class ArrayList { // before generic classes
    private Object[] elementData;
    ...
    public Object get(int i) { ... }
    public void add(Object o) { ... }
}
```
这个方法有两个问题。当获取一个值时必须进行强制类型转换。
```java
ArrayList files = new ArrayList();
...
String fileName = (String) files.get(i);
```
此时，这里没有错误检查。可以向数组列表中添加任何类的对象。
```java
files.add(new File("..."));
```
对于这个调用，编译和运行都不会出错。然而在其他地方，如果将 `get` 的结果强制类型转换为 `String` 类型，就会产生一个错误。

泛型提供了一个更好的解决方案：类型参数(type parameters)。`ArrayList` 类有一个类型参数用来指示元素的类型：
```java
ArrayList<String> files = new ArrayList<String>();
```

这使得代码具有更好的可读性，一看就知道这个数组列表中包含的是 `String` 对象。在 Java SE 7 及以后的版本中，构造函数中可以省略泛型类型，省略的类型可以从变量的类型推断得出：
```java
ArrayList<String> files = new ArrayList<>();
```

编译器可以很好地利用这个信息，当调用 `get` 时，不需要进行强制类型转换，编译器就知道返回值类型为 `String`，而不是 `Object`：
```java
String filename = files.get(0);
```

编译器还知道 `ArrayList<String>` 中 `add` 方法有一个类型为 `String` 的参数，这就被使用 `Object` 类型的参数安全一些，现在，编译器可以进行检查，避免插入错误类型的对象：
```java
files.add(new File("...")); // can only add String objects to an ArrayList<String>
```
以上语句是无法通过编译的，出现编译错误比类在运行时出现类的强制转换异常要好得多。

<font color="red">类型参数的魅力在于：使得程序具有更好的可读性和安全性。</font>

### 谁想成为泛型程序员
大多数 Java 程序员都使用 `ArrayList<String>` 这样的类型，就好像它们已经构建在语言之中，像 `String[]` 数组一样，当然，数组列表比数组要好一些，因为它可以自动扩展。

但是，实现一个泛型类并没有那么容易，一个泛型程序员的任务就是要预测出所用类的未来可能有的所有用途。


## 定义简单泛型类
一个泛型类(generic class)就是具有一个或多个类型变量的类。
```java
class Pair<T> {

    private T first;
    private T second;

    public Pair() {
        first = null;
        second = null;
    }

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() { return first; }
    public T getSecond() { return second; }

    public void setFirst(T newValue) {
        first = newValue;
    }

    public void setSecond(T newValue) {
        second = newValue;
    }
}
```
`Pair` 类引入了一个类型变量 `T`，用尖括号(`<>`)括起来，并放在类名的后面。泛型类可以有多个类型变量，例如，可以定义 `Pair` 类，其中第一个域和第二个域使用不同的类型：
```java
class Pair<T, U> { ... }
```
类定义中的类型变量指定方法的返回类型以及域和局部变量的类型：
```java
private T first; // use the type variable
```
注释：类型变量使用大写形式，且比较短。在 Java 库中，使用变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型，T（以及临近的字母 U 和 S）表示任意类型。

用具体的类型替换类型变量就可以实例化泛型类型：
```java
Pair<String>

// 可以将结果视为带有构造器的普通类：
Pair<String>()
Pair<String>(String, String)
// 和方法
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)
```
<font color="red">泛型类可看作是普通类的工厂</font>


## 泛型方法
可以定义一个带有类型参数的泛型方法：
```java
class ArrayAlg {
    public static <T> T getMiddle(T... a) {
        return a[a.length / 2];
    }
}
```
这个方法是在普通类中定义的，而不是在泛型类中定义的，类型变量放在修饰符的后面，返回类型的前面。

泛型方法阿可以定义在普通类中，也可以定义在泛型类中。

当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：
```java
String middle = ArrayAlg.<String>getMiddle("Mary", "had", "a", "little", "lamb");
```
大多数情况下，方法调用中可以省略 `<String>` 类型参数。编译器有足够的信息能够推断出所调用的方法，它使用 `words` 的类型(即 `String[]`)与泛型类型 `T[]` 进行匹配并推断出 `T` 一定是 `String`，也就是说，可以调用：
```java
String middle = ArrayAlg.getMiddle("Mary", "had", "a", "little", "lamb");
```
几乎在大多数情况下，对于泛型方法的类型引用没有问题。

偶尔，编译器也会提示错误，此时需要解释错误报告：
```java
double middle = ArrayAlg.getMiddle(3.14, 2019, 0);
```
解释上述代码有两种方法，而且都是合法的：编译器将会自动打包参数为一个 1 个 `Double` 和 2 个 `Integer` 对象，而后寻找这些类的共同超类型。事实上，找到 2 个这样的超类型：`Number` 和 `Comparable` 接口。在这种情况下，可以采取的补救措施是将所有的参数写为 `double` 值。

提示：如何知道编译器对一个泛型方法调用最终推断出哪种类型？可以有目的地引入一个错误，并研究所产生的错误消息：
```java
JButton middle3 = ArrayAlg.getMiddle("Hello", 0, null)
```
编译时得到一个错误，推断为 `Object`、`Serializable` 或 `Comparable`，不符合上限 `JButton` 或 `Object`：
```txt
Error:(24, 45) java: incompatible types: inferred type does not conform to upper bound(s)
    inferred: java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>>
    upper bound(s): javax.swing.JButton,java.lang.Object
```


## 类型变量的限定
有时，类或方法需要对类型变量加以约束。
```java
class ArrayAlg {

    public static <T> T min(T[] a) {
        if (a == null || a.length == 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a.length; i++) {
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        }
        return smallest;
    }
}
```
但是，这里有一个问题，变量 `smallest` 的类型为 T，这意味着它可以是任何一个类的对象，怎么才能确信 T 所属的类有 `CompareTo` 方法呢？

解决这个问题的方案是：将 T 限制为实现了 `Comparable` 接口的类。（ `Comparable` 接口是只包含一个方法 `CompareTo` 的标准接口。）可以通过对类型变量 T 设置限定(bound)来实现这一点：
```java
public static <T extends Comparable> T min(T[] a) {
    ...
}
```
实际上 `Comparable` 接口本身就是一个泛型类型。

现在，泛型的 `min` 方法只能被实现了 `Comparable` 接口的类的数组调用，比如 `String`、`LocalDate` 等。

注意⚠️：此处使用关键字 `extends` 而不是 `implements`，毕竟，`Comparable` 是一个接口。`<T extends BoundingType>` 表示 T 应该是绑定类型的子类型(subtype)，T 和绑定类型可以是类、也可以是接口。选择关键字 `extends` 的原因是更接近子类的概念。

一个类型变量或通配符可以有多个限定，限定类型用 `&` 分隔，而逗号用来分隔类型变量：
```java
T extends Comparable & Serializable
```
注意⚠️：在 Java 的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类，如果用一个类作为限定，它必须是限定列表中的第一个。


## 泛型代码和虚拟机
虚拟机没有泛型类型对象 —— 所有对象都属于普通类。

### 类型擦除
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除(erased)类型变量，并替换为限定类型(无限定的变量用 `Object`)。

`Pair<T>` 的原始类型如下所示：
```java
class Pair {

    private Object first;
    private Object second;

    public Pair() {
        first = null;
        second = null;
    }

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst() { return first; }
    public Object getSecond() { return second; }

    public void setFirst(Object newValue) {
        first = newValue;
    }

    public void setSecond(Object newValue) {
        second = newValue;
    }
}
```
原始类型用第一个限定的类型变量来替换，如果没有给定限定就用 `Object` 替换。

结果是一个普通的类，就好像泛型引入 Java 语言之前已经实现的那样。

在程序中可以包含不同类型的 `Pair`，例如，`Pair<String>` 或 `Pair<LocalDate>`。而擦除类型后就变成原始的 `Pair` 类型了。

假设声明：
```java
public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
}
```
原始类型 `Interval` 如下所示：
```java
public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
}
```
注意⚠️：如果切换限定 `class Interval<T extends Serializable & Comparable>` 会发生什么，原始类型用 `Serializable` 替换 T，并且编译器在必要时将强制类型转换插入 `Comparable`。为了提高效率，因此应将标记(tagging)接口（即没有方法的接口）放在限定列表的末尾。

### 翻译泛型表达式
当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换：
```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```
擦除 `getFirst` 的返回类型后将返回 `Object` 类型，编译器自动插入 `Employee` 的强制类型转换，也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
- 对原始方法 `Pair.getFirst` 的调用；
- 将返回的 `Object` 类型强制转换为 `Employee` 类型。

当存取一个泛型域时也要插入强制类型转换，假设 `Pair` 类中的 `first` 域和 `second` 域都是公有的，表达式：
```java
Employee buddy = buddies.first;
```
也会在结果字节码中插入强制类型转换。。

### 翻译泛型方法
类型擦除也会出现在泛型方法中。通常认为下述的泛型方法是一个完整的方法族：
```java
public static <T extends Comparable> T min(T[] a) 
```
而擦除类型之后，只剩下一个方法：
```java
public static Comparable min(Comparable[] a)
```
类型参数 T 已经被擦除了，只留下了限定类型 `Comparable`。

```java
class DateInterval extends Pair<LocalDate> {
    public void setSecond(LocalDate second) {
        if (second.compareTo(getFirst()) >= 0) {
            super.setSecond(second);
        }
    }
    ...
}
```
一个日期区间 `DateInterval` 是一对 `LocalDate` 对象，并且需要覆盖这个方法来确保第二个值永远不小于第一个值，这个类擦除后变成：
```java
class DateInterval extends Pair { // after erasure
    public void setSecond(LocalDate second) { ... }
    ...
}
```
注意，这里存在另一个从 `Pair` 继承的 `setSecond` 方法：
```java
    public void setSecond(Object second) { ... }
```
这显然是一个不同的方法，因为它有一个不同类型的参数。

考虑下面的语句：
```java
DateInterval interval = new DateInterval(...);
Pair<LocalDate> pair = interval; //ok, assignment to superclass
pair.setSecond(aDate);
```
这里希望对 `setSecond` 的调用具有多态性，并调用最合适的那个方法。由于 `pair` 引用了 `DateInterval` 对象，所以应该调用 `DateInterval.setSecond`。问题在于类型擦除与多态发生了冲突，要解决这个问题，就需要编译器在 `DateInterval` 类中生成一个桥方法(bridge method)：
```java
public void setSecond(Object second) { setSecond((Date) second); }
```
跟踪 `pair.setSecond(aDate)` 语句的执行：变量 `pair` 已经声明为类型 `Pair<LocalDate>`，并且这个类型只有一个简单方法 `setSecond(Object)`。虚拟机用 `pair` 引用的对象调用该方法，这个对象是 `DateInterval` 类型的，因而将会调用 `DateInterval.setSecond(Object)`，这个方法即就是合成的桥方法，它调用 `DateInterval.setSecond(Date)`，实现期望的效果。

假设 `DateInterval` 方法也覆盖了 `getSecond` 方法：
```java
class DateInterval extends Pair<LocalDate> {
    public LocalDate getSecond() {
        return (Date) super.getSecond().clone();
    }
    ...
}
```
在 `DateInterval` 类中，有两个 `getSecond` 方法：
```java
LocalDate getSecond() // defined in DateInterval
Object getSecond() // overrides the method defined in Pair to call the first method
```
注意：不能像上面这样编写 Java 代码，因为具有相同参数类型的两个同名方法是不合法的。但是在虚拟机中，用参数类型和返回类型确定一个方法，因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确处理这一情况。

桥方法不仅用于泛型类型，还有，在一个方法覆盖另一个方法时可以指定一个更严格的返回类型：
```java
public class Employee implements Cloneable {
    public Employee clone() throws CloneNotSupportedException {
        ...
    }
}
```
`Object.clone` 和 `Employee.clone` 方法被说成是具有协变的返回类型(covariant return types)。

实际上，`Employee` 类有两个克隆方法：
```java
Employee clone() // defined above
Object clone() // synthesized bridge method, overrides Object.clone
```
synthesized \[ˈsɪnθəsaɪzd] adj.合成的;

总之，关于 Java 泛型转换的事实：
- 虚拟机中没有泛型，只有普通的类和方法；
- 所有的类型参数都用它们的限定类型替换；
- 桥方法被合成来保持多态；
- 为保持类型安全性，必要时插入强制类型转换。

### 调用遗留代码
设计 Java 泛型类型时，主要目标是允许泛型代码和遗留代码之间能够互操作。

比如想要设定一个 `JSlider` 标签，可以使用方法：
```java
void setLableTable(Dictionary table)
```
在这里，`Dictionary` 是一个原始类型，因为实现 `JSlider` 类时 Java 中还不存在泛型。不过填充字典时，要使用泛型类型：
```java
Dictionary<Integer, Component> labelTable = new Hashtable<>();
labelTable.put(0, new JLabel(new ImageIcon("nine.gif")));
labelTable.put(10, new JLabel(new ImageIcon("ten.gif")));
```
然后将 `Dictionary<Integer, Component>` 对象传递给 `setLabelTable`：
```java
slider.setLabelTable(labelTable);
```
毕竟编译器无法确定 `setLabelTable` 可能会对 `Dictionary` 对象做什么操作。

相反地，由一个遗留的类得到一个原始类型的对象，可以将它赋给一个参数化的类型变量，这样做会有一个警告：
```java
Dictionary<Integer, Component> labelTable = slider.getLabelTable();
```

可以利用注解(annotation)使警告消失，注解必须放在生成这个警告的代码所在的方法之前：
```java
@SuppressWarning("unchecked")
Dictionary<Integer, Component> labelTable = slider.getLabelTable();
```
或者，可以标注整个方法，这个注解会关闭对方法中的所有代码的检查：
```java
@SuppressWarning("unchecked")
public void configureSlider() { ... }
```


## 约束与局限性

## 泛型类型的继承规则

## 通配符类型

## 反射和泛型


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


