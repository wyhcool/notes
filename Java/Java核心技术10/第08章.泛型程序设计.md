---
title: 泛型程序设计
date: 2019-02-01 12:35:00
tags:
categories:
- Java
---

使用泛型机制编写的程序代码要比那些杂乱地使用 `Object` 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。

## 为什么要使用泛型程序设计
泛型程序设计(Generic programming)意味着编写的代码可以被很多不同类型的对象所重用。

### 类型参数的好处
在 Java 增加泛型类之前，泛型程序设计是用继承实现的，`ArrayList` 类只维护一个 `Object` 引用的数组：
```java
public class ArrayList { // before generic classes
    private Object[] elementData;
    ...
    public Object get(int i) { ... }
    public void add(Object o) { ... }
}
```
这个方法有两个问题。当获取一个值时必须进行强制类型转换。
```java
ArrayList files = new ArrayList();
...
String fileName = (String) files.get(i);
```
此时，这里没有错误检查。可以向数组列表中添加任何类的对象。
```java
files.add(new File("..."));
```
对于这个调用，编译和运行都不会出错。然而在其他地方，如果将 `get` 的结果强制类型转换为 `String` 类型，就会产生一个错误。

泛型提供了一个更好的解决方案：类型参数(type parameters)。`ArrayList` 类有一个类型参数用来指示元素的类型：
```java
ArrayList<String> files = new ArrayList<String>();
```

这使得代码具有更好的可读性，一看就知道这个数组列表中包含的是 `String` 对象。在 Java SE 7 及以后的版本中，构造函数中可以省略泛型类型，省略的类型可以从变量的类型推断得出：
```java
ArrayList<String> files = new ArrayList<>();
```

编译器可以很好地利用这个信息，当调用 `get` 时，不需要进行强制类型转换，编译器就知道返回值类型为 `String`，而不是 `Object`：
```java
String filename = files.get(0);
```

编译器还知道 `ArrayList<String>` 中 `add` 方法有一个类型为 `String` 的参数，这就被使用 `Object` 类型的参数安全一些，现在，编译器可以进行检查，避免插入错误类型的对象：
```java
files.add(new File("...")); // can only add String objects to an ArrayList<String>
```
以上语句是无法通过编译的，出现编译错误比类在运行时出现类的强制转换异常要好得多。

<font color="red">类型参数的魅力在于：使得程序具有更好的可读性和安全性。</font>

### 谁想成为泛型程序员
大多数 Java 程序员都使用 `ArrayList<String>` 这样的类型，就好像它们已经构建在语言之中，像 `String[]` 数组一样，当然，数组列表比数组要好一些，因为它可以自动扩展。

但是，实现一个泛型类并没有那么容易，一个泛型程序员的任务就是要预测出所用类的未来可能有的所有用途。


## 定义简单泛型类
一个泛型类(generic class)就是具有一个或多个类型变量的类。
```java
class Pair<T> {

    private T first;
    private T second;

    public Pair() {
        first = null;
        second = null;
    }

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() { return first; }
    public T getSecond() { return second; }

    public void setFirst(T newValue) {
        first = newValue;
    }

    public void setSecond(T newValue) {
        second = newValue;
    }
}
```
`Pair` 类引入了一个类型变量 `T`，用尖括号(`<>`)括起来，并放在类名的后面。泛型类可以有多个类型变量，例如，可以定义 `Pair` 类，其中第一个域和第二个域使用不同的类型：
```java
class Pair<T, U> { ... }
```
类定义中的类型变量指定方法的返回类型以及域和局部变量的类型：
```java
private T first; // use the type variable
```
注释：类型变量使用大写形式，且比较短。在 Java 库中，使用变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型，T（以及临近的字母 U 和 S）表示任意类型。

用具体的类型替换类型变量就可以实例化泛型类型：
```java
Pair<String>

// 可以将结果视为带有构造器的普通类：
Pair<String>()
Pair<String>(String, String)
// 和方法
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)
```
<font color="red">泛型类可看作是普通类的工厂</font>


## 泛型方法
可以定义一个带有类型参数的泛型方法：
```java
class ArrayAlg {
    public static <T> T getMiddle(T... a) {
        return a[a.length / 2];
    }
}
```
这个方法是在普通类中定义的，而不是在泛型类中定义的，类型变量放在修饰符的后面，返回类型的前面。

泛型方法阿可以定义在普通类中，也可以定义在泛型类中。

当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：
```java
String middle = ArrayAlg.<String>getMiddle("Mary", "had", "a", "little", "lamb");
```
大多数情况下，方法调用中可以省略 `<String>` 类型参数。编译器有足够的信息能够推断出所调用的方法，它使用 `words` 的类型(即 `String[]`)与泛型类型 `T[]` 进行匹配并推断出 `T` 一定是 `String`，也就是说，可以调用：
```java
String middle = ArrayAlg.getMiddle("Mary", "had", "a", "little", "lamb");
```
几乎在大多数情况下，对于泛型方法的类型引用没有问题。

偶尔，编译器也会提示错误，此时需要解释错误报告：
```java
double middle = ArrayAlg.getMiddle(3.14, 2019, 0);
```
解释上述代码有两种方法，而且都是合法的：编译器将会自动打包参数为一个 1 个 `Double` 和 2 个 `Integer` 对象，而后寻找这些类的共同超类型。事实上，找到 2 个这样的超类型：`Number` 和 `Comparable` 接口。在这种情况下，可以采取的补救措施是将所有的参数写为 `double` 值。

提示：如何知道编译器对一个泛型方法调用最终推断出哪种类型？可以有目的地引入一个错误，并研究所产生的错误消息：
```java
JButton middle3 = ArrayAlg.getMiddle("Hello", 0, null)
```
编译时得到一个错误，推断为 `Object`、`Serializable` 或 `Comparable`，不符合上限 `JButton` 或 `Object`：
```txt
Error:(24, 45) java: incompatible types: inferred type does not conform to upper bound(s)
    inferred: java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends java.lang.Object&java.io.Serializable&java.lang.Comparable<?>>
    upper bound(s): javax.swing.JButton,java.lang.Object
```


## 类型变量的限定
有时，类或方法需要对类型变量加以约束。
```java
class ArrayAlg {

    public static <T> T min(T[] a) {
        if (a == null || a.length == 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a.length; i++) {
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        }
        return smallest;
    }
}
```
但是，这里有一个问题，变量 `smallest` 的类型为 T，这意味着它可以是任何一个类的对象，怎么才能确信 T 所属的类有 `CompareTo` 方法呢？

解决这个问题的方案是：将 T 限制为实现了 `Comparable` 接口的类。（ `Comparable` 接口是只包含一个方法 `CompareTo` 的标准接口。）可以通过对类型变量 T 设置限定(bound)来实现这一点：
```java
public static <T extends Comparable> T min(T[] a) {
    ...
}
```
实际上 `Comparable` 接口本身就是一个泛型类型。

现在，泛型的 `min` 方法只能被实现了 `Comparable` 接口的类的数组调用，比如 `String`、`LocalDate` 等。

注意⚠️：此处使用关键字 `extends` 而不是 `implements`，毕竟，`Comparable` 是一个接口。`<T extends BoundingType>` 表示 T 应该是绑定类型的子类型(subtype)，T 和绑定类型可以是类、也可以是接口。选择关键字 `extends` 的原因是更接近子类的概念。

一个类型变量或通配符可以有多个限定，限定类型用 `&` 分隔，而逗号用来分隔类型变量：
```java
T extends Comparable & Serializable
```
注意⚠️：在 Java 的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类，如果用一个类作为限定，它必须是限定列表中的第一个。


## 泛型代码和虚拟机

## 约束与局限性

## 泛型类型的继承规则

## 通配符类型

## 反射和泛型


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


