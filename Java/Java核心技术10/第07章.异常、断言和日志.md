---
title: 异常、断言和日志
date: 2019-01-28 14:19:00
tags:
categories:
- Java
---

对于异常情况，例如，可能造成程序崩溃的错误输入，Java 使用一种称为异常处理(exception handling)的错误捕获机制处理。

在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此可以将这些检测删掉，并在其他检测需要时将它们粘贴回来，Java 使用断言来有选择地启用检测。

当程序出现错误时，并不总是能够与用户或终端进行沟通，此时，可以通过标准 Java 日志框架来记录下出现的问题，以备之后进行分析。

## 处理错误
异常处理的任务是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况，必须研究程序中可能出现的错误和问题以及哪类问题需要关注。
- 用户输入错误
- 设备错误，比如打印机被关掉了、打印机在打印过程中没纸了
- 物理限制，比如磁盘满了
- 代码错误

在 Java 中，如果某个方法不能采用正常的途径完成它的任务，就可以通过另外一个途径退出方法。在这种情况下，方法并不返回任何值，而是抛出(throw)一个封装了错误信息的对象。需要注意的是，这个方法会立刻退出，并不返回任何值。此外，调用这个方法的代码也将无法继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler)。

### 异常分类
在 Java 中，异常对象都是派生于 `Throwable` 类的一个实例。
```shell
# Java  异常层次结构

          Throwable
    _________||_________
  _|_                  _|_
 Error              Exception
                ________|________
              _|_               _|_
        IOException(...)   Runtime Exception
```
注意⚠️：所有的异常都是由 `Throwable` 继承而来，但是在下一层理解分解为两个分支： `Error` 和 `Exception`。

`Error` 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了要通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。

在设计 Java 程序时，需要关注 `Exception` 层次结构。这个层次结构又分解为两个分支：一个分支派生于 `RuntimeException`，另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于 `RuntimeException`；而程序本身没有问题，但由于像 `I/O` 错误这类问题导致的异常属于其他异常。

派生于 `RuntimeException` 的异常包含下面几种情况：
- 错误的类型转换；
- 数组访问越界；
- 访问 `null` 指针。

不是派生于 `RuntimeException` 的异常包括：
- 试图在文件尾部后面继续读取数据；
- 试图打开一个不存在的文件；
- 试图根据给定的字符串查找 `Class` 对象，而这个字符串表示的类不存在。

<font color="red">如果出现 `RuntimeException` 异常，那一定是你的问题。</font>

应该通过检测数组下标是否越界来避免 `ArrayIndexOutOfBoundsException` 异常；应该通过在使用变量之前检测是否为 `null` 来杜绝 `NullPointerException` 异常的发生。

Java 语言规范将派生于 `Error` 类或 `RuntimeException` 类的所有异常称为非受查异常(unchecked)，所有其他的异常称为受查异常(checked)。

<strong>编译器将核查是否为所有的受查异常提供了异常处理器。</strong>

注意⚠️：`RuntimeException` 这个名字很容易让人混淆，实际上现在讨论的所有错误都发生在运行时。

C++ 中有两个基本的异常类：一个是 `logic_error` 类，它相当于 Java 中的 `RuntimeException`，表示程序中的逻辑错误；另一个是 `runtime_error` 类，它相当于 Java 中的 `非 RuntimeException` 异常，是所有由于不可预测的原因所引发的异常的基类。

### 声明受查异常
如果遇到了无法处理的情况，那么 Java 的方法可以抛出一个异常。

一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。

试图处理文件信息的代码就需要通知编译器可能会抛出 `IOException` 类的异常。

方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。
```java
public FileInputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null);
}
```
这个声明表示这个构造器将根据给定的 `name` 参数产生一个 `FileInputStream` 对象，但也有可能抛出一个 `FileNotFoundException` 异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的 `FileInputStream` 对象，而是抛出一个 `FileNotFoundException` 异常类对象，运行时系统就会开始搜索异常处理器，以便知道如何处理 `FileNotFoundException` 对象。

在编写方法时，不必将所有可能抛出的异常都进行说明。需要记住在遇到下面 4 种情况时应该抛出异常：
- 调用一个抛出受查异常的方法，比如 `FileInputStream` 构造器；
- 程序运行过程中发现错误，并且利用 `throw` 语句抛出一个受查异常；
- 程序出现错误，例如 `a[-1]=0` 会抛出一个 `ArrayIndexOutOfBoundsException` 这样的非受查异常；
- Java 虚拟机和运行库出现的内部错误。

如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常，因为任何一个抛出异常的方法都有可能是一个死亡陷阱，如果没有处理器捕获这个异常，当前执行的线程就会结束。

对于那些可能被他人使用的方法，应该根据异常规范(exception specification)，在方法的首部声明这个方法可能抛出的异常。

如果一个方法可能抛出多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。

但是，不需要声明 Java 的内部错误，即从 `Error` 继承的错误，任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力。

同样，也不应该声明从 `RuntimeException` 继承的那些非受查异常。因为这些运行时错误完全在我们的控制之下，如果特别关注数组下标引发的错误，就应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性上。

总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。

如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。

警告⚠️：如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。

特别需要说明的是🌿：如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。

如果类中的一个方法声明将会抛出一个异常，而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常，或者这个类任意一个子类的异常。

### 如何抛出异常
首先要决定抛出什么类型的异常，即找到一个合适的异常类，其次是创建这个类的对象，最后将这个对象抛出。
```java
String readData(Scanner in) throws EOFException {
    ...
    while (...) {
        if (!in.hasNext()) {

            if (n < len) {
                String gripe = "Content-length: " + len + ", Received: " + n;
                throw new EOFException(gripe);
            }
        }
    }
    return s;
}
```
一旦方法抛出了异常，这个方法就可能返回到调用者。也就是说，不必为返回的默认值或错误代码担忧。

### 创建异常类
创建自己的异常类，只需要定义一个派生于 `Exception` 的类，或者派生于 `Exception` 子类的类。

习惯上，所有派生的异常类都包含两个构造器，一个是默认的构造器，另一个是带有详细描述信息的构造器。
```java
class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String gripe) {
        super(gripe);
    }
}
```

java.lang.Throwable 类用到的方法：
- Throwable()：构造一个新的 `Throwable` 对象，这个对象没有详细的描述信息。
- Throwable(String message)：构造一个新的 `Throwable` 对象，这个对象带有特定的详细描述信息。
- String getMessage()：获取 `Throwable` 对象的详细描述信息。


## 捕获异常
### 捕获异常
如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。

对于图形界面程序(applet 和应用程序)，在捕获异常之后，也会打印出堆栈的信息，但程序将返回到用户界面的处理循环中（在调试 GUI 程序时，最好保证控制台窗口可见，并且没有被最小化）。
```java
try {
    //code
    //more code
} catch (ExceptionType e) {
    //handler for this type
}
```
如果在 `try` 语句块中的任何代码抛出了一个在 `catch` 子句中说明的异常类，那么：
1. 程序将跳过 `try` 语句块的其余代码；
2. 程序将执行 `catch` 子句中的处理器代码。

如果在 `try` 语句块中的代码没有抛出任何异常，那么程序将跳过 `catch` 子句。

如果方法中的任何代码抛出了一个在 `catch` 子句中没有声明的异常类型，那么这个方法就会立刻退出。

读取数据的程序代码：
```java
public void read(String filename) {
    try {
        InputStream in = new FileInputStream(filename);
        int b;
        while ((b = in.read()) != -1) {
            //process input
        }
    } catch (IOException ex) {
        ex.printStackTrace();
    }
}
```
通常，最好的选择是什么也不做，而是将异常传递给调用者。
```java
public void read(String filename) throws IOException {
    InputStream in = new FileInputStream(filename);
    int b;
    while ((b = in.read()) != -1) {
        //process input
    }
}
```
编译器严格地执行 `throws` 说明符，如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。

哪个方法更好呢？<strong>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</strong>

如果想传递一个异常，就必须在方法的首部添加一个 `throws` 说明符，以便告知调用者这个方法可能抛出异常。

阅读 Java API 文档，以便知道每个方法可能会抛出哪些异常，然后再决定是自己处理，还是添加到 `throws` 列表中。<strong>对于后一种情况，也不必犹豫，将异常直接交给能够胜任的处理器进行处理要比压制对它的处理更好。</strong>

记住，这个规则有一个例外：如果编写一个覆盖超类的方法，而这个超类方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个受查异常。不允许在子类的 `throws` 说明符中出现超过超类方法所列出的异常类范围。

### 捕获多个异常
在一个 `try` 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。
```java
try {
    //code that might throw exceptions
} catch (FileNotFoundException ex) {
    //emergency action for missing files
} catch (UnknownHostException ex) {
    //emergency action for unknown hosts
} catch (IOException ex) {
    //emergency action for all other I/O problems
}
```
异常对象可能包含与异常本身有关的信息，使用 `e.getMessage()` 得到详细的错误信息，使用 `e.getClass().getName()` 得到异常对象的实际类型。

在 Java SE 7 中，同一个 `catch` 子句可以捕获多个异常类型：
```java
try {
    //code that might throw exceptions
} catch (FileNotFoundException | UnknownHostException ex) {
    //emergency action for missing files and unknown hosts
} catch (IOException ex) {
    //emergency action for all other I/O problems
}
```
只有当捕获当异常类型彼此之间不存在子类关系时才需要这个特性。

捕获多个异常时，异常变量隐含为 `final` 变量。

### 再次抛出异常与异常链
在 `catch` 子句中可以抛出一个异常，这样做的目的是改变异常的类型。
```java
try {
    //access the database
} catch (SQLException ex) {
    throw new ServletException("database error: " + ex.getMessage());
}
```
不过，可以有一种更好的处理方法，并且将原始异常设置为新异常的原因：
```java
try {
    //access the database
} catch (SQLException ex) {
    Throwable se = new ServletException("database error");
    se.initCause(ex);
    throw se;
}
```
当捕获到异常时，可以使用如下语句重新得到原始异常：
```java
Throwable e = se.getCause();
```
强烈建议使用这种包装技术，这样可以让用户抛出系统中的高级异常，而不会丢失原始异常的细节。

如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用。可以捕获这个受查异常，并将它包装成一个运行时异常。

### finally 子句
当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。

如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常，但是这种解决方案导致需要在两个地方清除所分配的资源，一个在正常的代码中，另一个在异常代码中。

Java 有一种更好的解决方案，使用 `finally` 子句。不管是否有异常被捕获，`finally` 子句中的代码都被执行。
```java
InputStream in = new FileInputStream(...);
try {
    //1
    //code that might throw exceptions
    //2
} catch (IOException ex) {
    //3
    //show error message
    //4
} finally {
    //5
    in.close();
}
//6
```
有 3 中情况会执行 `finally` 子句：
1) 代码没有抛出异常。这种情况下，程序首先执行 `try` 语句块中的所有代码，然后执行 `finally` 子句中的代码，随后执行 `try` 语句块后的第一条语句，执行路径为 1、2、5、6。
2) 抛出一个在 `catch` 子句中捕获的异常。这种情况下，程序将执行 `try` 语句块中的代码，直到发生异常为止。此时，将跳过 `try` 语句块中的剩余代码，转去执行与该异常匹配的 `catch` 子句中的代码，最后执行 `finally` 子句中的代码。
  2.1) 如果 `catch` 子句没有抛出异常，程序将执行 `try` 语句块后的第一条语句，执行路径为 1、3、4、5、6。
  2.2) 如果 `catch` 子句抛出了一个异常，异常将被抛回给这个方法的调用者，执行路径为 1、3、5。
3) 代码抛出了一个异常，但这个异常不是由 `catch` 子句捕获的。在这种情况，程序将执行 `try` 语句块中的代码，直到发生异常为止。此时，将跳过 `try` 语句块中的剩余代码，然后执行 `finally` 子句中的语句，并将异常将被抛回给这个方法的调用者，执行路径为 1、5。

`try` 语句可以只有 `finally` 子句，而没有 `catch` 子句：
```java
InputStream in = new FileInputStream(...);
try {
    //code that might throw exceptions
} finally {
    in.close();
}
```
无论在 `try` 语句块中是否遇到异常，`finally` 子句都会被执行。如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 `catch` 子句捕获。

强烈建议解耦合 `try/catch` 和 `try/finally` 语句块，以提高代码的清晰度：
```java
InputStream in = new FileInputStream(...);
try {
    try {
        //code that might throw exceptions
    } finally {
        in.close();
    }
} catch (IOException e) {
    //show error message
}
```
内层的 `try` 语句块只有一个职责，就是确保关闭输入流。外层的 `try` 语句块也只有一个职责，就是确保报告出现的错误，这种设计方式不仅清楚，而且还具有一个功能，就是将会报告 `finally` 子句中出现的错误。

警告❌：当 `finally` 子句中包含 `return` 语句时，将会出现一种意想不到的结果。假设利用 `return` 语句从 `try` 语句块中退出，在方法返回前，`finally` 子句的内容将被执行。如果 `finally` 子句中也有一个 `return` 语句，这个返回值将会覆盖原始的返回值。
```java
public static int f(int n) {
    try {
        int r = n * n;
        return r;
    } finally {
        if (n == 2) return 0;
    }
}

f(2); // 0
```
有时候， `finally` 子句也会带来麻烦，例如，清理资源的方法也可能抛出异常。
```java
InputStream in = new FileInputStream(...);
try {
    //code that might throw exceptions
} finally {
    in.close();
}
```
现在假设 `try` 语句块中的代码抛出一些 `非 IOException` 的异常，这些异常只有这个方法的调用者才能给予处理。执行 `finally` 语句块，并调用 `close` 方法，而 `close` 方法本身也有可能抛出 `IOException` 异常。当出现这种情况时，原始的异常将会丢失，转而抛出 `close` 方法的异常。

这会有问题，因为第一个异常很可能更有意思，需要做适当的处理，重新抛出原来的异常，代码会变得极其繁琐：
```java
InputStream in = new FileInputStream(...);
Exception ex = null;
try {
    try {
         //code that might throw exceptions
    } catch (Exception e) {
        ex = e;
        throw ex;
    }
} finally {
    try {
        in.close();
    } catch (Exception e) {
        if (ex == null) throw e;
    }
}
```

### 带资源的 try 语句
对于以下代码模式：
```java
//open a resource
try {
    //work with the resource
} finally {
    //close the resource
}
```
假设资源属于一个实现了 `AutoCloseable` 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。

`AutoCloseable` 接口有一个方法：
```java
package java.lang;

public interface AutoCloseable {
    void close() throws Exception;
}
```
另外有一个 `Closeable` 接口：
```java
package java.io;

public interface Closeable extends AutoCloseable {
    public void close() throws IOException;
}
```
带资源的 `try` 语句(try-with-resources)的最简形式为：
```java
try (Resource res = ...) {
    //work with res
}
```
`try` 块退出时，会自动调用 `res.close()`。

读取一个文件中的所有单词：
```java
try (Scanner in = new Scanner(new FileInputStream("/usr/share/dict/wrods"), "UTF-8");
    PrintWriter out = new PrintWriter("out.txt")) {
    
    while (in.hasNext()) {
        out.println(in.next().toUpperCase());
    }
}
```
这个块正常退出时，或者存在一个异常时，都会调用 `in.close()` 方法，就好像使用了 `finally` 块一样。

还可以指定多个资源。不论这个块如何退出，`in` 和 `out` 都会关闭。

带资源的 `try` 语句能够很好的处理这种情况：如果 `try` 块抛出一个异常，而且 `close` 方法也抛出一个异常。

原来的异常会重新抛出，而 `close` 方法抛出的异常会被抑制，这些异常将自动捕获，并由 `addSuppressed` 方法增加到原来的异常。可以调用 `getSuppressed` 方法得到从 `close` 方法抛出的被抑制的异常列表。

### 分析堆栈轨迹元素
堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，这个列表就会显示出来。

可以调用 `Throwable` 类的 `printStackTrace` 方法访问堆栈轨迹的文本描述信息：
```java
Throwable t = new Throwable();
StringWriter out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();
System.out.println(description);
```
一种更灵活的方法是使用 `getStackTrace` 方法，它会得到 `StackTraceElement` 对象的一个数组：
```java
Throwable t = new Throwable();
StackTraceElement[] frames = t.getStackTrace();
for (StackTraceElement frame : frames) {
    //analyze frame
}
```
`StackTraceElement` 类含有能够获得文件名和当前执行的代码行号的方法，同时，还含有能够获得类名和方法名的方法。`toString` 方法将产生一个格式化的字符串，其中包含所获得的信息。

静态的 `Thread.getAllStackTrace` 方法，它可以产生所有线程的堆栈轨迹：
```java
Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
for (Thread t : map.keySet()) {
    StackTraceElement[] frames = map.get(t);
    //analyze frames
}
```

java.lang.Throwable 类用到的方法：
- Throwable(Throwable cause)
- Throwable(String message, Throwable cause)：用给定的原因构造一个 `Throwable` 对象。
- Throwable initCause(Throwable cause)：将这个对象设置为原因，返回 `this` 引用。如果这个对象已经被设置为原因，则抛出一个异常。 
- Throwable getCause()：获得设置为这个对象的原因的异常对象。如果没有设置原因，则返回 `null`。
- StackTraceElement[] getStackTrace()：获得构造这个对象时调用堆栈的跟踪。
- void addSuppressed(Throwable t)：为这个异常增加一个抑制异常。这出现在带资源的 `try` 语句中，其中 t 是 `close` 方法抛出的一个异常。
- Throwable[] getSuppressed()：得到这个异常的所有抑制异常。这是带资源的 `try` 语句中 `close` 方法抛出的异常。


java.lang.Exception 类用到的方法：
- Exception(Throwable cause)
- Exception(String message, Throwable cause)：用给定的原因构造一个异常对象。

java.lang.RuntimeException 类用到的方法：
- RuntimeException(Throwable cause)
- RuntimeException(String message, Throwable cause)：用给定的原因构造一个 `RuntimeException` 对象。

java.lang.StackTraceElement 类用到的方法：
- String getFileName()：返回这个元素运行时对应的源文件。如果这个信息不存在，则返回 `null`。
- int getLineNumber()：返回这个元素运行时对应的源文件行数。如果这个信息不存在，则返回 `-1`。
- String getClassName()：返回这个元素运行时对应的类的完全限定名。
- String getMethodName()：返回这个元素运行时对应的方法名。构造器名是 `<init>`；静态初始化器名是 `<clinit>`。这里无法区分同名的重载方法。
- boolean isNativeMethod()：如果这个元素运行时在一个本地方法中，则返回 `true`。
- String toString()：如果存在的话，返回一个包含类名、方法名、文件名和行数的格式化字符串。


## 使用异常机制的技巧


## 使用断言


## 记录日志


## 调试技巧


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


