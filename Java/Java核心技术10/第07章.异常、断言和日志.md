---
title: 异常、断言和日志
date: 2019-01-28 14:19:00
tags:
categories:
- Java
---

对于异常情况，例如，可能造成程序崩溃的错误输入，Java 使用一种称为异常处理(exception handling)的错误捕获机制处理。

在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此可以将这些检测删掉，并在其他检测需要时将它们粘贴回来，Java 使用断言来有选择地启用检测。

当程序出现错误时，并不总是能够与用户或终端进行沟通，此时，可以通过标准 Java 日志框架来记录下出现的问题，以备之后进行分析。

## 处理错误
异常处理的任务是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况，必须研究程序中可能出现的错误和问题以及哪类问题需要关注。
- 用户输入错误
- 设备错误，比如打印机被关掉了、打印机在打印过程中没纸了
- 物理限制，比如磁盘满了
- 代码错误

在 Java 中，如果某个方法不能采用正常的途径完成它的任务，就可以通过另外一个途径退出方法。在这种情况下，方法并不返回任何值，而是抛出(throw)一个封装了错误信息的对象。需要注意的是，这个方法会立刻退出，并不返回任何值。此外，调用这个方法的代码也将无法继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler)。

### 异常分类
在 Java 中，异常对象都是派生于 `Throwable` 类的一个实例。
```shell
# Java  异常层次结构

          Throwable
    _________||_________
  _|_                  _|_
 Error              Exception
                ________|________
              _|_               _|_
        IOException(...)   Runtime Exception
```
注意⚠️：所有的异常都是由 `Throwable` 继承而来，但是在下一层理解分解为两个分支： `Error` 和 `Exception`。

`Error` 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了要通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。

在设计 Java 程序时，需要关注 `Exception` 层次结构。这个层次结构又分解为两个分支：一个分支派生于 `RuntimeException`，另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于 `RuntimeException`；而程序本身没有问题，但由于像 `I/O` 错误这类问题导致的异常属于其他异常。

派生于 `RuntimeException` 的异常包含下面几种情况：
- 错误的类型转换；
- 数组访问越界；
- 访问 `null` 指针。

不是派生于 `RuntimeException` 的异常包括：
- 试图在文件尾部后面继续读取数据；
- 试图打开一个不存在的文件；
- 试图根据给定的字符串查找 `Class` 对象，而这个字符串表示的类不存在。

<font color="red">如果出现 `RuntimeException` 异常，那一定是你的问题。</font>

应该通过检测数组下标是否越界来避免 `ArrayIndexOutOfBoundsException` 异常；应该通过在使用变量之前检测是否为 `null` 来杜绝 `NullPointerException` 异常的发生。

Java 语言规范将派生于 `Error` 类或 `RuntimeException` 类的所有异常称为非受查异常(unchecked)，所有其他的异常称为受查异常(checked)。

<strong>编译器将核查是否为所有的受查异常提供了异常处理器。</strong>

注意⚠️：`RuntimeException` 这个名字很容易让人混淆，实际上现在讨论的所有错误都发生在运行时。

C++ 中有两个基本的异常类：一个是 `logic_error` 类，它相当于 Java 中的 `RuntimeException`，表示程序中的逻辑错误；另一个是 `runtime_error` 类，它相当于 Java 中的 `非 RuntimeException` 异常，是所有由于不可预测的原因所引发的异常的基类。

### 声明受查异常
如果遇到了无法处理的情况，那么 Java 的方法可以抛出一个异常。

一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。

试图处理文件信息的代码就需要通知编译器可能会抛出 `IOException` 类的异常。

方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。
```java
public FileInputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null);
}
```
这个声明表示这个构造器将根据给定的 `name` 参数产生一个 `FileInputStream` 对象，但也有可能抛出一个 `FileNotFoundException` 异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的 `FileInputStream` 对象，而是抛出一个 `FileNotFoundException` 异常类对象，运行时系统就会开始搜索异常处理器，以便知道如何处理 `FileNotFoundException` 对象。

在编写方法时，不必将所有可能抛出的异常都进行说明。需要记住在遇到下面 4 种情况时应该抛出异常：
- 调用一个抛出受查异常的方法，比如 `FileInputStream` 构造器；
- 程序运行过程中发现错误，并且利用 `throw` 语句抛出一个受查异常；
- 程序出现错误，例如 `a[-1]=0` 会抛出一个 `ArrayIndexOutOfBoundsException` 这样的非受查异常；
- Java 虚拟机和运行库出现的内部错误。

如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常，因为任何一个抛出异常的方法都有可能是一个死亡陷阱，如果没有处理器捕获这个异常，当前执行的线程就会结束。

对于那些可能被他人使用的方法，应该根据异常规范(exception specification)，在方法的首部声明这个方法可能抛出的异常。

如果一个方法可能抛出多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。

但是，不需要声明 Java 的内部错误，即从 `Error` 继承的错误，任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力。

同样，也不应该声明从 `RuntimeException` 继承的那些非受查异常。因为这些运行时错误完全在我们的控制之下，如果特别关注数组下标引发的错误，就应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性上。

总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。

如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。

警告⚠️：如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。

特别需要说明的是🌿：如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。

如果类中的一个方法声明将会抛出一个异常，而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常，或者这个类任意一个子类的异常。

### 如何抛出异常
首先要决定抛出什么类型的异常，即找到一个合适的异常类，其次是创建这个类的对象，最后将这个对象抛出。
```java
String readData(Scanner in) throws EOFException {
    ...
    while (...) {
        if (!in.hasNext()) {

            if (n < len) {
                String gripe = "Content-length: " + len + ", Received: " + n;
                throw new EOFException(gripe);
            }
        }
    }
    return s;
}
```
一旦方法抛出了异常，这个方法就可能返回到调用者。也就是说，不必为返回的默认值或错误代码担忧。

### 创建异常类
创建自己的异常类，只需要定义一个派生于 `Exception` 的类，或者派生于 `Exception` 子类的类。

习惯上，所有派生的异常类都包含两个构造器，一个是默认的构造器，另一个是带有详细描述信息的构造器。
```java
class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String gripe) {
        super(gripe);
    }
}
```

java.lang.Throwable 类用到的方法：
- Throwable()：构造一个新的 `Throwable` 对象，这个对象没有详细的描述信息。
- Throwable(String message)：构造一个新的 `Throwable` 对象，这个对象带有特定的详细描述信息。
- String getMessage()：获取 `Throwable` 对象的详细描述信息。


## 捕获异常


## 使用异常机制的技巧


## 使用断言


## 记录日志


## 调试技巧


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


