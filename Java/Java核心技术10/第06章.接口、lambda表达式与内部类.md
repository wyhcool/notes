---
title: 接口、lambda 表达式与内部类
date: 2020-01-18 13:10:00
update:
tags:
categories:
- Java
---

接口(interface)技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现(implement)一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。

lambda 表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法，使用 lambda 表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。

内部类(inner class)定义在另外一个类的内部，其中的方法可以访问它们的外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。

代理(proxy)是一种实现任意接口的对象。代理是一种非常专业的构造工具，它可以用来构造系统级的工具。


## 接口
### 接口概念
接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。

`Arrays` 类中的 `sort` 方法承诺可以对数组对象进行排序，但要求满足：对象所属的类必须实现了 `Comparable` 接口：
```java
public interface Comparable {
    int compareTo(Object other);
}
```
这就是说，任何实现 `Comparable` 接口的类都需要包含 `compareTo` 方法，并且这个方法的参数必须是一个 `Object` 对象，返回一个整型数值。
```java
// 在 Java SE 5.0 中，Comparable 接口已经改进为泛型类型：
public interface Comparable<T> {
    int compareTo(T other); // parameter has type T
}

// 在实现 Comparable<Employee> 接口的类中，必须提供下列方法：
int compareTo(Employee other);

// 还可以使用不带类型参数的原始 Comparable 类型，这样一来，compareTo
// 方法就有一个 Object 类型的参数，必须手动将 compareTo 方法的参数强制
// 转换为所希望的类型。
```
接口中的所有方法自动地属于 `public`，因此，在接口中声明方法时，不必提供关键字 `public`。

接口中还有一个没有明确说明的附加要求：在调用 `x.compareTo(y)` 时，这个方法必须确实比较两个对象的内容，并返回比较的结果。当 x 小于 y 时，返回一个负数；当 x 等于 y 时，返回 0；否则返回一个正数。

一个接口可以包含多个方法。

在接口中可以定义常量。

最重要的是接口不能提供哪些功能：接口绝不能含有实例域，在 Java SE 8 之前，也不能在接口中实现方法。当然，这些方法不能引用实例域 —— 接口没有实例。

提供实例域和方法实现的任务由实现接口的类来完成。

为了让类实现一个接口，通常需要下面两个步骤：
- 将类声明为实现给定的接口；
- 对接口中的所有方法进行定义。

要将类声明为实现某个接口，需要使用关键字 `implements`。

警告⚠️：在实现方法时，必须把方法声明为 `public`，否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。
```java
class Employee implements Comparable<Employee> {
    public int compareTo(Employee other) {
        return Double.compare(salary, other.salary);
    }
}
```
提示：ℹ️ `Comparable` 接口中的 `compareTo` 方法将返回一个整型数值。但需注意：在对两个整数域进行比较时，整数的范围不能过大，以避免造成减法运算的溢出。如果确信两个整数均为非负整数，或者它们的绝对值不会超过 `(Integer.MAX_VALUE-1)/2`，就不会出现问题，否则，调用静态 `Integer.compare` 方法。在对两个浮点数值域进行比较时，当它们很接近但又不相等的时候，它们的差经过四舍五入后有可能变成 0。

要让一个类使用排序服务必须让它实现 `compareTo` 方法，这是理所当然的，因为要向 `sort` 方法提供对象的比较方式。但是为什么不能在 `Employee` 类直接提供一个 `compareTo` 方法，而必须实现 `Comparable` 接口呢？

主要原因是：Java 程序设计语言是一种强类型(strongly typed)语言。在调用方法的时候，编译器将会检查这个方法是否存在。
```java
// 在 sort 方法中存在下列语句：
if (a[i].compareTo(a[j]) > 0) {
    //...
}
// 为此，编译器必须确认 a[i] 一定要有 compareTo 方法。
// 如果a是一个 Comparable 对象的数组，就可以确保拥有 compareTo 方法
// 因为每个实现 Comparable 接口的类都必须提供这个方法的定义。
```
java.lang.Comparable\<T> 用到的方法：
- int compareTo(T other)：用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值；如果相等则返回 0；否则返回正值。

java.util.Arrays 用到的方法：
- static void sort(Object[] a)：使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了 Comparable 接口的类，并且元素之间必须是可比较的。

java.lang.Integer 用到的方法：
- static int compare(int x, int y)：如果 x \< y 返回一个负整数；如果 x 和 y 相等，则返回 0；否则返回一个正整数。

java.lang.Double 用到的方法：
- static int compare(double x, double y)：如果 x \< y 返回一个负整数；如果 x 和 y 相等，则返回 0；否则返回一个正整数。

语言标准规定：对于任意的 x 和 y，实现必须能够保证 `sgn(x.compareTo(y)) = -sgn(y.compareTo(x))`（也就是说，如果 `y.compareTo(x)` 抛出一个异常，那么 `x.compareTo(y)` 也应该抛出一个异常。）其中 `sgn` 是一个数值的符号：如果 n 是负值，`sgn(n)` 返回 -1；如果 n 是 0，`sgn(n)` 返回 0；如果 n 是正值，`sgn(n)` 返回 1。

### 接口的特性
接口不是类，尤其不能使用 `new` 运算符实例化一个接口。

然而，尽管不能构造接口的对象，却能声明接口的变量。接口变量必须引用实现了接口的类对象。

如同使用 `instanceof` 检查一个对象是否属于某个特定类一样，也可以使用 `instanceof` 检查一个对象是否实现了某个特定的接口。

如同建立类的继承关系一样，接口也可以被扩展，允许存在多条从具有较高通用性的接口到较高专用性的接口的链。

虽然在接口中不能包含实例域或静态方法，却可以包含常量。与接口中的方法都自动地被设置为 `public` 一样，接口中的域将被自动设为 `public static final`。

建议🤚:出于提高清晰度的考虑，可以将接口方法标记为 `public`，将域标记为 `public static final`。<strong><font color="red">但 Java 语言规范建议不要书写✍️多余的关键字</font></strong>

有些接口只定义了常量，而没有定义方法。比如，在标准库中的 `SwingConstants`。<strong><font color="red">然而，这样应用接口有点偏离了接口概念的初衷，建议不要这样使用它。</font></strong>

尽管每个类只能拥有一个超类，但却可以实现多个接口，这就为定义类的行为提供了极大的灵活性。例如，Java 程序设计语言有一个非常重要的内置接口 `Cloneable`，如果某个类实现了这个接口，使用 `Object` 类中的 `clone` 方法就可以创建该类对象的一个拷贝。

使用逗号将实现的各个接口分隔开。

### 接口与抽象类
为什么 Java 程序设计语言要不辞辛苦地引入接口的概念？

使用抽象类表示通用属性存在这样一个问题：每个类只能扩展于一个类。

但每个类可以实现多个接口。

C++ 注释：C++ 允许一个类有多个超类，此特性称为多重继承(multiple inheritance)。多重继承会让语言本身变得非常复杂，效率也会降低。

实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。

### 静态方法
在 Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的，只是这有违于将接口作为抽象规范的初衷。

目前为止，通常的做法是将静态方法放在伴随类中。在标准库中有成对出现的接口和实用工具类，如 `Collection`/`Collections` 或 `Path`/`Paths`。

一般地，在实现自己的接口时，不再需要为实用工具方法另外提供一个伴随类。

### 默认方法
可以为接口方法提供一个默认实现，必须用 `default` 修饰符标记。

通常，这没有太大用处，因为接口的每一个实际实现都要覆盖这个方法。不过有些情况下，默认方法可能比较有用。比如发生鼠标点击事件时得到通知，大多数情况下，开发者只需要关心其中的 1、2 个事件类型。在 Java SE 8 中，可以把所有方法声明为默认方法，这些默认方法什么也不做。这样一来，实现这个接口的程序员只需要为它们真正关心的事件覆盖相应的监听器。
```java
public interface MouseListener {
    default void mouseClicked(MouseEvent event) {}
    default void mousePressed(MouseEvent event) {}
    default void mouseRelease(MouseEvent event) {}
    default void mouseEntered(MouseEvent event) {}
    default void mouseExited(MouseEvent event) {}
}
```

默认方法可以调用任何其他方法。

注意⚠️：在 Java API 中，很多接口都有相应的伴随类，这个伴随类实现了相应接口的部分或所有方法，如 `Collection`/`AbstractCollection` 或 `MouseListener`/`MouseAdapter`。在 Java SE 8 中，这个技术已经过时，现在可以直接在接口中实现方法。

默认方法的一个重要用法是<strong>接口演化(interface evolution)</strong>。

以 `Collection` 接口为例，这个接口作为 `Java` 的一部分已经很多年了，后来，在 Java SE 8 中，又为这个接口增加了一个 `stream` 方法，假设 `stream` 方法不是一个默认方法，那么原先实现该接口的类将不能编译，因为它没有实现这个新方法。<strong>为接口增加一个非默认方法不能保证源代码兼容(source compatible)</strong>。

假设不重新编译这个类，而只是使用原先一个包含这个类的 JAR 文件。这个类仍能正常加载，尽管没有这个新方法。程序仍然可以构造类实例，不会有意外发生。不过如果在该实例上调用新增的 `stream` 方法，就会出现 `AbstractMethodError`。

将方法实现为一个默认方法就可以解决以上两问题。

### 解决默认方法冲突
如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况呢？

Java 采用如下规则：
- 1.超类优先。如果超类提供了一种具体方法，则具有相同名称和参数类型的默认方法将被忽略。
- 2.接口冲突。如果超级接口提供了默认方法，而另一个接口提供了具有相同名称和参数类型（默认值或没有参数）的方法，则必须通过覆盖该方法来解决冲突。
```java
interface Named {
    default String getName() { return getClass().getName() + "_" + hashCode(); }
}

interface Person {
    default String getName() { return getClass().getName();}
}

class Student implements Person, Named {
    //...
}
```
类会继承 `Person` 和 `Named` 接口提供的两个不一致的 `getName` 方法，此时 `Student` 类并不是从中选择一个，Java 编译器会报告一个错误，让程序员来解决这个二义性。只需要在 `Student` 类中提供一个 `getName` 方法，在这个方法中，可以选择两个冲突方法中的一个。

假设 `Named` 接口没有为 `getName` 提供默认实现，`Student` 类仍不会从 `Person` 接口继承默认方法，此时报错：`Class 'Student' must be declared abstract or implement abstract method in 'Named'`。如果至少有一个接口提供了一个实现，编译器就会报告错误，程序员必须解决这个二义性。

当然，如果两个接口都没有为共享方法提供默认实现，那么就与 Java SE 8 之前的情况一样，这里不存在冲突。

实现类可以有两个选择：实现这个方法，或者干脆不实现（即这个类本身就是抽象的）。

如果一个类扩展了一个超类，同时实现了一个接口，并从超类和接口中继承了相同的方法，这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。

"类优先"规则可以确保与 Java SE 7 的兼容性。如果为一个接口增加默认方法，这对于这个默认方法周倩能正常工作的代码不会有任何影响。



## lambda 表达式


## 内部类


## 代理


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8