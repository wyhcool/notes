---
title: Swing 用户界面组件
date: 2019-03-04 08:00:00
tags:
categories:
- Java
---

## Swing 与模型-视图-控制器设计模式
### 设计模式
在解决一个问题时，不需要从头做起，而是借鉴过去的经验，或者向做过相关工作的专家请教。设计模式就是一种方法，这种方法以一种结构化的方式展示专家们的心血。

每种模式都遵循一种特定的格式，这些模式首先描述背景，即引发设计问题的情形；接着解释问题，通常这里会有几个冲突的因素；最终，权衡这些冲突，给出问题的解决方案。

在“模型-视图-控制器”模式中，背景是显示信息和接收用户输入的用户界面系统。这里有几个冲突因素，对于同一数据来说，可能需要同时更新多个可视化表示。例如，为了适应各种观感标准，可能需要改变可视化表示形式；又例如，支持语音命令，可能需要改变交互机制。解决方案是将这些功能分布到三个独立的交互组件：模型、视图和控制器。

在 AWT 和 Swing 设计中使用的除了“模型-视图-控制器”模式外，还包括：
- 容器和组件是“组合(composite)”模式
- 带滚动条的面板是“装饰器(decorator)”模式
- 布局管理器是“策略(strategy)”模式

设计模式的另一个重要特点是它们已经成为文化的一部分，成为探讨设计方案的一种有效办法。

### 模型-视图-控制器模式(model-view-controller)
MVC 模式需要实现三个独立的类：
- 模型(model)：存储内容；
- 视图(view)：显示内容；
- 控制器(controller)：处理用户输入。

这个模式明确地规定了三个对象如何进行交互。模型存储内容，它没有用户界面。模型必须实现改变内容和查找内容的方法。记住：模型是完全不可见的，显示存储在模型中的数据是视图的工作。

MVC 模式的一个优点是一个模型可以有多个视图，其中每个视图可以显示全部内容的不同分或不同形式。

控制器负责处理用户输入事件，然后决定是否把这些事件转换成对模型或视图的改变。

### Swing 按钮的模型-视图-控制器分析
对于大多数组件来说，模型类将实现一个名字以 `Model` 结尾的接口，例如，按钮类就实现了 `ButtonModel` 接口，实现了此接口的类可以定义各种按钮的状态，在 Swing 库中一个名为 `DefaultButtonModel` 的类就实现了这个接口。

```java
public interface ButtonModel extends ItemSelectable {
    boolean isArmed();
    boolean isSelected();
    boolean isEnabled();
    boolean isPressed();
    boolean isRollover();
    public void setArmed(boolean b);
    public void setSelected(boolean b);
    public void setEnabled(boolean b);
    public void setPressed(boolean b);
    public void setRollover(boolean b);
    public void setMnemonic(int key);
    public int  getMnemonic();
    public void setActionCommand(String s);
    public String getActionCommand();
    public void setGroup(ButtonGroup group);
    void addActionListener(ActionListener l);
    void removeActionListener(ActionListener l);
    void addItemListener(ItemListener l);
    void removeItemListener(ItemListener l);
    void addChangeListener(ChangeListener l);
    void removeChangeListener(ChangeListener l);
}
```

`ButtonModel` 接口中的按钮模型所维护的数据类别：

| 属性名 | 值 |
|:-|:-|
| actionCommand | 与按钮关联的动作命令字符串 |
| mnemonic | 按钮的快捷键 |
| armed | 如果按钮被按下且鼠标仍在按钮上则为 true |
| enabled | 如果按钮是可选择的则为 true |
| pressed | 如果按钮被按下且鼠标按键没有释放则为 true |
| rollover | 如果鼠标在按钮之上则为 true |
| selected | 如果按钮已经被选择则为 true |

每个 `JButton` 对象都存储了一个按钮模型对象，可以用下列方式得到它的引用：
```java
JButton button = new JButton("Blue");
ButtonModel model = button.getModel();
```

`JButton` 究竟是什么呢？事实上，它只是一个继承了 `JComponent` 的包装器类，其中包含了一个 `DefaultButtonModel` 对象，一些视图数据（例如按钮标签和图标）以及负责按钮视图的 `BasicButtonUI` 对象。


## 布局管理概述
通常，组件放置在容器中，布局管理器决定容器中组件具体放置的位置和大小。

`Component` 的类层次结构：
```
                                Object
                                  |
                              Component
                                  |
                              Container
       ___________________________|______________________
       |                                                | 
    Window                                        JComponent 
   ____|____       _____________________________________|_______________________________________ 
 Frame   Dialog   JPanel  JTextComponent  JLabel  JScrollPane  JComboBox  AbstractButton  JMenuBar
  |        |              ______|______                           ________________|________________
JFrame   JDialog    JTextField      JTextArea                  JButton     JToggleButton      JMenuItem
```

注意：继承层次有两点显得混乱：首先，像 `JFrame` 这样的顶层窗口是 `Container` 的子类，所以也是 `Component` 的子类，但却不能放在其他容器内。其次，`JComponent` 是 `Container` 的子类，但不直接继承 `Component`，因此，可以将其他组件添置到 `JButton` 中，但无论如何，这些组件无法显示出来。

每个容器都有一个默认的布局管理器，面板(JPanel 对象)的默认布局管理器是流布局管理器(flow layout mananger)，但可以重新进行设置：
```java
// 设置面板使用 GridLayout 类布局组件
panel.setLayout(new GridLayout(4, 4));
```

### 边框布局
边框布局管理器(border layout manager)是每个 `JFrame` 的内容窗格的默认布局管理器，它允许为每个组件选择一个放置位置，可以选择把组件放在内容窗格的中部、北部、南部、东部或者西部：
```java
frame.add(component, BorderLayout.SOUTH);
```
先放置边缘组件，剩余的可用空间由中间组件占据。当容器被缩放时，边缘组件的尺寸不会改变，而中部组件的大小会发生变化。在添加组件时可以指定 `BorderLayout` 类中的 `CENTER`、`NORTH`、`SOUTH`、`EAST` 和 `WEST` 常量。

注意：并非需要占用所有的位置，如果没有提供任何值，系统默认为 `CENTER`。

与流布局不同，边框布局会扩展所有组件的尺寸以便填满可用空间（而流布局将维持每个组件的最佳尺寸）。当将一个按钮添加到容器中时会出现问题：
```java
frame.add(yellowButton, BorderLayout.SOUTH); // don't
```
执行上述语句的结果是，按钮扩展至填满框架的整个南部区域。而且，如果再将另外一个按钮添加到南部区域时，就会取代第一个按钮。

解决这个问题的常见方法是使用另外一个面板，将按钮全部包含在一个面板中：
```java
JPanel panel = new JPanel();
panel.add(yellowButton);
panel.add(blueButton);
panel.add(redButton);
frame.add(panel, BorderLayout.SOUTH);
```

### 网格布局
网格布局按行列排列所有的组件，它的每个单元大小都是一样的。

在网格布局对象的构造器中，需要指定行数和列数：
```java
panel.setLayout(new GridLayout(4, 4));
```
添加组件，从第一行的第一列开始，然后是第一行的第二列，以此类推。

实际上，在组织窗口的布局时小网格(通常只有一行或者一列)比较有用。例如，如果想放置一行尺寸都一样的按钮，就可以将这些按钮放置在一个面板里，这个面板使用只有一行的网格布局进行管理。

```
getSource()
Returns the object on which the Event initially occurred.
依赖于事件对象

getActionCommand()
Returns the command name of the action event fired by this button. If the command name is null (default) then this method returns the label of the button.
依赖于按钮上的字符串

getSource 得到的组件的名称，而 getActionCommand 得到的是标签。
如：
Button bt = new Button("buttons");
用 getSource 得到的是 bt，而用 getActionCommand 得到的是 buttons
```


## 文本输入

## 选择组件

## 菜单

## 复杂的布局管理

## 对话框

## GUI 程序排错

## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8