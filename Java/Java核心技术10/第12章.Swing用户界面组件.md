---
title: Swing 用户界面组件
date: 2019-03-04 08:00:00
tags:
categories:
- Java
---

## Swing 与模型-视图-控制器设计模式
### 设计模式
在解决一个问题时，不需要从头做起，而是借鉴过去的经验，或者向做过相关工作的专家请教。设计模式就是一种方法，这种方法以一种结构化的方式展示专家们的心血。

每种模式都遵循一种特定的格式，这些模式首先描述背景，即引发设计问题的情形；接着解释问题，通常这里会有几个冲突的因素；最终，权衡这些冲突，给出问题的解决方案。

在“模型-视图-控制器”模式中，背景是显示信息和接收用户输入的用户界面系统。这里有几个冲突因素，对于同一数据来说，可能需要同时更新多个可视化表示。例如，为了适应各种观感标准，可能需要改变可视化表示形式；又例如，支持语音命令，可能需要改变交互机制。解决方案是将这些功能分布到三个独立的交互组件：模型、视图和控制器。

在 AWT 和 Swing 设计中使用的除了“模型-视图-控制器”模式外，还包括：
- 容器和组件是“组合(composite)”模式
- 带滚动条的面板是“装饰器(decorator)”模式
- 布局管理器是“策略(strategy)”模式

设计模式的另一个重要特点是它们已经成为文化的一部分，成为探讨设计方案的一种有效办法。

### 模型-视图-控制器模式(model-view-controller)
MVC 模式需要实现三个独立的类：
- 模型(model)：存储内容；
- 视图(view)：显示内容；
- 控制器(controller)：处理用户输入。

这个模式明确地规定了三个对象如何进行交互。模型存储内容，它没有用户界面。模型必须实现改变内容和查找内容的方法。记住：模型是完全不可见的，显示存储在模型中的数据是视图的工作。

MVC 模式的一个优点是一个模型可以有多个视图，其中每个视图可以显示全部内容的不同分或不同形式。

控制器负责处理用户输入事件，然后决定是否把这些事件转换成对模型或视图的改变。

### Swing 按钮的模型-视图-控制器分析
对于大多数组件来说，模型类将实现一个名字以 `Model` 结尾的接口，例如，按钮类就实现了 `ButtonModel` 接口，实现了此接口的类可以定义各种按钮的状态，在 Swing 库中一个名为 `DefaultButtonModel` 的类就实现了这个接口。

```java
public interface ButtonModel extends ItemSelectable {
    boolean isArmed();
    boolean isSelected();
    boolean isEnabled();
    boolean isPressed();
    boolean isRollover();
    public void setArmed(boolean b);
    public void setSelected(boolean b);
    public void setEnabled(boolean b);
    public void setPressed(boolean b);
    public void setRollover(boolean b);
    public void setMnemonic(int key);
    public int  getMnemonic();
    public void setActionCommand(String s);
    public String getActionCommand();
    public void setGroup(ButtonGroup group);
    void addActionListener(ActionListener l);
    void removeActionListener(ActionListener l);
    void addItemListener(ItemListener l);
    void removeItemListener(ItemListener l);
    void addChangeListener(ChangeListener l);
    void removeChangeListener(ChangeListener l);
}
```

`ButtonModel` 接口中的按钮模型所维护的数据类别：

| 属性名 | 值 |
|:-|:-|
| actionCommand | 与按钮关联的动作命令字符串 |
| mnemonic | 按钮的快捷键 |
| armed | 如果按钮被按下且鼠标仍在按钮上则为 true |
| enabled | 如果按钮是可选择的则为 true |
| pressed | 如果按钮被按下且鼠标按键没有释放则为 true |
| rollover | 如果鼠标在按钮之上则为 true |
| selected | 如果按钮已经被选择则为 true |

每个 `JButton` 对象都存储了一个按钮模型对象，可以用下列方式得到它的引用：
```java
JButton button = new JButton("Blue");
ButtonModel model = button.getModel();
```

`JButton` 究竟是什么呢？事实上，它只是一个继承了 `JComponent` 的包装器类，其中包含了一个 `DefaultButtonModel` 对象，一些视图数据（例如按钮标签和图标）以及负责按钮视图的 `BasicButtonUI` 对象。


## 布局管理概述
通常，组件放置在容器中，布局管理器决定容器中组件具体放置的位置和大小。

`Component` 的类层次结构：
```
                                Object
                                  |
                              Component
                                  |
                              Container
       ___________________________|______________________
       |                                                | 
    Window                                        JComponent 
   ____|____       _____________________________________|_______________________________________ 
 Frame   Dialog   JPanel  JTextComponent  JLabel  JScrollPane  JComboBox  AbstractButton  JMenuBar
  |        |              ______|______                           ________________|________________
JFrame   JDialog    JTextField      JTextArea                  JButton     JToggleButton      JMenuItem
```

注意：继承层次有两点显得混乱：首先，像 `JFrame` 这样的顶层窗口是 `Container` 的子类，所以也是 `Component` 的子类，但却不能放在其他容器内。其次，`JComponent` 是 `Container` 的子类，但不直接继承 `Component`，因此，可以将其他组件添置到 `JButton` 中，但无论如何，这些组件无法显示出来。

每个容器都有一个默认的布局管理器，面板(JPanel 对象)的默认布局管理器是流布局管理器(flow layout mananger)，但可以重新进行设置：
```java
// 设置面板使用 GridLayout 类布局组件
panel.setLayout(new GridLayout(4, 4));
```

### 边框布局
边框布局管理器(border layout manager)是每个 `JFrame` 的内容窗格的默认布局管理器，它允许为每个组件选择一个放置位置，可以选择把组件放在内容窗格的中部、北部、南部、东部或者西部：
```java
frame.add(component, BorderLayout.SOUTH);
```
先放置边缘组件，剩余的可用空间由中间组件占据。当容器被缩放时，边缘组件的尺寸不会改变，而中部组件的大小会发生变化。在添加组件时可以指定 `BorderLayout` 类中的 `CENTER`、`NORTH`、`SOUTH`、`EAST` 和 `WEST` 常量。

注意：并非需要占用所有的位置，如果没有提供任何值，系统默认为 `CENTER`。

与流布局不同，边框布局会扩展所有组件的尺寸以便填满可用空间（而流布局将维持每个组件的最佳尺寸）。当将一个按钮添加到容器中时会出现问题：
```java
frame.add(yellowButton, BorderLayout.SOUTH); // don't
```
执行上述语句的结果是，按钮扩展至填满框架的整个南部区域。而且，如果再将另外一个按钮添加到南部区域时，就会取代第一个按钮。

解决这个问题的常见方法是使用另外一个面板，将按钮全部包含在一个面板中：
```java
JPanel panel = new JPanel();
panel.add(yellowButton);
panel.add(blueButton);
panel.add(redButton);
frame.add(panel, BorderLayout.SOUTH);
```

### 网格布局
网格布局按行列排列所有的组件，它的每个单元大小都是一样的。

在网格布局对象的构造器中，需要指定行数和列数：
```java
panel.setLayout(new GridLayout(4, 4));
```
添加组件，从第一行的第一列开始，然后是第一行的第二列，以此类推。

实际上，在组织窗口的布局时小网格(通常只有一行或者一列)比较有用。例如，如果想放置一行尺寸都一样的按钮，就可以将这些按钮放置在一个面板里，这个面板使用只有一行的网格布局进行管理。

```
getSource()
Returns the object on which the Event initially occurred.
依赖于事件对象

getActionCommand()
Returns the command name of the action event fired by this button. If the command name is null (default) then this method returns the label of the button.
依赖于按钮上的字符串

getSource 得到的组件的名称，而 getActionCommand 得到的是标签。
如：
Button bt = new Button("buttons");
用 getSource 得到的是 bt，而用 getActionCommand 得到的是 buttons
```


## 文本输入
文本域(`JTextField`)和文本区(`JTextArea`)组件获取文本输入。文本域只能接收单行文本的输入，而文本区能够接收多行文本的输入。`JPassword` 也只能接收单行文本的输入，但不会将输入的内容显示出来。

这三个类都继承自 `JTextComponent` 类，由于 `JTextComponent` 是一个抽象类，所以不能构造这个类的对象。

### 文本域
把文本域添加到窗口的方法是将它添加到面板或者其他容器中：
```java
JPanel panel = new JPanel();
JTextField textField = new JTextField("Default input", 20);
panel.add(textField);
```
构造器的第一个参数提供了初始文本，第二个参数设置了文本域的宽度，如上宽度值为 20 列。注意：列不是一个精确的测量单位，一列就是在当前使用的字体下一个字符的宽度。如果希望文本域最多能够输入 n 个字符，就应该把宽度设置为 n 列。

注意⚠️：列数只是给 AWt 设定首选大小的一个提示，如果布局管理器需要缩放这个文本域，它会调整文本域的大小。在 `JTextField` 的构造器中设定的宽度并不是用户能输入的字符个数的上限，用户可以输入一个更长的字符串，但是当文本长度超过文本域长度时输入就会滚动。

提示：如果需要在运行时重新设置列数，可以使用 `setColumns` 方法，在改变了一个文本域的大小之后，需要调用包含这个文本框的容器的 `revalidate` 方法，重新计算容器内所有组件的大小，并对它们重新进行布局：
```java
textField.setColumns(10);
panel.revalidate();
```
`revalidate` 方法是 `JComponent` 类的方法，它并不是马上就改变组件大小，而是给这个组件加一个需要改变大小的标记，这样就避免了多个组件改变大小时带来的重复计算。但是如果想重新计算一个 `JFrame` 中的所有组件，就必须调用 `validate` 方法，因为 `JFrame` 没有扩展 `JComponent`。

只要不为 `JTextField` 构造器提供字符串参数，就可以构造一个空白文本域：
```java
JTextField textField = new JTextField(20);
```
可以调用 `setText` 方法改变文本域中的内容，该方法是从 `JTextComponent` 中继承而来的：
```java
textField.setText("Hello!");
```
调用 `getText` 方法来获取用户键入的文本，调用 `trim` 方法将返回的文本域中的内容的前后空格去掉：
```java
String text = textField.getText().trim();
```
如果要改变显示文本的字符，可以调用 `setFont` 方法。

### 标签和标签组件
标签是容纳文本的组件，它们没有任何的修饰，也不能响应用户输入，可以利用标签标识组件：
- 用相应的文本构造一个 `JLabel` 组件；
- 将标签组件放置在距离需要标识的组件足够近的地方，以便用户可以知道标签所标识的组件。

`JLabel` 的构造器允许指定初始文本和图标，也可选择内容的排列方式。可以用 `SwingConstants` 接口中的常量来指定排列方式，在这个接口中定义了 `LEFT`、`RIGHT`、`CENTER`、`NORTH`、`EAST` 等常量，`JLabel` 是实现这个接口的类，因此也可以使用这些常量：
```java
JLabel label = new JLabel("User name: ", SwingConstants.RIGHT);
// 或者
JLabel label = new JLabel("User name: ", JLabel.RIGHT);
```
利用 `setText` 和 `setIcon` 方法可以在运行时期间设置标签的文本和图标。

### 密码域
密码域是一个特殊类型的文本域，每个输入的字符都用回显字符(each character)表示，典型的回显字符是星号(\*)。Swing 提供了 `JPasswordField` 类来实现这样的文本域。

密码域应用 MVC 模式，密码域采用与常规的文本域相同的模型来存储数据，但是它的视图却改为显示回显字符，而不是实际的字符。

javax.swing.JPasswordField 类用到的方法：
- char\[] getPassword()：返回密码域的文本，为了安全起见，在使用之后应该覆写返回的数组内容（密码并不是以 `String` 的形式返回，这是因为字符串在被垃圾回收器回收之前会一直驻留在虚拟机中）。

### 文本区
使用 `JTextArea` 组件来接收多行文本，并用 `ENTER` 键换行，每行都以一个 `\n` 结尾。

在 `JTextArea` 组件的构造器中，可以指定文本区的行数和列数：
```java
// 8 lines of 40 columns each
JTextArea textArea = new JTextArea(8, 40);
```
当输入过长时，文本会滚动，可以用 `setColumns` 方法改变列数，用 `setRows` 方法改变行数，这些数值只是首选大小，布局管理器可能会对文本区进行缩放。

如果文本区的文本超出显示的范围，那么剩下的文本就会被裁减掉。可以通过开启换行特性来避免裁剪过长的行：
```java
textArea.setLineWrap(true); // long lines are wrapped
```
注意：换行只是视觉效果，文档中的文本没有改变，在文本中并没有插入 `\n` 字符。

### 滚动窗格
在 Swing 中，文本区没有滚动条。如果需要滚动条，可以将文本区插入到滚动窗格中(scroll pane)中：
```java
JTextArea textArea = new JTextArea(8, 40);
JScrollPane scrollPane = new JScrollPane(textArea);
```
现在滚动窗格管理文本区的视图。如果文本超出了文本区可以显示的范围，滚动条就会自动地出现，并且在删除部分文本后，但文本能够显示在文本区范围内时，滚动条会再次自动地消失。滚动是由滚动窗格内部处理的，编写程序时无需处理滚动事件。

如果要想为组件添加滚动条，只需将它们放入一个滚动窗格中即可。


## 选择组件
### 复选框
复选框自动地带有标识标签，用户通过点击某个复选框来选择相应的选项，再点击则去掉选取。当复选框获得焦点时，用户也可以通过按空格键来切换选择。

复选框需要一个紧邻它的标签来说明其用途，在构造器中指定标签文本：
```java
JCheckBox bold = new JCheckBox("Bold");
```
可以使用 `setSelected` 方法来选定或取消选定复选框：
```java
bold.setSelected(true);
```
`isSelected` 方法将返回每个复选框的当前状态。如果没有选取则为 `false`，否则为 `true`。

当用户点击复选框时将触发一个动作事件。通常，可以为复选框设置一个动作监听器。
```java
ActionListener listener = event -> {
    int mode = 0;
    if (bold.isSelected()) mode += Font.BOLD;
    if (italic.isSelected()) mode += Font.ITALIC;
    label.setFont(new Font(Font.SERIF, mode, FONTSIZE));
};
bold.addActionListener(listener);
italic.addActionListener(listener);
```

### 单选框
通常，需要用户只选择几个选项中的一个，当用户选择另一项的时候，前一项就自动地取消选择，这样一组选框称为单选钮组(radio button group)。

在 Swing 中，为单选钮组构造一个 `ButtonGroup` 对象，然后再将 `JRadioButton` 类型的对象添加到按钮组中。按钮组负责在新按钮被按下时，取消前一个被按下的按钮的选择状态。
```java
ButtonGroup group = new ButtonGroup();

JRadioButton smallButton = new JRadioButton("Small", false);
group.add(smallButton);

JRadioButton mediumButton = new JRadioButton("Medium", true);
group.add(mediumButton);
```
构造器的第二个参数为 `true` 表明这个按钮初始状态是被选择，其他按钮构造器的这个参数为 `false`。

注意：按钮组仅仅控制按钮的行为，如果想把这些按钮组织在一起布局，需要把它们添加到容器中，比如 `JPanel`。

单选钮的事件通知机制与其他按钮一样。当用户点击一个单选钮时，这个按钮将产生一个动作事件。比如，定义一个事件监听器用来把字体大小设置为特定值：
```java
ActionListener listener = event -> 
    label.setFont(new Font("Serif", Font.PLAIN, size));
```

注意⚠️：`ButtonGroup` 对象控制着所有的按钮，`ButtonGroup` 类中有一个 `getSelection` 方法，返回附加在被选择按钮上的 `ButtonModel` 的引用。`ButtonModel` 的 `getActionCommand` 方法可以获取动作命令，而一个单选钮的动作命令是它的文本标签，它的模型的动作命令是 `null`。只有在通过 `setActionCommand` 命令明确地为所有单选钮设置动作命令后，才能够通过调用方法 `buttonGroup.getSelection().getActionCommand()` 获得当前选择的按钮的动作命令。

### 边框


### 组合框


### 滚动条


## 菜单

## 复杂的布局管理

## 对话框

## GUI 程序排错

## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8