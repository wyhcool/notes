---
title: 事件处理
date: 2020-02-28 10:19:00
tags:
categories:
- Java
---

## 事件处理基础
任何支持 GUI 的操作环境都要不断地监视按键或点击鼠标这样的事件，操作系统将这些事件报告给正在运行的应用程序，如果有事件产生，每个应用程序将决定如何对它们做出响应。

在 Visual Basic 语言中，事件与代码有着明确的对应关系，程序员对相关的特定事件编写代码，并将这些代码放置在过程中。

在 C 语言中，需要编写代码不断地检查事件队列，以便查询操作环境报告的内容。

在 AWT 所知的事件范围内，完全可以控制事件从事件源(event source)到事件监听器(event listener)的传递过程，并将任何对象指派给事件监听器。

事件源有一些向其注册事件监听器的方法，当某个事件源产生事件时，事件源会向事件注册的所有事件监听器对象发送一个通告。

在 Java 中将事件的相关信息封装在一个事件对象(event object)中，所有的事件对象都最终派生于 `java.util.EventObject` 类。

不同的事件源可以产生不同类别的事件，例如，按钮可以发送一个 `ActionEvent` 对象，而窗口可以发送 `WindowEvent` 对象。

AWT 事件处理机制：
- 监听器对象是一个实现了特定监听器接口(listener interface)的类的实例。
- 事件源是一个能够注册监听器对象并发送事件对象的对象。
- 当事件发生时，事件源将事件对象传递给所有注册的监听器。
- 监听器对象将利用事件对象中的信息决定如何对事件做出响应。

### 处理按钮点击事件
使用 `ActionListener` 接口并不仅限于按钮点击事件，它可以应用于多种情况：
- 当采用鼠标双击的方式选择了列表框中的一个选项时；
- 当选择了一个菜单项时；
- 当在文本域中按回车键时；
- 对于一个 `Timer` 组件来说，当到达指定的时间间隔时。

使用 `ActionListener` 接口的方式都是一样的：`actionPerformed` 方法( `ActionListener` 中的唯一方法)将接收一个 `ActionEvent` 类型的对象作为参数，这个事件对象包含了事件发生时的相关信息。

这里有一个需要考虑的问题：`ColorAction` 对象不能访问 `buttonPanel` 变量，可以采用两种方式来解决这个问题。一种是将面板存储在 `ColorAction` 对象中，并在 `ColorAction` 的构造器中设置它；另一种是将 `ColorAction` 作为 `ButtonFrame` 类的内部类，这样一来，它的方法就自动地拥有访问外部面板的权限了。

事件监听器对象通常需要执行一些对其他对象可能产生影响的操作，可以策略性地将监听器类放置在需要修改状态的那个类中。

### 简洁地指定监听器
每个监听器执行一个单独的动作，通常，没有必要分别建立单独的类，只需要使用一个 lambda 表达式：
```java
exitButton.addActionListener(event -> System.exit(0));
```

注释(过时，不建议)：在较老的代码中，通常会看到使用匿名类：
```java
exitButton.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        System.exit(0);
    }
});
```

注释(过时，不建议)：创建实现了 `ActionListener` 接口的事件源容器，然后这个容器再设置自身作为监听器：
```java
yellowButton.addActionListener(this);
blueButton.addActionListener(this);
redButton.addActionListener(this);

// 现在这 3 个按钮不再是单独的监听器，它们共享一个监听器对象，即框架 frame
// 因此，actionPerformed 方法必须明确点击了哪个按钮
class ButtonFrame extends JFrame implements ActionListener {
    ...
    public void actionPerformed(ActionEvent event) {
        Object source = event.getSource();
        if (source == yellowButton) {
            ...
        } else if (source == blueButton) {
            ...
        } else if (source == redButton) {
            ...
        } else {
            ...
        }
    }
}
```

注释(过时，不建议)：lambda 表达式出现之前，还可以采用一种机制来指定事件监听器，其事件处理器包含一个方法调用。假设一个按钮监听器需要执行以下调用：
```java
frame.loadData();

// EventHandler 类可以创建这样一个监听器
EventHandler.create(ActionListener.class, frame, "loadData");
```
`EventHanlder` 机制的效率不高，而且比较容易出错，它使用反射来调用方法。处于这个原因，`EventHandler.create` 调用的第二个参数必须属于一个公有类，否则，反射机制就无法确定和调用目标方法。

### 改变观感
在默认情况下，Swing 程序使用 Metal 观感，可以采用两种方式改变观感。

第一种方式是在 Java 安装的子目录 jre/lib 下有一个 swing.properties。在这个文件中，将属性 `swing.defaultlaf` 设置为所希望的观感类名。

采用这种方式开启观感时，必须重新启动程序。Swing 程序只在启动时读取一次 swing.properties 文件。

第二种方式是动态地改变观感。需要调用静态的 `UIManager.setLookAndFeel` 方法，并提供所想要的观感类名，然后在调用静态方法 `SwingUtilities.updateComponentTreeUI` 来刷新全部的组件集。这里需要向这个方法提供一个组件，并由此找到其他的所有组件。
```java
String className = "com.sun.java.swing.plaf.motif.MotifLookAndFeel";
try {
    UIManager.setLookAndFeel(className);
    SwingUtilities.updateComponentTreeUI(frame);
    pack();
} catch (Exception ex) {
    ex.printStackTrace();
}
```

为了列举安装的所有观感实现，可以调用：
```java
UIManager.LookAndFeelInfo[] infos = UIManager.getInstalledLookAndFeels();

// 列举每一种观感的名字和类名
String name = infos[i].getName();
String className = infos[i].getClassName();

// 本机观感
Metal
javax.swing.plaf.metal.MetalLookAndFeel

Nimbus
javax.swing.plaf.nimbus.NimbusLookAndFeel

CDE/Motif
com.sun.java.swing.plaf.motif.MotifLookAndFeel

Mac OS X
com.apple.laf.AquaLookAndFeel
```

可以使用辅助方法 `makeButton` 和匿名内部类指定按钮动作，来切换观感：
```java
public class PlafFrame extends JFrame {
    ...
    private void makeButton(String name, String className) {
        JButton button = new JButton(name);
        buttonPanel.add(button);
        button.addActionListener(event -> {
            ...
            UIManager.setLookAndFeel(className);
            SwingUtitlities.updateComponentTreeUI(this);
            ...
        });
    }
}
```

注释：如果使用一个内部匿名类来定义这个监听器，需要注意向 `SwingUtitlities.updateComponentTreeUI` 传递 `PlafFrame.this`，而不是内部类的 `this` 引用。
```java
public class PlafFrame extends JFrame {
    ...
    private void makeButton(String name, String className) {
        ...
        button.addActionListener(new ActionListener() {
            ...
            SwingUtitlities.updateComponentTreeUI(PlafFrame.this);
            ...
        });
    }
}
```
注意：在 lambda 表达式中不存在这个问题，因为在一个 lambda 表达式中，`this` 就指示外围的对象。

### 适配器类
并不是所有的事件处理都像按钮点击那样简单。在程序中，往往希望用户在确认没有丢失所做工作之后再关闭程序，当用户关闭框架时，可能希望弹出一个对话框来警告用户没有保存的工作有可能会丢失，只有在有用户确认之后才退出程序。

当程序用户视图关闭一个框架窗口时，`JFrame` 对象就是 `WindowEvent` 的事件源。如果希望捕获这个事件，就必须有一个合适的监听器对象，并将它添加到框架的窗口监听器列表中。
```java
WindowListener listener = ...;
frame.addWindowListener(listener);
```

窗口监听器必须是实现 `WindowListener` 接口的类的一个对象。在 `WindowListener` 接口中包含 7 个方法，当发生窗口事件时，框架将调用这些方法响应 7 个不同的事件：
```java
public interface WindowListener {
    void windowOpened(WindowEvent e);
    void windowClosing(WindowEvent e);
    void windowClosed(WindowEvent e);
    void windowIconified(WindowEvent e); // 最小化
    void windowDeiconified(WindowEvent e); //最大化
    void windowActivated(WindowEvent e);
    void windowDeactivated(WindowEvent e);
}
```
注意⚠️：要确定窗口是否已最大化，需要添加 `WindowStateListener` 监听器，并覆盖 `windowStateChanged` 方法。

实现一个接口的任何类都必须实现其中的所有方法，在这里意味着实现 7 个方法。然而只对名为 `windowClosing` 方法感兴趣，可以定义实现这个接口的类：在 `windowClosing` 方法中增加一个对 `System.exit(0)` 的调用，其他 6 个方法不做任何事情。
```java
class Terminator implements WindowListener {
    void windowOpened(WindowEvent e) {}
    void windowClosing(WindowEvent e) {
        if (user agrees) {
            System.exit(0);
        }
    }
    void windowClosed(WindowEvent e) {}
    void windowIconified(WindowEvent e) {}
    void windowDeiconified(WindowEvent e) {}
    void windowActivated(WindowEvent e) {}
    void windowDeactivated(WindowEvent e) {}
}
```
鉴于简化的目的，每个含有多个方法的 AWT 监听器接口都配有一个适配器类(adapter)，这个类实现了接口中的所有方法，但每个方法没有做任何事情，这意味着适配器类自动满足了 Java 实现相关监听接口的技术需求，可以通过扩展适配器类来指定对某些事件的响应动作，而不必实现接口中的每个方法。

注意⚠️：`ActionListener` 这样的接口只有一个方法，因此没必要提供适配器类。

下面使用窗口适配器：
```java
class Terminator extends WindowAdapter {
    public void windowClosing(WindowEvent e) {
        if (user agrees) {
            System.exit(0);
        }
    }
}
```
警告❌：如果在扩展适配器类时将方法名拼写错了，编译器不会捕获到这个错误，可以使用 `@Override` 注解避免这种错误。

可以将监听器类定位为框架的匿名内部类，代码将会更加简练：
```java
frame.addWindowListener(new WindowAdapter() {
    public void windowClosing(WindowEvent e) {
         if (user agrees) {
            System.exit(0);
        }
    }
});
```


## 动作


## 鼠标事件


## AWT 事件继承层次


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8