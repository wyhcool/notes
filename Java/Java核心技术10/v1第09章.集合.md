---
title: 集合
date: 2019-02-09 12:56:00
tags:
categories:
- Java
---

## Java 集合框架
### 将集合的接口与实现分离
Java 集合类库将接口(interface)与实现(implementation)分离。

以队列(queue)为例，队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象时，并按照“先进先出”的规则检索对象时就应该使用队列。
```java
public interface Queue<E> { // a simplified form of the interface in the standard library
    void add(E element);
    E remove();
    int size();
}
```
接口并没有说明队列是如何实现的，队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。

每一个实现都可以通过一个实现了 `Queue` 接口的类表示：
```java
public class CircularArrayQueue<E> implements Queue<E> { // not an actual library class
    private int head;
    private int tail;
    private E[] elements;

    CircularArrayQueue(int capacity) { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}

public class LinkedListQueue<E> implements Queue<E> { // not an actual library class
    private Link head;
    private Link tail;

    LinkedListQueue() { ... }
    public void add(E element) { ... }
    public E remove() { ... }
    public int size() { ... }
}
```
当在程序中使用队列时，一旦构建了集合，就无需知道实际使用了哪种实现。因此，只有在构造集合对象时，使用具体的类才有意义。可以使用接口类型来保存集合引用。
```java
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```
当使用 `LinkedListQueue` 是个更好的选择时，只需要对调用构造器的地方作出修改：
```java
Queue<Customer> expressLane = new LinkedListQueue<>();
expressLane.add(new Customer("Harry"));
```
接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此优先选择循环数组。然而，通常这样做也需要付出一定的代价。

循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。

### Collection 接口
在 Java 类库中，集合类的基本接口是 `Collection` 接口，这个接口有两个基本方法：
```java
package java.util;

public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
    Iterator<E> iterator();
    ...
}
```
`add` 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 `true`，如果集合没有发生变化就返回 `false`。

`iterator` 方法用于返回一个实现了 `Iterator` 接口的对象，可以使用这个迭代器对象依次访问集合中的元素。

### 迭代器
`Iterator` 接口包含 4 个方法：
```java
package java.util;

public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
通过反复调用 `next` 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，`next` 方法将抛出一个 `NoSuchElementException`。因此，需要在调用 `next` 之前调用 `hasNext` 方法。如果迭代器对象还有可供访问的元素，这个方法就返回 `true`。

如果想要查看集合中的所有元素，就请求一个迭代器：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext) {
    String elem = iter.next();
    // do something with elem
}
```

或者使用 `for each` 循环可以更加简练地表示同样的循环操作，编译器将 `for each` 循环翻译为带有迭代器的循环：
```java
Collection<String> c = ...;
for (String elem : c) {
     // do something with elem
}
```
`for each` 循环可以与任何实现了 `Iterable` 接口的对象一起工作，这个接口设计为：
```java
package java.lang;

public interface Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
`Collection` 接口扩展了 `Iterable` 接口，因此，对于标准类库中的任何集合都可以使用 `for each` 循环。

在 Java SE 8 中，甚至可以不用写循环。可以调用 `forEachRemaining` 方法并提供一个 `lambda` 表达式，将对迭代器的每一个元素调用这个 `lambda` 表达式，直到再没有元素为止：
```java
iterator.forEachRemaing(elem -> do something with elem);
```
元素被访问的顺序取决于集合类型。如果对 `ArrayList` 进行迭代，迭代器将从索引 0 开始，每迭代一次，索引值加 1；然后，如果访问 `HashSet` 中的元素，每个元素将会按照某种随机的次序出现，虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

Java 迭代器查找一个元素的唯一方法是调用 `next`，而在执行查找操作的同时，迭代器的位置随之向前移动。因此，可以将 Java 迭代器认为是两个元素之间。当调用 `next`时，迭代器就会越过下一个元素，并返回刚刚越过的那个元素的引用。

注意⚠️：可以将 `Iterator.next` 与 `InputStream.read` 看作为等效的。从数据流中读取一个字节，就会自动地消耗掉这个字节。下一次调用 `read` 将会消耗并返回输入的下一个字节。

`Iterator` 接口的 `remove` 方法将会删除上次调用 `next` 方法时返回的元素。在决定删除元素之前，需要先查看元素。但是，要删除特定位置的元素，则仍然需要跳过该元素：
```java
Iterator<String> it = c.iterator();
it.next(); // skip over the first element
it.remove(); // now remove it
```
更重要的是，对 `next` 方法和 `remove` 方法的调用具有互相依赖性。如果调用 `remove` 之前没有调用 `next` 将是不合法的。如果这样做，将会抛出一个 `IllegalStateException` 异常。

### 泛型实用方法
由于 `Collection` 与 `Iterator` 都是泛型接口，可以编写操作任何集合类型的实用方法。Java 类库设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用，这样，类库的使用者就不必自己重新构建这些方法了。

事实上，`Collection` 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
...
```
当然，如果每个实现 `Collection` 接口的类都必须提供这么多常规方法，那将是一件麻烦事。为了使实现者的工作更加轻松，Java 库提供了一个 `AbstractCollection` 类，该类保留基本方法 `size` 和 `iterator` 的抽象，但根据它们来实现常规方法。例如：
```java
public abstract class AbstractCollection<E>
    implements Collection<E> 
{
    ...
    public abstract Iterator<E> iterator();

    public boolean contains(Object obj) {
        for (E element: this) { // call iterator()
            if (element.equals(obj)) {
                return true;
            }
        }
        return false;
    }
    ...
}
```
此时，一个具体的集合类可以扩展 `AbstractCollection`，现在只需要由具体的集合类提供 `iterator` 方法，而 `contains` 方法已经由 `AbstractCollection` 超类提供了，但是如果子类有更加有效的方式实现 `contains` 方法，也可以由子类提供。

java.util.Collection\<E> 用到的方法：
- Iterator\<E> iterator()：返回一个用于访问集合中每个元素的迭代器。
- int size()：返回当前存储在集合中的元素个数。
- boolean isEmpty()：如果集合中没有元素，返回 `true`。
- boolean contains(Object obj)：如果集合中包含一个与 obj 相等的对象，返回 `true`。
- boolean containsAll(Collection\<?> other)：如果集合中包含 other 集合中的所有元素，返回 `true`。
- boolean add(Object element)：将一个元素添加到集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean addAll(Collection\<? extends E> other)：将 other 集合中的所有元素添加到这个集合中，如果由于这个调用改变了集合，返回 `true`。
- boolean remove(Object obj)：从这个集合中删除等于 obj 的对象，如果有匹配的对象被删除，返回 `true`。
- boolean removeAll(Collection\<?> other)：从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 `true`。
- default boolean removeIf(Predicate<? super E> filter)：从这个集合中删除 filter 返回 `true` 的所有元素。如果由于这个调用改变了集合，返回 `true`。
- void clear()：从这个集合中删除所有的元素。
- boolean retainAll(Collection\<?> other)：从这个集合中删除所有与 other 集合中的元素不同的元素。如果由于这个调用改变了集合，返回 `true`。
- Object\[] toArray()：返回这个集合的对象数组。
- \<T> T\[] toArray(T\[] arrayToFill)：返回这个集合的对象数组。如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null；否则，分配一个新数组，其成员类型与 arrayToFill 的成员类型相同，其长度等于集合的大小，并填充集合元素。

java.util.Iterator\<E> 用到的方法：
- boolean hasNext()：如果存在可访问的元素，返回 `true`。
- E next()：返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 `NoSuchElementException`。
- void remove()：删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`。

### 集合框架中的接口
Java 集合框架为不同类型的集合定义了大量接口：
```java
       Iterable
          |
     Collection               Map          Iterator     RandomAccess
__________|__________          |              |
|         |         |          |              |
List     Set     Queue     SortedMap      ListIterator
          |                    |
      SortedSet           NavigableMap
          | 
      NavigableSet
```
集合有两个基本接口：`Collection` 和 `Map`。

由于映射包含键 / 值对，要用 `put` 方法来插入：
```java
V put(K key, V value)
```
从映射中读取值则要使用 `get` 方法：
```java
V get(K key)
```

`List` 是一个有序集合(ordered collection)，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问(random access)，因为这样可以按照任意顺序访问元素。与之不同的是，使用迭代器访问时，必须顺序地访问元素。

`List` 接口定义了多个用于随机访问的方法：
```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

`ListIterator` 接口是 `Iterator` 的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素：
```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用 `List` 方法并提供一个整数索引来访问。与之不同的是，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。

为了避免对链表完成随机访问操作，Java SE 1.4 引入一个标记接口 `RandomAccess`，这个接口不包含任何方法，可以用它来测试一个特定的集合是否支持高效的随机访问：
```java
if (c instanceof RandomAccess) {
    // use random access algorithm
} else {
    // use sequential access algorithm
}
```

`Set` 接口等同于 `Collection` 接口，不过其方法的行为有更严谨的定义。集(Set)的 `add` 方法不允许添加重复的元素。要适当地定义集的 `equals` 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。`hashCode` 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

`SortedSet` 和 `SortedMap` 接口会提供用于排序的比较器对象，这两个接口定义了可到集合子集视图的方法。

Java SE 6 引入了接口 `NavigableSet` 和 `NavigableMap`，其中包含一些用于搜索和遍历有序集和映射的方法。`TreeSet` 和 `TreeMap` 类实现了这些接口。


## 具体的集合
除了以 Map 结尾的类之外，其他类都实现了 `Collection` 接口，而以 Map 结尾的类实现了 `Map` 接口。

| 集合类型 | 描述 |
|:-|:-|
| ArrayList | 一种可以动态增长和缩减的索引序列 |
| LinkedList | 一种可以在任何位置进行高效地插入和删除操作的有序序列 |
| ArrayDeque | 一种用循环数组实现的双端队列 |
| HashSet | 一种没有重复元素的无序集合 |
| TreeSet | 一种有序集 |
| EnumSet | 一种包含枚举类型值的集 |
| LinkedHashSet | 一种可以记住元素插入次序的集 |
| PriorityQueue | 一种允许高效删除最小元素的集合 |
| HashMap | 一种存储键／值关联的数据结构 |
| TreeMap | 一种键值有序排列的映射表 |
| EnumMap | 一种键值属于枚举类型的映射表 |
| LinkedHashMap | 一种可以记住键／值添加次序的映射表 |
| WeakHashMap | 一种其值无用武之地可以被垃圾回收器回收的映射表 |
| IdentityHashMap | 一种用 == 而不是用 equals 比较键值的映射表 |

### 链表
数组以及动态的 `ArrayList` 数组列表类都有一个重大的缺陷：当从中间位置删除/插入一个元素要付出很大的代价，其原因是数组中处于被删除/插入元素之后的所有元素都要向数组的前端/后端移动。

尽管数组在连续的存储位置上存放对象引用，但链表(linked list)却将每个对象存放在独立的结点中，每个结点还存放着下一个结点的引用。在 Java 程序设计语言中，所有链表实际上都是双向链接的(double linked) —— 即每个结点还存放着指向前驱结点的引用。

从链表中间删除一个元素只需要更新被删除元素附近的链接。

先添加 3 个元素，然后再将第 2 个元素删除：
```java
List<String> staff = new LinkedList<>(); // LinkedList implements list
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next(); // visit first element
String second = iter.next(); // visit second element
iter.remove(); // remove last visited element
```

链表与泛型集合之间的重要区别：链表是一个有序集合(ordered collection)，每个对象的位置十分重要。`LinkedList.add` 方法将对象添加到链表的尾部，但是常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖位置的 `add` 方法由迭代器负责，只有对自然有序的集合使用迭代其添加元素才有实际意义。

比如，集(set)类型，其中的元素完全无序，因此，在 `Iterator` 接口中就没有 `add` 方法。相反地，集合类库提供了子接口 `ListIterator`，其中包含 `add` 方法。
```java
package java.util;

public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}
```
与 `Collection.add` 不同，这个方法不返回 `boolean` 类型的值，它假定添加操作总会改变链表。

另外，`ListIterator` 接口有两个方法，可以用来反向遍历链表：
```java
boolean hasPrevious();
E previous();
```
与 `next` 方法一样，`previous` 方法返回越过的对象。

`LinkedList` 类的 `listIterator` 方法返回一个实现了 `ListIterator` 接口的迭代器对象，`add` 方法在迭代器位置之前添加一个新对象：
```java
List<String> staff = new LinkedList<>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next(); // skip pass first element
iter.add("Juliet"); // 在第二个元素之前添加
```
如果多次调用 `add` 方法，将按照提供的次序把元素添加到链表中，它们被依次添加到迭代器当前位置之前。

当用一个刚刚由 `listIterator` 方法返回，并且指向链表表头的迭代器调用 `add` 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即 `hasNext` 返回 `false`)，添加的元素将变成列表的新表尾。如果链表有 n 个元素，有 n+1 个位置可以添加新元素，这些位置与迭代器的 n+1 个可能的位置相对应。

注意⚠️：在调用 `next` 之后，`remove` 方法确实会删除迭代器左侧的元素。但是，如果调用 `previous` 之后，，`remove` 方法会删除迭代器右侧的元素，且不能连续调用两次 `remove`。

`add` 方法只依赖于迭代器的位置，而 `remove` 方法依赖于迭代器的状态。

`set` 方法用一个新元素取代调用 `next` 或 `previous` 方法返回的上一个元素。

如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状态。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个 `ConcurrentModificationException` 异常。

为了避免发生并发修改的异常，请遵循：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

检测到并发修改的问题的方法：集合可以跟踪改写操作（诸如添加或删除元素）的次数，每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己已经改写操作的计数值是否与集合的改写操作计数值一致，如果不一致，抛出一个 `ConcurrentModificationException` 异常。

注意⚠️：对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。`set` 方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用 `set` 方法对现有的结点的内容进行修改。

在 Java 类库中，还提供了许多在理论上存在一定争议的方法。比如链表不支持快速随机访问，如果要查看链表中第 n 个元素，就必须从头开始，越过 n-1 个元素，没有捷径可走。尽管如此，`LinkedList` 类还是提供了一个用来访问某个特定元素的 `get` 方法。

绝对不应该使用这种让人误解的随机访问方法来遍历链表。每次查找一个元素都要从列表的头部重新开始搜索，`LinkedList` 对象根本不做任何缓存位置信息的操作。

列表迭代器接口还有一个方法，可以告之当前为位置的索引。由于 Java 迭代器指向两个元素之间的位置，所以可以同时产生两个索引：`nextIndex` 方法返回下一次调用 `next` 方法时返回元素的整数索引；`previousIndex` 方法返回下一次调用 `previous` 方法时返回元素的整数索引。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。

如果有一个整数索引 n，那么 `list.listIterator(n)` 将返回一个迭代器，这个迭代器指向索引为 n 的元素前面的位置，也就是说，调用 `next` 与调用 `list.get(n)` 会产生同一个元素，只是获得这个迭代器的效率比较低。

如果链表中只有很少几个元素，就完全没有必要为 `get` 方法和 `set` 方法的开销而烦恼。

使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用 `ArrayList`。

避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就是用数组或 `ArrayList`，而不要使用链表。

java.util.List\<E> 用到的方法：
- ListIterator\<E> listIterator()：返回一个列表迭代器，以便用来访问列表中的元素。
- ListIterator\<E> listIterator(int index)：返回一个列表迭代器，以便用来访问列表中的元素，这个元素是第一次调用 `next` 返回的给定索引的元素。
- void add(int i, E element)：在给定位置添加一个元素。
- void addAll(int i, Collection\<? extends E> elements)：将某个集合中的所有元素添加到给定位置。
- E remove(int i)：删除给定位置的元素并返回这个元素。
- E get(int i)：获取给定位置的元素。
- E set(int i, E element)：用新元素取代给定位置的元素，并返回原来那个元素。
- int indexOf(Object element)：返回与指定元素相等的元素在列表中第一次出现的位置，如果没有这样的元素将返回 -1。
- int lastIndexOf(Object element)：返回与指定元素相等的元素在列表中最后一次出现的位置，如果没有这样的元素将返回 -1。

java.util.ListIterator\<E> 用到的方法：
- void add(E newElement)：在当前位置前添加一个元素。
- void set(E newElement)：用新元素取代 `next` 或 `previous` 上次访问的元素。如果在 `next` 或 `privious` 上次调用之后列表结构被修改了，将抛出一个 `IllegalStateException`。
- boolean hasPrevious()：当反向迭代列表时，还有可供访问的元素，返回 `true`。
- E previous()：返回前一个对象。如果已经到达了列表的头部，就抛出一个 `NoSuchElementException` 异常。
- int nextIndex()：返回下一次调用 `next` 方法时将返回的元素索引。
- int previousIndex()：返回下一次调用 `previous` 方法时将返回的元素索引。

java.util.LinkedList\<E> 用到的方法：
- LinkedList()：构造一个空链表。
- LinkedList(Collection\<? extends E> elements)：构造一个链表，并将集合中的所有元素添加到这个链表中。
- void addFirst(E element)
- void addLast(E element)：将某个元素添加到链表的头部或尾部。
- E getFirst()
- E getLast()：返回链表的头部或尾部的元素。
- E removeFirst()
- E removeLast()：删除并返回链表的头部或尾部的元素。

### 数组列表
`List` 接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。

有两种访问元素的协议：
- 迭代器
- `get` 和 `set` 方法随机访问

后者不适合链表，但对数组有用。

集合类库提供了 `ArrayList`，封装了一个动态再分配的对象数组。

注意⚠️：在需要动态数组时，可能会使用 `Vector` 类，`Vector` 类的所有方法都是同步的，可以由两个线程安全地访问一个 `Vector` 对象。但是，如果由一个线程访问 `Vector`，代码要在同步操作上耗费大量时间。而 `ArrayList` 方法不是同步的，因此，建议在不需要同步时使用 `ArrayList`。

### 散列集
散列表(hash table)为每个对象计算一个整数，称为散列码(hash code)，散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

如果自定义类，就需要负责实现这个类的 `hashCode` 方法。注意，自己实现的 `hashCode` 方法应该与 `equals` 方法兼容，即如果 `a.equals(b)` 为 `true`，a 与 b 必须具有相同的散列码。

最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。

在 Java 中，散列表用链表数组(arrays of linked lists)实现。每个列表被称为桶(bucket)。要向查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。

当计算出的桶中没有其他元素时，此时将元素直接插入桶中就可以了。当然，有时候会遇到桶被占满的情况，这也是不可避免的，这种现象被称为散列冲突(hash collision)。这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。
```
collision \[kəˈlɪʒn]n.碰撞(或相撞)事故; (两人之间或对立意见、看法等之间的) 冲突，抵触
```
如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。

在 Java SE 8 中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个相同散列码的值，这样就能提高性能。

如果想更多地控制散列表的性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果大致知道最终会有多少个元素要插入散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75% ~ 150%。另外，建议将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是 2 的幂，默认值是 16（为表大小提供的任何值都将被自动地转换为 2 的下一个幂）。

如果散列表太满，就需要再散列(rehashed)。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子(load factor)决定何时对散列表进行再散列。

如果装填因子是 0.75(默认值)，而表中超过 75% 的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。

散列表可以用于实现几个重要的数据结构。其中最简单的是 `set` 类型。`set` 是没有重复元素的元素集合，`set` 的 `add` 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

Java 集合类库提供了一个 `HashSet` 类，它实现了基于散列表的集。可以用 `add` 方法添加元素，`contains` 方法已经被重新定义，用来快速查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。

散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用 `HashSet`。

警告：在更改集中的元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化。

java.util.HashSet\<E> 用到的方法：
- HashSet()：构造一个空散列集。
- HashSet(Collection\<? extends E> elements)：构造一个散列集，并将集合中的所有元素添加到这个散列集中。
- HashSet(int initialCapacity)：构造一个空的具有指定容量(桶数)的散列集。
- HashSet(int initialCapacity, float loadFactor)：构造一个具有指定容量和装填因子(一个介于 0.0 ~ 1.0 之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集。

java.util.Object 用到的方法：
- int hashCode()：返回这个对象的散列码。散列码可以是任何整数，包括正数和负数。`equals` 和 `hashCode` 的定义必须兼容，即如果 `x.equals(y)` 为 `true`，`x.hashCode()` 必须等于 `y.hashCode()`。

### 树集
`TreeSet` 类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合(sorted collection)，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地敖着排序后的顺序呈现。

正如 `TreeSet` 类名所示，排序是用树结构完成的（当前实现使用的是红黑树(red-black tree)），每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比还是快很多。如果树中包含 n 个元素，查找新元素的正确位置平均需要 log<sub>2</sub>n 次比较。

要使用树集，必须能够比较元素。这些元素必须实现 `Comparable` 接口，或者构造集时必须提供一个 `Comparator`。

是否总是应该使用树集取代散列集？毕竟添加一个元素所话费的时间看上去并不是很长，而且元素是自动排序的。到底应该怎样做将取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象。

java.util.TreeSet\<E> 用到的方法：
- TreeSet()
- TreeSet(Comparator\<? super E> comparator)：构造一个空树集。
- TreeSet(Collection\<? extends E> elements)
- TreeSet(SortedSet\<E> s)：构造一个树集，并增加一个集合或有序集中的所有元素。

java.util.SortedSet\<E> 用到的方法：
- Comparator\<? super E> comparator()：返回用于对元素进行排序的比较器。如果元素使用 `Comparable` 接口的 `compareTo` 方法进行比较则返回 `null`。
- E first()
- E last()：返回有序集中的最小元素或最大元素。

java.util.NavigableSet\<E> 用到的方法：
- E higher(E value)
- E lower(E value)：返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E ceiling(E value)
- E floor(E value)：返回大于等于 value 的最小元素或小于等于 value 的最大元素，如果没有这样的元素则返回 `null`。
- E pollFirst()
- E pollLast()：删除并返回这个集中的最大元素或最小元素，这个集为空时返回 `null`。
- Iterator\<E> descendingIterator()：返回一个按照递减顺序遍历集中元素的迭代器。

### 队列与双端队列
队列可以在尾部添加一个元素，在头部删除一个元素。

有两个端头的队列，即双端队列，可以在头部和尾部同时添加或删除元素。

不支持在队列中间添加元素。

在 Java SE 6 中引入了 `Deque` 接口，并由 `ArrayDeque` 和 `LinkedList` 类实现，这两个类都提供了双端队列，而且在必要时可以增加队列的长度。

java.util.Queue\<E> 用到的方法：
- boolean add(E element)
- boolean offer(E element)：如果队列未满，则将给定元素添加到此双端队列的末尾并返回 `true`。 如果队列已满，则第一个方法将引发 `IllegalStateException`，而第二个方法将返回 `false`。
- E remove()
- E poll()：假设队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 `null`。
- E element()
- E peek()：如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法抛出 `NoSuchElementException`，而第二个方法返回 `null`。

java.util.Deque\<E> 用到的方法：
- void addFirst(E element)
- void addLast(E element)
- boolean offerFirst(E element)
- boolean offerLast(E element)：将给定的对象添加到双端队列的头部或尾部。如果队列已满，则前两个方法将引发 `IllegalStateException`，而后两个方法将返回 `false`。
- E removeFirst()
- E removeLast()
- E pollFirst()
- E pollLast()：假设队列不空，删除并返回这个双端队列头部或尾部的元素。如果队列是空的，前两个方法抛出 `NoSuchElementException`，而后两个方法返回 `null`。
- E getFirst()
- E getLast()
- E peekFirst()
- E peekLast()：如果队列不空，返回这个双端队列头部或尾部的元素，但不删除。如果队列空，前两个方法抛出 `NoSuchElementException`，而后两个方法返回 `null`。

java.util.ArrayDeque\<E> 用到的方法：
- ArrayDeque()
- ArrayDeque(int initialCapacity)：用初始容量 16 或给定的初始容量构造一个无限双端队列。

### 优先级队列
优先级队列(priority queue)中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用 `remove` 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆(heap)。堆是一个可以自我调整的二叉树，对树执行添加(add)和删除(remove)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。

与 `TreeSet` 一样，一个优先级队列既可以保存实现了 `Comparable` 接口的类对象，也可以保存在构造器中提供的 `Comparator` 对象。

使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除。(由于习惯上将 1 设为最高优先级，所以会将最小的元素删除)。

与 `TreeSet` 中的迭代不同，这里的迭代并不是按照元素的排列顺序访问的，而删除元素却总是删除掉剩余元素中优先级数最小的那个元素。

java.util.PriorityQueue 用到的方法：
- PriorityQueue()
- PriorityQueue(int initialCapacity)：构造一个用于存放 `Comparable` 对象的优先级队列。
- PriorityQueue(int initialCapacity, Comparator<? super E> c)：构造一个优先级队列，并用指定的比较器对元素进行排序。


## 映射
映射(map)用来存放键／值对。

### 基本映射操作
Java 类库为映射提供了两个通用的实现：`HashMap` 和 `TreeMap`，这两个类都实现了 `Map` 接口。

散列映射对键进行散列，树映射用键的整体顺序进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键相关的值不能进行散列或比较。

如何选择散列映射或树映射呢？与集一样，散列稍微快一些，如果不需要按照排列顺序访问键，就最好选择散列。

每当往映射中添加对象时，必须同时提供一个键。

要检索一个对象，必须使用一个键。

如果在映射中没有与给定键对应的信息，`get` 将返回 `null`。`null` 返回值可能并不方便，有时可以有一个好的默认值，用作映射中不存在的键，然后使用 `getOrDefault` 方法。

键必须是唯一的，不能对同一个键存放两个值，如果对同一个键两次调用 `put` 方法，第二个值就会取代第一个值，实际上，`put` 将返回用这个键参数存储的上一个值。

`remove` 方法用于从映射中删除给定键对应的元素。

`size` 方法用于返回映射中的元素数。

要迭代处理映射的键和值，最容易的方法是使用 `forEach` 方法，可以提供一个接收键和值的 lambda 表达式，映射中的每一项会依序调用这个表达式。

java.util.Map\<K, V> 用到的方法：
- V get(Object key)：获取与键对应的值，返回与键对应的对象，如果在映射中没有这个对象则返回 `null`，键可以为 `null`。
- default V getOrDefault(Object key, V defaultValue)：获得与键关联的值，返回与键关联的对象，或者如果未在映射中找到这个键，则返回 defaultValue。
- V put(K key, V value)：将键与对应的值插入映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象。这个方法将返回键对应的旧值，如果这个键以前没有出现过则返回 `null`。键可以为 null，但值不能为 `null`。
- void putAll(Map<? extends K, ? extends V> entries)：将给定映射中的所有条目添加到这个映射中。
- boolean containsKey(Object key)：如果映射中已经有这个键，返回 `true`。
- boolean containsValue(Object value)：如果映射中已经有这个值，返回 `true`。
- default void forEach(BiConsumer<? super K, ? super V> action)：对这个映射中的所有键／值对应用这个动作。

java.util.HashMap<K, V> 用到的方法：
- HashMap()
- HashMap(int initialCapacity)
- HashMap(int initialCapacity, float loadFactor)：用给定的容量和装填因子构造一个空散列映射。

java.util.TreeMap<K, V>  用到的方法：
- TreeMap()：为实现 `Comparable` 接口的键构造一个空的树映射。
- TreeMap(Comparator<? super K> c)：构造一个树映射，并使用一个指定的比较器对键进行排序。
- TreeMap(Map<? extends K, ? extends V> entries)：构造一个树映射，并将某个映射中的所有条目添加到树映射中。
- TreeMap(SortedMap<? extends K, ? extends V> entries)：构造一个树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器。

java.util.SortedMap<K, V> 用到的方法：
- Comparator<? super K> comparator()：返回对键进行排序的比较器，如果键是用 `Comparable` 接口的 `compareTo` 方法进行比较的，返回 `null`。
- K firstKey()
- K lastKey()：返回映射中最小键和最大键。

### 更新映射项
正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。

需注意，当键第一次出现时，`get` 方法会返回 `null`，因此会出现一个 `NullPointerException` 异常。作为一个简单的补救，可以使用 `getOrDefault` 方法：
```java
counts.put(word, counts.getOrDefault(word, 0) + 1);
```

另一种方法是首先调用 `putIfAbsent`，只有当键原先不存在时，才会放入一个值。
```java
counts.putIfAbsent(word, 0);
counts.put(word, counts.get(word) + 1);
```

更好的方式是使用 `merge` 方法来简化操作：
```java
counts.merge(word, 1, Integer::sum);
```
将把 word 与 1 关联，否则使用 `Integer::sum` 函数将原值与 1 求和。

java.util.Map<K, V> 用到的方法：
- default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：如果 key 与一个非 `null` 值 v 关联，将函数应用到 v 和 value，将 key 与结果关联，或者如果结果为 `null`，则删除这个键，否则将 key 与 value 关联，返回 `get(key)`。
- defualt V compute(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：将函数应用到 key 和 get(key)，将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default V computeIfPresent(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：如果 key 与一个非 `null` 值 v 关联，将函数应用到 key 和 v，将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default V computeIfAbsent(K key, BiFunction<? super V, ? super V, ? extends V> remappingFunction)：将函数应用到 key，除非 key 与一个非 `null` 值关联。将 key 与结果关联，或者如果结果为 null，则删除这个键，返回 `get(key)`。
- default void replaceAll(BiFunction<? super V, ? super V, ? extends V> remappingFunction)：在所有映射项上应用函数。将键与非 `null` 结果关联，对于 `null` 结果，则将相应的键删除。

### 映射视图
集合框架不认为映射本身是一个集合，不过，可以得到映射的视图(view)，这是实现了 `Collection` 接口或某个子接口的对象。

有 3 种视图：键集，值集合，以及键／值对集，键和键／值对可以构成一个集，因为映射中一个键只能有一个副本：
```java
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet() //条目集的元素是实现 Map.Entry 接口的类的对象
```
注意⚠️：`keySet` 不是 `HashSet` 或 `TreeSet`，而是实现了 `Set` 接口的另外某个类的对象，`Set` 接口扩展了 `Collection` 接口，因此，可以像使用集合一样使用 `keySet`。

枚举一个映射的所有键：
```java
Set<String> keys = map.keySet();
for (String key : keys) {
    // do something with key
}
```

同时查看键和值，可以通过枚举条目来避免查找值：
```java
for (Map.Entry(String, Employee) entry : staff.entrySet()) {
    String k = entry.getKey();
    Employee v = entry.getValue();
    // do something with k, v
}

// 原先这是访问所有映射条目的最高效的方法，但是，现在只需要使用 forEach 方法
```

如果在键集视图上调用迭代器的 `remove` 方法，实际上会从映射中删除这个键和与它关联的值，但是，不能向键集视图增加元素。另外，如果增加一个键而没有同时增加值也是没有意义的，如果试图调用 `add` 方法，它会抛出一个 `UnsupportedOperationException`。

对于条目集视图也有同样的限制。

java.util.Map\<K, V> 用到的方法：
- Set\<Map.Entry<K, V>> entrySet()：返回 `Map.Entry` 对象（映射中的键／值对）的一个集视图，可以从这个集合中删除元素，它们将从映射中删除，但是不能增加任何元素。
- Set\<K> keySet()：返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但是不能增加任何元素。
- Collection\<V> values()：返回映射中所有值的一个集合视图，可以从这个集合中删除元素，所删除的值及相应的键从映射中删除，但是不能增加任何元素。

java.util.Map.Entry\<K, V> 用到的方法：
- K getKey()
- V getValue()：返回这一条目的键或值。
- V setValue(V newValue)：将相关映射中的值改为新值，并返回原来的值。

### 弱散列映射
设计 `WeakHashMap` 类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了，将会出现什么情况？假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现过这个键，所以，这个键／值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？难道删除无用的对象不是垃圾回收器的工作吗？

遗憾的是，垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。因此，需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用 `WeakHashMap` 完成这件事情。当对键的唯一引用来自散列条目时，这一数据结构将于垃圾回收器协同工作一起删除键／值对。

`WeakHashMap` 使用弱引用(weak references)保存键。`WeakReference` 对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。

通常垃圾回收器发现某个特定的对象已经没有其他引用了，就将其回收。然而，如果某个对象只能由 `WeakReference` 引用，垃圾回收器仍然要回收它，但是要将引用这个对象的弱引用放入队列中。`WeakHashMap` 将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来，然后，`WeakHashMap` 将删除对应的条目。

### 链接散列集与映射
`LinkedHashSet` 和 `LinkedHashMap` 类用来记住插入元素项的顺序，这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。

链接散列映射将使用访问顺序，而不是插入顺序，对映射条目进行迭代。每次调用 `get` 或 `put`，受到影响的条目将从当前的位置删除，并放到条目链表的尾部（只有条目在链表中的位置会受影响，而散列表中的桶不会受影响，一个条目总位于与键散列码对应的桶中）。

访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取，当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉，这些是近期最少使用的几个元素。

存放 100 个元素的高速缓存，每当方法返回 `true` 时，就添加一个新条目，从而导致删除 `eldest` 条目：
```java
Map<K, V> cache = new LinkedHashMap<>(128, 0.75F, true) {
    protected boolean removeEldestEntry(Map.Entry(K, V) eldest) {
        return size() > 100;
    }
};
```

### 枚举集与映射
`EnumSet` 是一个枚举类型元素集的高效实现，由于枚举类型只有有限个实例，所以 `EnumSet` 内部用位序列实现。如果对应的值在集中，则相应的位置被置为 1。

`EnumSet` 类没有公共的构造器，可以使用静态工厂方法构造这个集：
```java
enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };

public static void main(String[] args) {

    EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
    EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
    EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
    EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);

}
```
可以使用 `Set` 接口的常用方法来修改 `EnumSet`。

`EnumMap` 是一个键类型为枚举类型的类型，它可以直接且高效地使用一个值数组实现，在使用时，需要在构造器中指定键类型：
```java
EnumMap<Weekday, Employee> personInCharge = new EnumMap<>(Weekday.class);
```

注意：`E extends Enum<E>` 这样的类型参数表示 E 是一个枚举类型，所有的枚举类型都扩展于泛型 `Enum` 类。

### 标识散列映射
类 `IdentityHashMap` 有特殊的作用，在这个类中，键的散列值不是用 `hashCode` 函数计算的，而是用 `System.identityHashCode` 方法计算的，这是 `Object.hashCode` 方法根据对象的内存地址来计算散列码时所使用的方式，而且，在对两个对象进行比较时，`IdentityHashMap` 类使用 `==`，而不使用 `equals`。

也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。

在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。


## 视图与包装器
通过使用视图(views)可以获得其他的实现了 `Collection` 接口和 `Map` 接口的对象。映射类的 `keySet` 方法就是这样的一个示例，初看起来，好像是这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此，取而代之的是：`keySet` 方法返回一个实现 `Set` 接口的类对象，这个类的方法对原映射进行操作，这种集合称为视图。

### 轻量级集合包装器
`Arrays` 类的静态方法 `asList` 将返回一个包装了普通 Java 数组的 `List` 包装器，这个方法可以将数组传递给一个期望得到列表或集合参数的方法：
```java
Card[] cardDeck = new Card[52];
...
List<Card> cardList = Arrays.asList(cardDeck);
```
返回的对象不是 `ArrayList`，它是一个视图对象，带有访问底层数组的 `get` 和 `set` 方法。改变数组大小的所有方法（例如，与迭代器相关的 `add` 和 `remove` 方法）都会抛出一个 `UnsupportedOperationException` 异常。

`asList` 方法可以接收可变数目的参数：
```java
List<String> names = Arrays.asList("Amy", "Bob", "Carl");
```

方法调用 `Collections.nCopies(n, anObject)` 将返回一个实现了 `List` 接口的不可修改对象，并给人一种包含 n 个元素，每个元素都像是一个 `anObject` 的错觉。
```java
List<String> settings = Collections.nCopies(100, "DEFAULT");
```
存储代价很小，这是视图技术的一种巧妙应用。

注意：`Collections` 类包含很多实用方法，这些方法的参数与返回值都是集合，不要与 `Collection` 接口混淆起来。

方法调用 `Collections.singleton(anObject)` 则将返回一个视图对象，这个对象实现了 `Set` 接口，返回的对象实现了一个不可修改的单元素集，而不需要付出数据结构的开销。

对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等：
```java
Set<String> deepThoughts = Collections.emptySet();
```

### 子范围
可以为很多集合建立子范围(subrange)视图。

可以使用 `subList` 方法来获得一个列表的子范围视图：
```java
List group2 = staff.subList(10, 20);//左闭右开，与String.substring类似
```
可以将任意操作应用在子范围上，并且能够自动地反应整个列表的情况：
```java
group2.clear(); // staff reduction
```
现在，元素自动地从 `staff` 列表中清除了，并且 `group2` 为空。

对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围。`SortedSet` 接口声明了 3 个方法，这些方法将返回大于等于 `from` 且小于 `to` 的所有元素子集：
```java
SortedSet<E> subSet(E from, E to)
SortedSet<E> headSet(E to)
SortedSet<E> tailSet(E from)
```

有序映射也有类似的方法，返回映射视图，该映射包含键落在指定范围内的所有元素：
```java
SortedMap<K, V> subMap(K from ,K to)
SortedMap<K, V> headMap(K to)
SortedMap<K, V> tailMap(K from)
```

Java SE 6 引入的 `NavigableSet` 接口赋予子范围操作更多的控制能力，可以指定是否包括边界：
```java
Navigable<Set> subSet(E from, boolean fromInclusive, E to, boolean toInclusive)
Navigable<Set> headSet(E to, boolean toInclusive)
Navigable<Set> tailSet(E from, boolean fromInclusive)
```

### 不可修改的视图
`Collections` 有几个方法用于产生集合的不可修改视图(unmodifiable views)，这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改，就抛出一个异常，同时这个集合将保持未修改的状态。
```java
Collections.unmodifiableCollection
Collections.unmodifiableList
Collections.unmodifiableSet
Collections.unmodifiableSortedSet
Collections.unmodifiableNavigableSet
Collections.unmodifiableMap
Collections.unmodifiableSortedMap
Collections.unmodifiableNavigableMap
```
每个方法都定义于一个接口，例如 `Collections.unmodifiableList` 与 `ArrayList`、`LinkedList` 或者任何实现了 `List` 接口的其他类一起协同工作。

假设想要查看某部分代码，但又不触及某个集合的内容，就可以进行下列操作：
```java
List<String> staff = new LinkedList<>();
...
lookAt(Collections.unmodifiableList(staff));
```
`Collections.unmodifiableList` 方法将返回一个实现 `List` 接口的类对象，其访问器方法将从 `staff` 集合中获取值，当然，`lookAt` 方法可以调用 `List` 接口中的所有方法，而不只是访问器，但是所有的更改器方法已经被重新定义为抛出一个 `UnsupportedOperationExeption` 异常，而不是将调用传递给底层集合。

不可修改视图并不是集合本身不可修改，仍然可以通过集合的原始引用（在这里是 `staff`）对集合进行修改，并且仍然可以让集合的元素调用更改器方法。

由于视图只是封装了接口而不是实际的对象，所以只能访问到接口中定义的方法。例如 `LinkedList` 类有一些非常方便的方法，`addFirst` 和 `addLast`，它们都不是 `List` 接口的方法，不能通过不可修改视图进行访问。

注意⚠️：`unmodifiableCollection` 方法与 `synchronizedCollection` 和 `checkedCollection` 方法一样将返回一个集合，它的 `equals` 方法不调用底层集合的 `equals` 方法，相反，它继承了 `Object` 类的 `equals` 方法，这个方法只是检测两个对象是同一个对象。如果将集或列表转成集合，就再也无法检测其内容是否相同了。

视图就是以这种方式运行，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理 `hashCode` 方法。

然而，`unmodifiableSet` 类和 `unmodifiableList` 类却使用底层集合的 `equals` 方法和 `hashCode` 方法。

### 同步视图
如果由多个线程访问集合，就必须确保集不会被任意的地破坏。

类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。例如，`Collections` 类的静态 `synchronizedMap` 方法可以将任何一个映射表转换成具有同步访问方法的 `Map`：
```java
Map<String, Employee> map = Collections.synchronizedMap(new hashMap<String, Employee>());
```
现在就可以由多线程访问 `map` 对象了，`get` 和 `put` 方法都是同步操作的，即在另一个线程调用另一个方法之前，之前的方法调用必须彻底完成。

### 受查视图
受查视图用来对泛型类型发生问题时提供调试支持。

例如，将错误类型的元素混入泛型集合中的问题极有可能发生：
```java
ArrayList<String> strings = new ArrayList<>();
ArrayList rawList = strings; // warning only, not an error, for compatibility 兼容性 with legacy 遗留 code
rawList.add(new Date()); // now strings contains a Date object!
```
这个错误的 `add` 命令在运行时检测不到，相反，只有在稍后的另一部分代码中调用 `get` 方法，并将结果转化为 `String` 时，这个类才会抛出异常。

受查视图可以探测到这些问题，可以定义一个安全列表：
```java
List<String> safeStrings = Collections.checkedList(strings, String.class);
```
视图的 `add` 方法将检测插入的对象是否属于给定的类，如果不属于给定的类，就立即抛出一个 `ClassCastException` 异常，这样做的好处是错误可以在正确的地方得以报告。

警告⚠️：受查视图受限于虚拟机可以运行的运行时检查。例如，对于 `ArrayList<Pair<String>>`，由于虚拟机有一个单独的原始 `Pair` 类，所以，无法阻止插入 `Pair<Date>`。

### 关于可选操作的说明
通常，视图有一些局限性，即可能只可以读、无法改变大小、只支持删除而不支持插入，这些与映射的键视图情况相同。如果视图进行不恰当的操作，受限制的视图就会抛出一个 `UnsupportedOperationExeption`。

在集合和迭代器接口的 `API` 文档中，许多方法描述为“可选操作”，这看起来与接口的概念有所抵触，毕竟，接口的设计目的难道不是负责给出一个类必须实现的方法吗？确实，从理论角度看，在这里给出的方法很难令人满意。一个更好的解决方案是为每个只读视图和不能改变集合大小的视图建立各自独立的两个接口。不过，这将会使接口的数量成倍增长，这让类库设计者无法接受。


## 算法
泛型集合接口有一个很大的优点，即算法只需要实现一次。

例如，考虑一个计算集合中的最大元素的算法，在数组中、数组列表中、链表中都会用到这个算法，因此，可以将 `max` 方法实现为能够接收任何实现了 `Collection` 接口的对象：
```java
public static <T extends Comparable> T max(Collection<T> c) {
    if (c.isEmpty()) throw new NoSuchElementException();
    Iterator<T> iter = c.iterator();
    T largest = iter.next();
    if (iter.hasNext()) {
        T next = iter.next();
        if (largest.compareTo(next) < 0) {
            largest = next;
        }
    }
    return largest;
}
```

### 排序与混排
`Collections` 类中的 `sort` 方法对实现了 `List` 接口的集合进行排序：
```java
List<String> staff = new LinkedList();
// fill collection
Collections.sort(staff);
```
这个方法假定列表元素实现了 `Comparable` 接口。

可以采用其他方式对列表进行排序，可以使用 `List` 接口的 `sort` 方法并传入一个 `Comparator` 对象，例如可以按照工资对一个员工列表进行排序：
```java
staff.sort(Comparator.comparingDouble(Employee::getSalary));
```

如果按照降序对列表进行排序，可以使用静态方法 `Collections.reverseOrder()`，。这个方法将返回一个比较器，比较器则返回 `b.compareTo(a)`：
```java
staff.sort(Comparator.reverseOrder());
```
这个方法将根据元素类型对 `compareTo` 方法给定排序顺序，按照逆序对列表 `staff` 进行排序。

同样，如下方式将按工资逆序排序：
```java
staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());
```

`sort` 方法采用对排序手段是归并排序，在 Java 程序设计语言中直接将所有元素转入一个数组，对数组进行排序，再将排序后对数组复制回列表。

集合类库中使用对排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。

因为集合不需要实现所有的可选方法，因此，所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。例如，显然不能将 `unmodifiableList` 列表传递给排序算法。可以传递什么类型的列表呢？根据文档定义，列表必须是可修改的，但不必是可以改变大小的。
- 如果列表支持 `set` 方法，则是可修改的。
- 如果列表支持 `add` 和 `remove` 方法，则是可改变大小的。

`Collections` 类中有一个算法 `shuffle`，其功能与排序刚好相反，即随机地混排列表中元素的顺序：
```java
ArrayList<Card> cards = ...;
Collections.shuffle(catds);
```
shuffle \[ˈʃʌfl] v.拖着脚走; (笨拙或尴尬地) 把脚动来动去; 坐立不安; 洗(牌);

如果提供的列表没有实现 `RandomAccess` 接口，`shuffle` 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。

### 二分查找
`Collections` 类的 `binarySearch` 方法实现了二分查找算法，注意：集合必须是排好序的，否则算法将返回错误的答案。要想查找某个元素，必须提供集合(这个集合要实现 `List` 接口)以及要查找的元素。如果集合没有采用 `Comparable` 接口的 `compareTo` 方法进行排序，还需要提供一个比较器对象：
```java
i = Collections.binarySearch(c, element);
i = Collections.binarySearch(c, element, comparator);
```
如果 `binarySearch` 方法返回的数值大于等于 0，则表示匹配对象的索引。也就是说，`c.get(i)` 等于在这个比较顺序下的 `element`。如果返回负值，则表示没有匹配的对象，但是可以利用返回值计算应该将 `element` 插入到集合的哪个位置，以保持集合的有序性。插入的位置是：
```java
insertionPoint = -i - 1;
```
注意： 当 i 为 0 时，位置是不确定的。也就是说，要将元素插入到正确的位置：
```java
if (i < 0) {
    c.add(-i - 1, element);
}
```

只有采用随机访问，二分查找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置，二分查找就完全失去了优势。

从有序列表中搜索一个键，如果元素扩展了 `AbstractSequentialList` 类，则采用线性查找，否则将采用二分查找。

### 简单算法
java.util.Collections 的常用算法：
- static \<T extends Comparable\<? super T>> T min(Collection\<T> elements)
- static \<T extends Comparable\<? super T>> T max(Collection\<T> elements)
- static \<T> T min(Collection\<T> elements, Comparator\<? super T> c)
- static \<T> T max(Collection\<T> elements, Comparator\<? super T> c)：返回集合中组小的或最大的元素。
- static \<T> void copy(List\<? super T> to, List\<T> from)：将原列表中的所有元素复制到目标列表的相应位置上，目标列表长度至少与原列表一样。
- static \<T> void fill(List\<? super T> l, T value)：将列表中所有位置设置为相同的值。
- static \<T> boolean addAll(Collection\<? super T> c, T... values)：将所有的值添加到集合中。如果结合改变了，则返回 `true`。
- static \<T> boolean replaceAll(List\<T> l, T oldValue, T newValue)：用 `newValue` 取代所有值为 `oldValue` 的元素。
- static int indexOfSubList(List\<?> l, List<?> s)
- static int lastIndexOfSubList(List\<?> l, List<?> s)：返回 l 中第一个或最后一个等于 s 子列表的索引。如果 l 中不存在等于 s 的子列表，则返回 -1。
- static void swap(List\<?> l, int i, int j)：交换给定偏移量的两个元素。
- static void reverse(List\<?> l)：逆序列表中元素的位置。
- static void rotate(List\<?> l, int d)：旋转列表中的元素，将索引 i 的条目移动至位置 `(i + d) % l.size()`。
- static int frequency(Collection\<?> c, Object o)：返回 c 中与对象 o 相同的元素个数。
- boolean disjoint(Collection\<?> c1, Collection\<?> c2)：如果两个集合没有共同的元素，则返回 `true`。

java.util.Collection\<T> 用到的方法：
- default boolean removeIf(Predicate\<? super E> filter)：删除所有匹配的元素。

java.util.List\<E> 用到的方法：
- default void repleceAll(UnaryOperator\<E> op)：对这个列表的所有元素应用这个操作。

### 批操作
很多操作会“成批”复制或删除元素。

```java
// 从 coll1 中删除 coll2 中出现的所有元素
coll1.removeAll(coll2);

// 从 coll1 中删除所有未在 coll2 中出现的元素
coll1.retainAll(coll2)
```

假设希望找到两个元素的交集(intersection)：
```java
// 建立一个新集来存放结果
// 每一个集合都有这样一个构造器，其参数是包含初始值的另一个集合
Set<String> result = new HashSet<>(a);

// 使用 retainAll，保留恰好也在 b 中出现的所有元素
// 这样就构成了交集，而无需编写循环
result.retainAll(b);
```

进一步地，对视图应用一个批操作，假设有一个映射，将员工 ID 映射到员工对象，而且建立了一个将不再聘用的所有员工的 ID：
```java
Map<String, Employee> staffMap = ...;
Set<String> terminatedIDs = ...;

// 直接建立一个键集，并删除终止聘用关系的所有员工的 ID
staffMap.keySet().removeAll(terminatedIDs);
```
由于键集是映射的一个视图，所以与键相关联的员工名会自动从映射中删除。

通过使用一个子范围视图，可以把批操作限制在子列表和子集上。假设，希望把一个列表的前 10 个元素增加到另一个容器，可以建立一个子列表选出前 10 个元素：
```java
relocated.addAll(staff.subList(0, 10));
```
这个子范围还可以完成更改操作：
```java
staff.subList(0, 10).clear();
```

### 集合与数组的转换
把一个数组转换为集合，`Arrays.asList` 包装器可以实现这个达到这个目的：
```java
String[] values = ...;
HashSet<String> staff = new HashSet<>(Arrays.asList(values));
```

从集合得到数组会更苦难一些，可以使用 `toArray` 方法：
```java
Object[] values = staff.toArray();
```
这样做的结果是一个对象数组，尽管你知道集合中包含一个特定类型的对象，但不能使用强制类型转换：
```java
String[] values = (String[]) staff.toArray(); // Error!
```
`toArray` 方法返回的是一个 `Object[]` 数组，不能改变它的类型。实际上，必须使用 `toArray` 方法的一个变体形式，提供一个所需类型而且长度为 0 的数组，这样以来，返回的数组就会创建为相同的数组类型：
```java
String[] values = staff.toArray(new String[0]);
```
可以构造一个指定大小的数组，这样就不会创建新数组：
```java
staff.toArray(new String[staff.size()]);
```

### 编写自己的算法
编写自己的算法，应该尽可能地使用接口，而不要使用具体的实现。

假设用一组菜单填充 `JMenu`：
```java
void fillMenu(JMenu menu, ArrayList<JMenuItem> items) {
    for (JMenuItem item : items) {
        menu.add(item);
    }
}
```
这样会限制方法的调用程序，即调用程序必须在 `ArrayList` 中提供选项。如果这些项放在一个另一个容器中，首先必须对它们重新包装，因此，最好接受一个更加通用的集合。

什么是完成这项工作的最通用的集合接口？在这里，只需要访问所有的元素，这是 `Collection` 接口的基本功能：
```java
void fillMenu(JMenu menu, Collection<JMenuItem> items) {
    for (JMenuItem item : items) {
        menu.add(item);
    }
}
```

如果编写了一个返回集合的方法，可能还想要一个返回接口，而不是返回类的方法，因为这样做可以在之后改变想法，并用另一个集合重新实现这个方法。

比如，返回所有菜单项的方法 `getAllItems`：
```java
List<JMenuItem> getAllItems(JMenu menu) {
    List<JMenuItem> items = new ArrayList<>();
    for (int i = 0; i < menu.getItemCount(); i++) {
        items.add(menu.getItem(i))
    }
    return items;
}
```
假设不复制所有的菜单项，而仅仅提供这些菜单项的视图，只需要使用 `AbstractList` 的匿名子类：
```java
List<JMenuItem> getAllItems(final JMenu menu) {
    return new AbstractList<>() {
        public JMenuItem get(int i) {
            return menu.getIem(i);
        }
        public int size() {
            return menu.getItemCount();
        }
    };
}
```


## 遗留的集合
从 Java 第 1 版问世以来，在集合框架出现之前已经存在大量的 “遗留的” 容器类。

### Hashtable 类
`Hashtable` 类与 `HashMap` 类的作用一样，它们拥有相同的接口。

与 `Vector` 类的方法一样，`Hashtable` 的方法也是同步的。

如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 `HashMap`。

如果需要并发访问，则要使用 `ConcurrentHashMap`。

### 枚举
遗留集合使用 `Enumeration` 接口对元素序列进行遍历。`Enumeration` 接口有两个方法，即 `hasMoreElements` 和 `nextElement`，这两个方法与 `Iterator` 接口的 `hasNext` 方法和 `next` 方法十分类似。

例如，`Hashtable` 类的 `elements` 方法将产生一个用于描述表中各个枚举值的对象：
```java
Enumeration<Employee> e = staff.elements();
while (e.hasMoreElements()) {
    Employee e = e.nextElement();
}
```
静态方法 `Collections.enumeration` 将产生一个枚举对象，枚举集合中的元素：
```java
List<InputStream> streams = ...;
SequenceInputStream in = new SequenceInputStream(Collections.enumeration(streams)); //the SequenceInputStream constructor expects an enumeration
```

### 属性映射
属性映射(property map)是一个类型非常特殊的映射结构，它有 3 个特性：
- 键与值都是字符串。
- 表可以保存到一个文件中，也可以从文件中加载。
- 使用一个默认的辅助表。

实现属性映射的 Java 平台类称为 `Properties`。

属性映射通常用于程序的特殊配置选项。

java.util.Properties 类用到的方法：
- Properties()：创建一个空的属性映射。
- Properties(Properties defaults)：创建一个带有一组默认值的空的属性映射。
- String getProperty(String key)：获得属性的对应关系，返回与键对应的字符串。如果在映射中不存在，返回默认表中与这个键对应的字符串。
- String getProperty(String key, String defaultValue)：获得在键没有找到时具有的默认值属性，它将返回与键对应的字符串，如果在映射中不存在，就返回默认的字符串。
- void load(InputStream in)：从 `InputStream` 加载属性映射。
- void store(OutputStream out, String commentString)：把属性映射存储到 `OutputStream`。

### 栈
从 1.0 版本开始，标准类库中就包含了 `Stack` 类，其中有 `push` 方法和 `pop` 方法。但是，`Stack` 类扩展为 `Vector` 类，从理论角度看，它可以让栈使用不属于栈操作的 `insert` 和 `remove` 方法，即可以在任何地方进行插入或删除操作，而不仅仅在栈顶。

java.util.Stack\<E> 用到的方法：
- E push(E item)：将 item 压入栈并返回 item。
- E pop()：弹出并返回栈顶 item。如果栈为空，请不要调用这个方法。
- E peek()：返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法。

### 位集
Java 平台的 `BitSet` 类用于存放一个位序列(它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列就可以使用位集。由于位集将位包装在字节里，所以，使用位集要比使用 `Boolean` 对象的 `ArrayList` 更加高效。

`BitSet` 类提供了一个便于读取、设置或清除各个位的接口。使用这个接口可以避免屏蔽或其他麻烦的位操作，如果将这些位存储在 `int` 或 `long` 变量中就必须进行这些繁琐的操作。

对于一个名为 `bucketOfBits` 的 `BitSet`：
```java
// 如果第 i 位处于 开 状态，就返回 true；否则返回 false
bucketOfBits.get(i);

// 将第 i 位置为 开 状态
bucketOfBits.set(i);

// 将第 i 位置为 关 状态
bucketOfBits.clear(i);
```

java.util.BitSet 用到的方法：
- BitSet(int initialCapacity)：创建一个位集。
- int length()：返回位集的逻辑长度，即 1 加上位集的最高设置为的索引。
- boolean get(int bit)：获得一个位。
- void set(int bit)：设置一个位。
- void clear(int bit)：清除一个位。
- void and(BitSet set)：这个位集与另一个位集进行逻辑 `AND`。
- void or(BitSet set)：这个位集与另一个位集进行逻辑 `OR`。
- void xor(BitSet set)：这个位集与另一个位集进行逻辑 `XOR`。
- void andNot(BitSet set)：清除这个位集中对应另一个位集中设置的所有位。


#### 埃拉托色尼筛选法(质数筛选算法)
埃拉托色尼筛选法(the Sieve of Eratosthenes)简称埃氏筛法，是古希腊数学家埃拉托色尼(Eratosthenes 274B.C.～194B.C.)提出的一种筛选法。是针对自然数列中的自然数而实施的，用于求一定范围内的质数。

sieve 美\[sɪv] n.滤器; 筛子; 笊篱; 漏勺;

质数(prime number)也叫素数，为大于 1 的且除 1 和本身以外不再有其他因数的自然数，与之相对的是合数。质数有无限个。

质数的性质：
- 质数只有两个因数：1 和本身
- 任何大于 1 的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的
- 质数的个数是无限多的
- 若 n 为正整数，在 n² 到 (n+1)² 之间至少有一个质数
- 若 n 为大于等于 2 的正整数，则 n 到 n! 之间至少有一个质数
- 若质数 p 为不超过 n(n≥4) 的最大质数，则 p ＞ n/2
- 所有大于 10 的质数中，个位数只有 1，3，7，9

埃拉托色尼筛选法基于一项基本性质：任何大于 1 的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的。

假设从起点开始（起点可由要求指定）的所有数都是质数。从起点开始向前搜寻，若为质数，则将其倍数（不超过上界 n）标记为非质数。例如 2 为质数，则标记 4，6，8, ...这些 2 的倍数都为非质数，然后标记下一个 …… 依此类推。

埃氏筛法步骤：
- （1）先把1删除（现今数学界1既不是质数也不是合数）
- （2）读取队列中当前最小的数2，然后把2的倍数删去
- （3）读取队列中当前最小的数3，然后把3的倍数删去
- （4）读取队列中当前最小的数5，然后把5的倍数删去
- （5）读取队列中当前最小的数7，然后把7的倍数删去
- （6）如上所述直到需求的范围内所有的数均删除或读取


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8

## 附属
### Java 中 Comparable 和 Comparator 比较
`Comparable` 是排序接口，若一个类实现了 `Comparable` 接口，就意味着该类支持排序。

而 `Comparator` 是比较器接口，我们若需要控制某个类的次序，可以建立一个该类的比较器来进行排序。

`Comparable` 相当于内部比较器，而 `Comparator` 相当于外部比较器。

两种方法各有优劣，用 `Comparable` 简单，只要实现 `Comparable` 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。用 `Comparator` 的好处是不需要修改源代码，而是另外实现一个比较器，当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了，并且在 `Comparator` 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。