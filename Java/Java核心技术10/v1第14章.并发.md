---
title: 并发
date: 2019-03-22 10:40:00
tags:
categories:
- Java
---

操作系统的多任务(multitasking)是指在同一时刻运行多个程序的能力。

多线程程序是在较低的层次上扩展了多任务(multitasking)的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

多进程与多线程有哪些区别呢？本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在某些操作系统中，与进程相比较，线程更轻量级，创建、撤销一个线程比启动新进程的开销要小得多。

## 什么是线程
调用 `Thread.sleep` 方法不会创建一个新线程，而是用于暂停当前线程的活动。`sleep` 方法可以抛出一个 `InterruptedException` 异常。

在没有使用多线程时，用户很难让它执行多个任务。必须等待上一个过程执行完毕才能与程序进行交互。

### 使用线程给其他任务提供机会
可以将移动球的代码放置在一个独立的线程中，运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球，每个球都在自己的线程中运行。

另外，AWT 的事件分配线程(event dispatch thread)将一直地并行运行，以处理用户界面的事件。由于每个线程都有机会得以运行，所在在球弹跳期间，当用户点击 Close 按钮时，事件调度线程将有机会关注到这个事件，并处理关闭动作。

通常，需要警惕任何长时间运行的计算，这计算可能是更大的框架（例如 GUI 或 Web 框架）的一部分。每当框架调用方法时，通常都会期望快速的返回。如果需要执行任何耗时的任务，则应当并发地运行任务。

在一个单独地线程中执行一个任务的过程：
1) 将任务代码移到实现了 `Runnable` 接口的类的 `run` 方法中，这个接口只有一个方法，是一个函数式接口，可以用 lambda 表达式建立一个实例：
```java
public interface Runnable {
    void run();
}

Runnable r = () -> { /* task code */ }
```
2) 由 `Runnable` 创建一个 `Thread` 对象：
```java
Thread t = new Thread(r);
```
3) 启动线程：
```java
t.start();
```

将弹跳球代码放在一个独立的线程中，只需要实现一个类 `BallRunnable`，然后将动画代码放在 run 方法中：
```java
new Thread(()-> {
    try {
        for (int i = 1; i <= STEPS; i++) {
            ball.move(comp.getBounds());
            comp.repaint();
            Thread.sleep(DELAY);
        }
    } catch (InterruptedException e) {

    }
}).start();
```
在一般情况下，线程在中断时被终止。因此，当发生 `InterruptedException` 异常时，`run` 方法将结束执行。

应该将要并行运行的任务与运行机制解耦合，如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。

警告⚠️：不要调用 `Thread` 类或 `Runnable` 对象的 `run` 方法。直接调用 `run` 方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 `Thread.start` 方法，这个方法将创建一个执行 `run` 方法的新线程。


## 中断线程
当线程的 `run` 方法执行方法体中最后一条语句后，并经由执行 `return` 语句返回，或者出现了在方法中没有捕获的异常时，线程将终止。

在 Java 的早期版本中，有一个 `stop` 方法，另一个线程可以调用该方法来终止线程，但是这个方法现在已经被废弃。

除了不推荐使用的 `stop` 方法之外，没有其他方法可以强制线程终止。但是，`interrupt` 中断方法可用于请求线程终止。

当对一个线程调用 `interrupt` 方法时，线程的中断状态(interrupted status)将被置位，这是每一个线程都具有的 `boolean` 标志，每个线程都应不时地检查这个标志，以判断线程是否被中断。

判断中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法：
```java
while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
    // do more work
}
```
但是，线程如果被阻塞，就无法检测中断状态，这是产生 `InterruptedException` 异常的地方。当在一个被阻塞的线程(调用 `sleep` 或 `wait`)上调用 `interrupt` 方法时，阻塞调用将会被 `InterruptedException` 异常中断。（如果存在不能被中断的阻塞 `I/O` 调用，应该考虑选择可中断的调用。）

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要，以至于它们应该在处理完异常后，继续执行，而不理会中断。但更普遍的是，线程简单地将中断解释为终止的请求，这样的线程的 `run` 方法具有以下形式：
```java
Runnable r = () -> {
    try {
        //...
        while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
            // do more work
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```

如果在每次迭代之后调用 `sleep` 方法（或其他的可中断方法），则 `isInterrupted` 检查既不必要也不有用。如果在设置了中断状态时调用了 `sleep` 方法，则它不会进入睡眠状态。 而是清除状态并引发 `InterruptedException`。因此，如果循环调用 `sleep` 时，不要检查中断状态。而是捕获 `InterruptedException`，如下所示：
```java
Runnable r = () -> {
    try {
        //...
        while (/* more work to do */) {
            // do more work
            Thread.sleep(delay);
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```
注意⚠️：有两个非常类似的方法，`interrupted` 方法是一个静态方法，它检测当前的线程是否被中断，此外，调用 `interrupted` 方法会清除线程的中断状态。另一方面，`isInterrupted` 方法是一个实例方法，可用于检查是否有任何线程被中断，调用它不会更改中断状态。


## 线程状态
线程可以有 6 种状态：
- new（新创建）
- runnable（可运行）
- blocked（被阻塞）
- waiting（等待）
- timed waiting（计时等待）
- terminated（被终止）

要确定一个线程的状态，可调用 `getState` 方法。

### 新创建线程
当用 `new` 操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是 `new`。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 可运行线程
一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

现在所有的桌面以及服务器操作系统都使用抢占式调度，但是，在一些小型设备上可能使用协作式调度：一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。如果线程的数目多于处理器的数目，调度器依然采用时间片机制。

在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行，这就是为什么将这个状态称为“可运行(runnable)”而不是“运行(running)”。

### 被阻塞线程和等待线程
当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

1) 当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的`Lock`），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

2) 当线程等待另一个线程将条件通知调度器时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 java.util.concurrent 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，阻塞状态与等待状态之间的差异并不明显。

3) 有几个方法有一个超时参数，调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 以及 `Object.wait`、`Thread.join`、`Lock.tryLock` 和 `Condition.await` 的定时版本。

当一个线程被阻塞或等待时（或终止时）另一个线程将被调度为运行状态。

当一个线程被重新激活时（例如，因为超时期满或者成功地获得了一个锁），调度器将检查它是否具有比当前运行线程更高的优先级，如果是这样，调度器从当前运行的线程中挑选一个，剥夺其运行权，选择一个新的线程运行。

### 被终止的线程
线程因如下两个原因之一而被终止：
- 因为 `run` 方法正常推出而自然死亡。
- 因为一个没有捕获的异常终止了 `run` 方法而意外死亡。

特别是，可以调用线程的 `stop` 方法杀死一个线程，该方法抛出 `ThreadDeath` 错误对象，由此杀死线程。但是 `stop` 方法已过时，勿使用。

```
        新创建
          |
          | 开始
          |     ------------- 请求锁 -----------> 被阻塞
          |    / <----------  得到锁 ---------------|
          |   /
        可运行 _____------------- 等待通知 ----------> 等待
          |  \     <------------ 出现通知 -------------|
          |   \
          |    \_____------- 等待超时或通知 ---------> 计时等待
          |          <------ 出现超时或通知 --------------|
          |
          | 运行方法
          | exits
          |
        被终止
```


## 线程属性
### 线程优先级
在 Java 中，每一个线程都有一个优先级。默认情况下，线程继承构造它的线程的优先级。可以用 `setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 `MIN_PRIORITY`（在 `Thread` 类中定义为 1）与 `MAX_PRIORITY`（定义为 10）之间的任何值，`NORM_PRIORITY` 被定义为 5。

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。

注意⚠️：绝对不要构造这样的程序，以使其正常运行取决于优先级。

警告⚠️：如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，即使这可能会完全饿死低优先级的线程。

### 守护线程
可以通过调用 `t.setDaemon(true)` 将线程转换为守护线程(daemon thread)。

守护线程的唯一用途是为其他线程提供服务。比如计时线程，它定时地发送信号给其他线程或清空过时的高速缓存项的线程，当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，就没必要继续运行程序了。

注意⚠️：守护线程永远不要访问持久性资源，例如文件或数据库，因为它可以在任何时候甚至在一个操作的中间随时终止。

### 未捕获异常处理器
线程的 `run` 方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。在这种情况下，线程就死亡了。

但是，不需要任何 `catch` 子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

该处理器必须属于一个实现 `Thread.UncaughtExceptionHandler` 接口的类，这个接口只有一个方法：
```java
void uncaughtException(Thread t, Throwable e);
```
可以用 `setUncaughtExceptionHanlder` 方法为任何线程安装一个处理器，也可以用 `Thread` 类的静态方法 `setDefaultUncaughtExceptionHandler` 为所有线程安装一个默认的处理器。替换处理程序可以使用日志记录 API 将未捕获的异常的报告发送到日志文件中。

如果不安装默认的处理器，默认的处理器为 `null`。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 `ThreadGroup` 对象。

线程组(thread group)是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于同一线程组，但是，也可以建立其他分组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。

`ThreadGroup` 类实现 `Thread.UncaughtExceptionHandler` 接口，它的 `uncaughtException` 方法做如下操作：

1) 如果该线程有父线程，那么父线程组的 `uncaughtException` 方法被调用。

2) 否则，如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器，则调用该处理器。

3) 否则，如果 `Throwable` 是 `ThreadDeath` 的一个实例，什么都不做。

4) 否则，线程的名字以及 `Throwable` 的栈轨迹被输出到 `System.err` 上。


## 同步
在多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？根据各线程访问数据的次序，可能会产生讹误的数据。这样的情况通常称为竞争条件(race condition)。

### 竞争条件
为了避免多线程引起的对共享数据的讹误，必须学会如何同步存取。

### 竞争条件详解
假设两个线程同时执行指令：
```java
accounts[to] += amount;
```
问题在于这不是原子操作，该指令可能被处理如下：
- 1) 将 `accounts[to]` 加载到寄存器。
- 2) 增加 `amount`。
- 3) 将结果写回 `accounts[to]`。

假定第一个线程执行步骤 1 和 2，然后它被剥夺了运行权。假定第二个线程被唤醒并修改了 `accounts` 数组中的同一项。然后，第一个线程被唤醒并完成其第 3 步。

这样，这一动作擦去了第二个线程所做的更新。

```
javap是 jdk 自带的反解析工具。它的作用就是根据 class 字节码文件，反解析出当前类对应的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。

查看执行类中的每一个语句的虚拟机字节码，运行命令：
javap -c -v Bank
--------------------------------------------------------------------------------
Classfile Bank.class
  Last modified Mar 28, 2020; size 1439 bytes
  MD5 checksum fb066f73ca84623fa463a4cf36c71355
  Compiled from "UnsynchBankTest.java"
class Bank
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #8.#44         // java/lang/Object."<init>":()V
   #2 = Fieldref           #14.#45        // Bank.accounts:[D
   #3 = Methodref          #46.#47        // java/util/Arrays.fill:([DD)V
   #4 = Fieldref           #48.#49        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #50.#51        // java/lang/Thread.currentThread:()Ljava/lang/Thread;
   #6 = Methodref          #52.#53        // java/io/PrintStream.print:(Ljava/lang/Object;)V
   #7 = String             #54            // %10.2f from %d to %d
   #8 = Class              #55            // java/lang/Object
   #9 = Methodref          #56.#57        // java/lang/Double.valueOf:(D)Ljava/lang/Double;
  #10 = Methodref          #58.#59        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
  #11 = Methodref          #52.#60        // java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #12 = String             #61            //  Total Balance: %10.2f%n
  #13 = Methodref          #14.#62        // Bank.getTotalBalance:()D
  #14 = Class              #63            // Bank
  #15 = Utf8               accounts
  #16 = Utf8               [D
  #17 = Utf8               <init>
  #18 = Utf8               (ID)V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               LBank;
  #24 = Utf8               n
  #25 = Utf8               I
  #26 = Utf8               initialBalance
  #27 = Utf8               D
  #28 = Utf8               transfer
  #29 = Utf8               (IID)V
  #30 = Utf8               from
  #31 = Utf8               to
  #32 = Utf8               amount
  #33 = Utf8               StackMapTable
  #34 = Utf8               getTotalBalance
  #35 = Utf8               ()D
  #36 = Utf8               a
  #37 = Utf8               sum
  #38 = Class              #63            // Bank
  #39 = Class              #16            // "[D"
  #40 = Utf8               size
  #41 = Utf8               ()I
  #42 = Utf8               SourceFile
  #43 = Utf8               UnsynchBankTest.java
  #44 = NameAndType        #17:#64        // "<init>":()V
  #45 = NameAndType        #15:#16        // accounts:[D
  #46 = Class              #65            // java/util/Arrays
  #47 = NameAndType        #66:#67        // fill:([DD)V
  #48 = Class              #68            // java/lang/System
  #49 = NameAndType        #69:#70        // out:Ljava/io/PrintStream;
  #50 = Class              #71            // java/lang/Thread
  #51 = NameAndType        #72:#73        // currentThread:()Ljava/lang/Thread;
  #52 = Class              #74            // java/io/PrintStream
  #53 = NameAndType        #75:#76        // print:(Ljava/lang/Object;)V
  #54 = Utf8               %10.2f from %d to %d
  #55 = Utf8               java/lang/Object
  #56 = Class              #77            // java/lang/Double
  #57 = NameAndType        #78:#79        // valueOf:(D)Ljava/lang/Double;
  #58 = Class              #80            // java/lang/Integer
  #59 = NameAndType        #78:#81        // valueOf:(I)Ljava/lang/Integer;
  #60 = NameAndType        #82:#83        // printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #61 = Utf8                Total Balance: %10.2f%n
  #62 = NameAndType        #34:#35        // getTotalBalance:()D
  #63 = Utf8               Bank
  #64 = Utf8               ()V
  #65 = Utf8               java/util/Arrays
  #66 = Utf8               fill
  #67 = Utf8               ([DD)V
  #68 = Utf8               java/lang/System
  #69 = Utf8               out
  #70 = Utf8               Ljava/io/PrintStream;
  #71 = Utf8               java/lang/Thread
  #72 = Utf8               currentThread
  #73 = Utf8               ()Ljava/lang/Thread;
  #74 = Utf8               java/io/PrintStream
  #75 = Utf8               print
  #76 = Utf8               (Ljava/lang/Object;)V
  #77 = Utf8               java/lang/Double
  #78 = Utf8               valueOf
  #79 = Utf8               (D)Ljava/lang/Double;
  #80 = Utf8               java/lang/Integer
  #81 = Utf8               (I)Ljava/lang/Integer;
  #82 = Utf8               printf
  #83 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
{
  public Bank(int, double);
    descriptor: (ID)V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=3
         0: aload_0  //从本地变量表中加载索引为0的变量的值，也即 this 的引用，压入栈
         1: invokespecial #1  //出栈，调用java/lang/Object."<init>":()V 初始化对象，就是this指定的对象的init()方法完成初始化
         4: aload_0
         5: iload_1
         6: newarray       double
         8: putfield      #2                  // Field accounts:[D
        11: aload_0
        12: getfield      #2                  // Field accounts:[D
        15: dload_2
        16: invokestatic  #3                  // Method java/util/Arrays.fill:([DD)V
        19: return
      LineNumberTable:
        line 46: 0
        line 47: 4
        line 48: 11
        line 49: 19
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      20     0  this   LBank;
            0      20     1     n   I
            0      20     2 initialBalance   D

  public void transfer(int, int, double);
    descriptor: (IID)V
    flags: ACC_PUBLIC
    Code:
      stack=7, locals=5, args_size=4
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: iload_1
         5: daload
         6: dload_3
         7: dcmpg
         8: ifge          12
        11: return
        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: invokestatic  #5                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
        18: invokevirtual #6                  // Method java/io/PrintStream.print:(Ljava/lang/Object;)V
        21: aload_0
        22: getfield      #2                  // Field accounts:[D
        25: iload_1
        26: dup2
        27: daload
        28: dload_3
        29: dsub
        30: dastore
        31: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        34: ldc           #7                  // String %10.2f from %d to %d
        36: iconst_3
        37: anewarray     #8                  // class java/lang/Object
        40: dup
        41: iconst_0
        42: dload_3
        43: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        46: aastore
        47: dup
        48: iconst_1
        49: iload_1
        50: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        53: aastore
        54: dup
        55: iconst_2
        56: iload_2
        57: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        60: aastore
        61: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        64: pop
        65: aload_0
        66: getfield      #2                  // Field accounts:[D
        69: iload_2
        70: dup2
        71: daload
        72: dload_3
        73: dadd
        74: dastore
        75: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        78: ldc           #12                 // String  Total Balance: %10.2f%n
        80: iconst_1
        81: anewarray     #8                  // class java/lang/Object
        84: dup
        85: iconst_0
        86: aload_0
        87: invokevirtual #13                 // Method getTotalBalance:()D
        90: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        93: aastore
        94: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        97: pop
        98: return
      LineNumberTable:
        line 52: 0
        line 53: 11
        line 55: 12
        line 56: 21
        line 57: 31
        line 58: 65
        line 59: 75
        line 60: 98
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      99     0  this   LBank;
            0      99     1  from   I
            0      99     2    to   I
            0      99     3 amount   D
      StackMapTable: number_of_entries = 1
        frame_type = 12 /* same */

  public double getTotalBalance();
    descriptor: ()D
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=8, args_size=1
         0: dconst_0
         1: dstore_1
         2: aload_0
         3: getfield      #2                  // Field accounts:[D
         6: astore_3
         7: aload_3
         8: arraylength
         9: istore        4
        11: iconst_0
        12: istore        5
        14: iload         5
        16: iload         4
        18: if_icmpge     38
        21: aload_3
        22: iload         5
        24: daload
        25: dstore        6
        27: dload_1
        28: dload         6
        30: dadd
        31: dstore_1
        32: iinc          5, 1
        35: goto          14
        38: dload_1
        39: dreturn
      LineNumberTable:
        line 63: 0
        line 64: 2
        line 65: 27
        line 64: 32
        line 67: 38
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           27       5     6     a   D
            0      40     0  this   LBank;
            2      38     1   sum   D
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 14
          locals = [ class Bank, double, class "[D", int, int ]
          stack = []
        frame_type = 248 /* chop */
          offset_delta = 23

  public int size();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: arraylength
         5: ireturn
      LineNumberTable:
        line 71: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LBank;
}
SourceFile: "UnsynchBankTest.java"
```
注意🌿：代码行 `accounts[to] += amount;` 增值命令是由几条指令组成的，执行它们的线程可以在任何一条指令点上被中断。

真正的问题是 `transfer` 方法的执行过程中可能被中断。如果能够确保线程在失去控制之前方法运行完成，那么就不会出现数据讹误。

### 锁对象
有两种机制防止代码块受并发访问的干扰，Java 语言为此提供一个 `synchronized` 关键字达到这一目的，而在 Java SE 5.0 引入了 `ReentrantLock` 类。

synchronized 美[ˈsɪŋkrənaɪzd] v.(使) 同步，在时间上一致，同速进行;
synchronize的过去分词和过去式;

reentrant 美[ˌriˈɛntrənt] adj.可重入; 可重入的; 重入; 可再入的; 重进入;

`synchronized` 关键字自动提供一个锁以及相关的条件，对于大多数需要显式锁的情况，这是很便利的。`java.util.concurrent` 框架为这些基础机制提供独立的类。

使用 `ReentrantLock` 保护代码块的基本结构如下：
```java
myLock.lock(); // a ReentrantLock object
try {
    // critical section
}
finally {
    myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown
}
```
这一结构确保任何时刻只有一个线程进入临界区，一旦一个线程封锁了锁对象，其他任何线程都无法通过 `lock` 语句。当其他线程调用 `lock` 时，它们被阻塞，直到第一个线程释放锁对象。

警告：把解锁操作放在 `finally` 子句之中是至关重要的，如果在临界区的代码抛出异常，锁必须被释放，否则，其他线程将永远阻塞。

如果使用锁，就不能使用带资源的 `try` 语句。首先，解锁方法名不是 `close`，不过，即使将它重命名，带资源的 `try` 语句也无法正常工作。它的首部希望声明一个新变量，但是如果使用的是一个锁，那么会是多个线程共享的那个变量。

假定一个线程调用 `transfer`，在执行结束前被剥夺了运行权。假设第二个线程也调用 `transfer`，由于第二个线程不能获得锁，将在调用 `lock` 方法时被阻塞。它必须等待第一个线程完成 `transfer` 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行。

注意每一个 `Bank` 对象有自己的 `ReentrantLock` 对象。如果两个线程视图访问同一个 `Bank` 对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的 `Bank` 对象，每个线程得到不同的锁对象，两个线程都不会发生阻塞。因为线程在操纵不同的 `Bank` 实例时，线程之间不会相互影响。

锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对 `lock` 方法的嵌套调用。线程在每一次调用 `lock` 都要调用 `unlock` 来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。

`transfer` 方法调用 `getTotalBalance` 方法，这也会封锁 `bankLock` 对象，此时 `bankLock` 对象的持有计数为 2。当 `getTotalBalance` 方法退出的时候，持有计数变回 1。当 `transfer` 方法退出的时候，持有计数变为 0。线程释放锁。

通常，保护需要若个操作来更新或检查共享对象的代码块，要确保这些操作完成后，另一个线程才能使用相同对象。

注意⚠️：要留心临界区的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，`finally` 子句将释放锁，但会使对象可能处于一种受损状态。

使用 `ReentrantLock(boolean fair)` 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程，但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。

警告🍓：公平锁比使用常规锁要慢得多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候才使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁。

### 条件对象 Condition Objects
通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。

条件对象，也被称为条件变量(condtion variables)。

避免选择没有足够资金的账户作为转出账户，注意不能使用下面的代码❌：
```java
if (bank.getBalance(from) >= amount) {
    // thread might be deactivated at this point
    bank.transfer(from, to, amount);
}
```
当前线程完全有可能在成功地完成测试，且在调用 `transfer` 方法之前将被中断。在线程再次运行前，账户余额可能已经低于提款金额。必须确保没有其他线程在本检查余额与转账活动之间修改余额。通过使用锁来保护检查与转账动作：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            // wait
            // ...
        }
        // transfer funds
        // ...
    } finally {
        bankLock.unlock();
    }
}
```
现在，当账户没有足够的金额时，等待直到另一个线程向账户中注入资金。但是，这一线程刚刚获得了对 `bankLock` 的排他性访问，因此别的线程没有进行存款操作的机会。

一个锁对象可以有一个或多个相关的条件对象，可以使用 `newCondtion` 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映出它所表达的条件的名字。
```java
class Bank {
    private Condtion sufficientFunds; // 余额充足条件
    // ...
    public Bank() {
        // ...
        sufficientFunds = bankLock.newCondtion();
    }
}
```
如果 `transfer` 方法发现余额不足时，调用 `sufficientFunds.await();`，当前线程现在被阻塞了，并放弃了锁。这样可以使得另一个线程可以进行增加账户余额的操作。

等待获得锁的线程和调用 `await` 方法的线程存在本质上的不同。一旦一个线程调用 `await` 方法，它进入该条件的等待集。等锁可用时，该线程不能马上解除阻塞。相反，它仍然处于阻塞状态，直到另一个线程在相同条件下调用 `signalAll` 方法为止。

当另一个线程转账时，调用 `sufficientFunds.signalAll();`，这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 `await` 调用返回，获得该锁并从被阻塞的地方继续执行。

此时，线程应该再次测试该条件。由于无法确保该条件被满足，`signalAll` 方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。

通常，对 `await` 的调用应该在如下形式的循环体中：
```java
while (!(ok to procced)) {
    condtion.await();
}
```

至关重要的是最终需要在某个其他线程中调用 `signalAll` 方法。当一个线程调用 `await` 时，它没有办法重新激活自身，它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再执行了，这将导致死锁(deadlock)现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用 `await` 方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

应该何时调用 `signalAll` 呢？在对象的状态有利于等待线程的方向改变时调用 `signalAll`。例如，当一个账户余额发生改变时，等待的线程会应该有机会检查余额：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            sufficientFunds.await();
        }
        // transfer funds
        // ...
        sufficientFunds.signalAll();
    } finally {
        bankLock.unlock();
    }
}
```
注意调用 `signalAll` 不会立即激活一个等待线程。它仅仅是解除等待线程的阻塞，以便这些线程可以在当前线程释放锁之后，通过竞争实现对对象的访问。

另一个方法 `signal`，则是随机解除`等待集`中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自身仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 `signal`，则系统死锁。

警告：当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 `await`、`signalAll` 或 `signal` 方法。

### synchronized 关键字
锁 `Lock` 和条件 `Condtion` 的关键之处：
- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 锁可以拥有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

`Lock` 和 `Condition` 接口为开发者提供了高度的锁定控制。然而，大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到 Java 语言内部的机制。

从 1.0 版本开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 `synchronized` 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用方法，线程必须获得内部的对象锁。
```java
public synchronized void method() {
    // method body
}
// 等价于
public void method() {
    this.intrinsicLock.lock();
    try {
        // method body
    } finally {
        this.intrinsicLock.unlock();
    }
}

```

intrinsic 美 [ɪn'trɪnsɪk] adj.固有的，内在的，本质的;

可以简单地声明 `Bank` 类的 `transfer` 方法为 `synchronized`，而不是使用一个显式的锁。

内部对象锁只有一个关联条件。`wait` 方法将线程添加到 `等待集` 中，`notifyAll` 或 `notify` 方法解除等待线程的阻塞状态。换言之，调用 `wait` 或 `notifyAll` 等价于：
```java
intrinsicCondition.await();
intrinsicCondition.signalAll();
```

注意：`wait`、`notifyAll` 以及 `notify` 方法是 `Object` 类的 `final` 方法。`Condition` 方法必须被命名为 `await`、`signalAll` 和 `signal` 以便它们不会与那些方法发生冲突。
```java
class Bank {
    //...
    private double[] accounts;
    //...
    public synchronized void transfer(int from, int to, int amount) throws InterruptedException {
        while (accounts[from] < amount) {
            wait(); // wait on intrinsic object lock's single condition
        }
        accounts[from] -= amount;
        accounts[to] += amount;
        notifyAll(); // notify all threads waiting on the condtion
    }
    //...
}
```
使用 `synchronized` 关键字编写代码要简洁得多。理解这段代码，需要了解每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入 `synchronized` 方法的线程，由条件来管理那些调用 `wait` 的线程。

将静态方法声明为 `synchronized` 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。如果 `Bank` 类有一个静态同步方法，那么当该方法被调用时，`Bank.class` 对象的锁被锁住，因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

内部锁和条件存在一些局限：
- 不能中断一个正在试图获得锁的线程。
- 试图获得锁时不能设定超时。
- 每个锁仅有单一的条件，可能是不够的。

使用 `Lock` 和 `Condition` 对象还是同步方法？
- 最好既不使用 `Lock`/`Condition` 也不使用 `synchronized` 关键字。在许多情况下，可以使用 java.util.concurrent 包中的一种机制，它会处理所有的加锁。
- 如果 `synchronized` 关键字适合，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
- 如果特别需要 `Lock`/`Condition` 结构提供的独有特性时，才使用  `Lock`/`Condition`。

### 同步阻塞
每一个 Java 对象有一个锁，线程可以通过调用同步方法获得锁，还可以通过进入一个同步阻塞(synchronized block)获得锁：
```java
synchoronized(obj) { // the syntax for a synchronized block
    // critical section
}
```
于是获得 obj 的锁。
```java
public class Bank {
    private double[] accounts;
    private Object lock = new Object();
    // ...
    public void transfer(int from, int to, int amount) {
        synchronized(lock) {
            accounts[from] -= amount;
            accounts[to] += amount;
        }
        // ...
    }
}
```
lock 对象被创建仅仅是用来使用每个 Java 对象持有的锁。

使用一个对象的锁来实现额外的原子操作，实际上称为客户端锁定(client-side locking)。

考虑 `Vector` 类，一个列表，它的方法是同步的：
```java
public void transfer(int from, int to, int amount) {
    accounts.set(from, accounts.get(from) - amount);
    accounts.set(to, accounts.get(to) + amount);
    // ...
}
```
虽然 `Vector` 类的 `get` 和 `set` 方法是同步的，但这对于上述程序没有什么帮助。在第一次 `get` 的调用已经完成之后，一个线程完全可能在 `transfer` 方法中被剥夺运行权。然后另一个线程可以将不同的值存储到同一位置。但是，我们可以劫持锁：
```java
public void transfer(int from, int to, int amount) {
    synchronized (accounts) {
        accounts.set(from, accounts.get(from) - amount);
        accounts.set(to, accounts.get(to) + amount);
        // ...
    }
}
```
注意：这个方法可以工作，但是完全依赖于一个事实：`Vector` 类对自己的所有可修改方法都使用内部锁。故，客户端锁定是非常脆弱的，不推荐使用。

### 监视器概念
监视器具有如下特性：
- 监视器是只包含私有域的类。
- 每个监视器类的对象有一个相关的锁。
- 使用该锁对所有对方法进行加锁。如果客户端调用 `obj.method()`，那么 obj 对象的锁是在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域。
- 该锁可以有任意多个相关条件。

Java 中每一个对象有一个内部的锁和内部的条件。如果一个方法用 `synchronized` 关键字声明，那么，它表现得就像是一个监视器方法，通过调用 `wait`/`notifyAll`/`notify` 来访问条件变量。

然而，下述的 3 个方法 Java 对象不同于监视器，从而使得线程的安全性下降：
- 域不要求必须是 `private`。
- 方法不要求必须是 `synchronized`。
- 内部锁对用户是可用的。

### volatile 域
volatile 美[ˈvɑːlətl] adj.易变的; 无定性的;

读写实例域，出错的可能性很大：
- 多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值，结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
- 编译器可以改变指令执行的顺序以使吞吐量最大化，这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变。

如果使用锁来保护被多个线程访问的代码，那么可以不用考虑这种问题，编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令。

同步格言：如果向一个变量写入值，而这个变量接下来可能会被另一个线程读取，或者，从一个变量读值，而这个变量可能是之前被另一个写入的，此时必须使用同步。

`volatile` 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 `volatile`，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

假定一个对象有一个布尔标记 `done`，它的值被一个线程设置却被另一个线程查询：
```java
private boolean done;
public synchronized boolean isDone() { return done; }
public synchronized void setDone() { done = true; }
```
如果另一个线程已经对该对象加锁，`isDone` 和 `setDone` 方法可能阻塞。或者，可以新建一个线程为这一变量使用独立的 `Lock`，但是这样开销过大了。在这种情况下，将域声明为 `volatile` 是合理的：
```java
private volatile boolean done;
public boolean isDone() { return done; }
public void setDone() { done = true; }
```

注意⚠️：`volatile` 变量不能提供原子性：
```java
public void flipDone() { done = !done; } // not atomic
```
不能确保翻转域中的值，不能保证读取、翻转和写入不被中断。

### final 变量
除非使用锁或 `volatile` 修饰符，否则无法从多个线程安全地读取一个域。

还有一种情况可以安全地访问一个共享域，即这个域声明为 `final` 时。

以下声明：
```java
final Map<String, Double> accounts = new HashMap<>();
```
其他线程会在构造函数完成构造之后才看到这个 `accounts` 变量。

如果不使用 `final`，就不能保证其他线程看到的是 `accounts` 更新后的值，它们可能都只是看到 `null`，而不是新构造的 `HashMap`。

当然，对这个映射表的操作并不是线程安全的。如果有多个线程在读写这个映射表，仍然需要进行同步。

### 原子性
假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 `volatile`。

java.util.concurrent.atomic 包中很多类使用了很高效的机器级指令，而不是使用锁来保证其他操作的原子性。例如，`AtomicInteger` 类提供了方法 `incrementAndGet` 和 `decrementAndGet`，它们分别以原子方式将一个整数自增或自减。
```java
public static AtomicLong nextNumber = new AtomicLong();

// in some thread
long id = nextNumber.incrementAndGet();
```
`incrementAndGet` 方法以原子方式将 `nextNumber` 自增，并返回自增后的值。也就是说，获得值、增 1 并设置然后生成新值的操作不会中断。可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

atomic 美[əˈtɑːmɪk] adj.原子的; 与原子有关的; 原子能的; 原子武器的;

跟踪不同线程观察的最大值，下面的代码是不可行的：
```java
public static AtomicLong largest = new AtomicLong();

// in some thread
largest.set(Math.max(larget.get()), observed); // Error - race condtion!
```
这个更新不是原子的，实际上，应该在一个循环中计算新值和使用 `CompareAndSet`：
```java
do {
    oldValue = largest.get();
    newValue = Math.max(oldValue, observed);
} while (!largest.compareAndSet(oldValue, newValue));
```
如果另一个线程也在更新 `largest`，就可能阻止这个线程更新，这样一来，`compareAndSet` 返回 `false`，而不会设置新值。在这种情况下，循环会更新尝试，读取更新后的值，并尝试修改。最终，它会成功地用新值替换原来的值。这听上去有些麻烦，不过 `compareAndSet` 方法会映射到一个处理器操作，比使用锁的速度更快。

在 Java SE 8 中，不再需要编写循环代码，可以提供一个 lambda 表达式更新变量：
```java
largest.updateAndGet(x -> Math.max(x, observed));
// 或
largest.accumulateAndGet(observed, Math::max);
```
`accumulateAndGet` 方法利用一个二元操作符来合并原子值和所提供的参数。

`getAndUpdate` 和 `getAndAccumulate` 方法可以返回原值。

类 `AtomicInteger`、`AtomicIntegerArray`、`AtomicIntegerFieldUpdate`、`AtomicLongArray`、`AtomicLongFieldUpdate`、`AtomicReference`、`AtomicRefenceArray` 和 `AtomicReferenceFieldUpdate` 也提供了这些方法。

如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8 提供了 `LongAdder` 和 `LongAccumulator` 类来解决这个问题。`LongAdder` 包括多个变量(加数)，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效，性能会有显著的提升。

如果认为可能存在大量竞争，只需要使用 `LongAdder` 而不是 `AtomicLong`。调用 `increment` 让计数器自增，或者调用 `add` 来增加一个量，或者调用 `sum` 来获得总和：
```java
final LongAdder adder = new LongAdder();
for (...) {
    pool.submit(() -> {
        while (...) {
            ...
            if (...) {
                adder.increment();
            }
        }
    })
}
...
long total = adder.sum();
```
注意⚠️：`increment` 方法不会返回原值，如果那样做会消除求和分解到多个加数所带来的性能提升。

`LongAccumulator` 将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。要加入新的值，可以调用 `accumulate`。调用 `get` 来获得当前值：
```java
LongAccumulator adder = new LongAccumulator(Long::sum, 0);

// in some thread
adder.accumulate(value);
```
在内部，这个累加器包含变量 a<sub>1</sub>、a<sub>2</sub>、... a<sub>n</sub>，每个变量初始化为零元素。

调用 `accumulate` 并提供值 v 时，其中一个变量会以原子形式更新为 a<sub>i</sub> = a<sub>i</sub> op v，这里的 op 是中缀形式的累加操作。

调用 `get` 的结果是 a<sub>1</sub> op a<sub>2</sub> op ... op a<sub>n</sub>。

### 死锁 deadlock
锁和条件不能解决多线程中的所有问题。

因为账户1 以及账户2 中的余额都不足以进行转账，有可能因为每一个线程都要等待更多的钱款存入而导致所有的线程都被阻塞，这样的状态称为死锁。

导致死锁的另一个途径是让第 i 个线程负责向第 i 个账户存钱，而不是从第 i 个账户取钱。这样一来，有可能将所有的线程都集中一个账户上，每一个线程都试图从这个账户取出大于该账户余额的钱。

还有一种很容易发生死锁的情况：将 `signalAll` 方法换为 `signal`，`signalAll` 通知所有等待增加资金的线程，而 `signal` 方法仅仅对一个线程解锁，如果该线程不能继续运行，所有的线程可能都被阻塞。

Java 编程语言中没有任何东西可以避免或打破这种死锁现象，必须仔细设计程序，以确保不会出现死锁。

### 线程局部变量
在线程间共享变量有风险，使用 `ThreadLocal` 辅助类为各个线程提供各自的实例。例如，`SimpleDateFormat` 类不是线程安全的，假设有一个静态变量：
```java
public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
```
如果有两个线程都执行以下操作：
```java
String dateStamp = dateFormat.format(new Date());
```
`dateFormat` 使用的内部数据结构可能会被并发的访问所破坏。

要为每个线程构造一个实例，可以使用下列代码：
```java
public static final ThreadLocal<SimpleDateFormat> dateFormat = ThreadLocal().withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

要访问具体的格式化方法，可以调用：
```java
String dateStamp = dateFormat.get().format(new Date());
```
在一个给定线程中首次调用 `get` 时，会调用 `initialValue` 方法，在此之后，`get` 方法会返回属于当前线程的那个实例。

java.util.Random 类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器，这样会很低效，可以使用 `ThreadLocal` 辅助类为每个线程提供一个单独的生成器。在 Java SE 7 中另外提供了一个便利类， `ThreadLocalRandom.current()` 调用会返回特定于当前线程的 `Random` 类实例：
```java
int random = ThreadLocalRandom.current().nextInt(upperBound);
```

### 锁测试与超时
线程在调用 `lock` 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞，应该谨慎地申请锁。

`tryLock` 方法试图申请一个锁，在成功获得锁后返回 `true`，否则，立即返回 `false`，而且线程可以立即离开去做其他事情。
```java
if (myLock.tryLock()) {
    // now the thread owns the lock
    try {
        // ...
    } finally {
        myLock.unlock();
    }
} else {
    // do something else
}
```
可以调用 `tryLock` 时，使用超时参数：
```java
if (myLock.tryLock(100, TimeUnit.MILISECONDS)) { ... }
```

`lock` 方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，`lock` 方法无法终止。然而，如果调用带有超时参数的 `tryLock`，那么如果线程在等待期间被中断，将抛出 `InterruptedException` 异常。这是一个非常有用的特性，因为允许程序打破死锁。

也可以调用 `lockInterruptibly` 方法，它就相当于一个超时设为无限的 `tryLock` 方法。

在等待一个条件时，也可以提供一个超时：
```java
myCondtion.await(100, TimeUnit.MILISECONDS);
```
如果一个线程被另一个线程通过调用 `signalAll` 或 `signal` 激活，或者超时时限已达到，或者线程被中断，那么 `await` 方法将返回。

如果等待的线程被中断，`await` 方法将抛出一个 `InterruptedException` 异常。

### 读／写锁
java.util.concurrent.locks 包中定义了两个锁类，`ReentrantLock` 类和 `ReentrantReadWriteLock` 类。

如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，后者是十分有用的。在这种情况下，允许对读线程共享访问是合适的，对写线程依然必须是互斥访问的。

使用读／写锁的步骤：

1) 构造一个 `ReentrantReadWriteLock` 对象：
```java
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
```

2) 抽取读锁和写锁：
```java
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
```

3) 对所有的获取方法加读锁：
```java
public double getTotalBalance() {
    readLock.lock();
    try { ... }
    finally { readLock.unlock(); }
}
```

4) 对所有的修改方法加写锁：
```java
public void transfer(...) {
    writeLock.lock();
    try { ... }
    finally { writeLock.unlock(); }
}
```

### 为什么弃用 stop 和 suspend 方法
初始的 Java 版本定义了一个 `stop` 方法用来终止一个进程，以及一个 `suspend` 方法用来阻塞一个线程直到另一个线程调用 `resume`。`stop` 和 `suspend` 方法有一些共同点：都试图控制一个给定线程的行为。

`stop` 方法终止所有未结束的方法，包括 `run` 方法。当线程被终止，立即释放被它锁住的所有对象的锁，这会导致对象处于不一致的状态。

当线程要终止另一个线程时，无法知道什么时候调用 `stop` 方法是安全的，什么时候导致对象被破坏。<font color="red">在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。</font>

`suspend` 方法不会破坏对象，如果用 `suspend` 挂起一个持有锁的线程，那么，该锁在恢复之前是不可用的。如果调用 `suspend` 方法的线程试图获得同一锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。

如果想安全地挂起线程，引入一个变量 `suspendRequested` 并在 `run` 方法的某个安全地方测试它，安全的地方是指该线程没有封锁其他线程需要的对象的地方。当线程发现 `suspendRequested` 变量已经设置，将会保持等待状态知道它再次获得为止。


## 阻塞队列 blocking queue
对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列中插入元素，消费者线程则取出它们。使用队列可以安全地从一个线程向另一个线程传递数据。

当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。工作者线程可以周期性地将中间结果存储在阻塞队列中，其他的工作者线程移出中间结果并进一步加以修改，队列会自动地平衡负载，如果第一个线程集运行得比第二个慢，第二个线程集在等待结果时会阻塞，如果第一个线程集运行得快，它将等待第二个队列集赶上来。

阻塞队列方法：

| 方法 | 正常动作 | 特殊情况下的动作 |
|:-|:-|:-|
| add | 添加一个元素 | 如果队列满，则抛出 IllegalStateException 异常 |
| element | 返回队列的头元素 | 如果队列空，则抛出 NoSuchElementException 异常 |
| offer | 添加一个元素并返回 true | 如果队列满，则返回 false |
| peek | 返回队列的头元素 | 如果队列空，则返回 null |
| poll | 移出并返回队列的头元素 | 如果队列空，则返回 null |
| put | 添加一个元素 | 如果队列满，则阻塞 |
| remove | 移出并返回头元素 | 如果队列空，则抛出 NoSuchElementException 异常 |
| take | 移出并返回头元素 | 如果队列空，则阻塞 |

阻塞队列的方法分为 3 类，这取决于当队列满或空时它们的响应方式：
- 将队列当作线程管理工具使用，使用 put 和 take 方法；
- 当试图向满的队列中添加或从空的队列中移出时，add、remove 和 element 操作抛出异常；
- 在一个多线程程序中，队列在任何时候空或满，一定要使用 offer、peek 和 poll 方法作为替代，这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。

注意：poll 和 peek 方法返回 null 指示失败，因此，向这些队列中插入 null 是非法的。

还有带有超时的 offer 方法和 poll 方法的变体：
```java
// 尝试在 100 毫秒内在队列的尾部插入一个元素，如果成功返回 true
// 否则，达到超时时，返回 false
boolean success = q.offer(x, 100, TimeUnit.MILLISECONDS);

// 尝试用 100 毫秒的时间移除队列的头元素，如果成功返回头元素
// 否则，达到超时时，返回 null
Object head = q.poll(100, TimeUnit.MILLISECONDS);
```
如果队列满，则 put 方法阻塞；如果队列空，则 take 方法阻塞。在不带超时参数时，offer 和 poll 方法等效。

java.util.concurrent 包提供了阻塞队列的几个变种。默认情况下，`LinkedBlockingQueue` 的容量是没有上界的，但是，也可以选择指定最大容量，这是一个双端的版本。`ArrayBlockingQueue` 在构造时要指定容量，并且有一个可选的参数来指定是否需要公平性，若设置了公平参数，则等待了最长时间的线程会优先得到处理。通常公平性会降低性能，只有在确实非常需要时才使用它。

`PriorityBlockingQueue` 是一个带优先级的队列，元素按照它们的优先级顺序被移出，该队列是没有容量上限，如果队列是空的，取元素的操作会阻塞。

`DelayQueue` 包含实现 `Delayed` 接口的对象：
```java
interface Delayed extends Comparable<Delayed> {
    long getDelay(TimeUnit unit);
}
```
`getDelay` 方法返回对象的残留延迟。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从 `DelayQueue` 移除。还必须实现 `compareTo` 方法，`DelayQueue` 使用该方法对元素进行排序。

Java SE 7 增加了一个 `TransferQueue` 接口，允许生产者线程等待，直到消费者准备就绪可以接收一个元素。如果生产者调用：
```java
q.transfer(item);
```
这个线程会阻塞，直到另一个线程将元素(item)删除。`LinkedTransferQueue` 类实现了该接口。

程序在一个目录及它的所有子目录下搜索所有文件， 打印出包含指定关键字的行。生产者线程枚举在所有子目录下的所有文件并把它们放到一个阻塞队列中。同时启动了大量的搜索线程，每个搜索线程从队列中取出一个文件，打开它，打印所有包含该关键字的行，然后取出下一个文件。

使用一个小技巧在工作结束后终止这个应用程序。为了发出完成信号，枚举线程放置一个虚拟对象到队列中，当搜索到这个虚拟对象时，将其放回并终止。


## 线程安全的集合
可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代更容易些，阻塞队列就是线程安全的集合。

### 高效的映射、集和队列
java.util.concurrent 包提供了映射、有序集和队列的高效实现：`ConcurrentHashMap`、`ConcurrentSkipListMap`、`ConcurrentSkipListSet` 和 `ConcurrentLinkedQueue`。

这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。

与大多数集合不同，`size` 方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。

集合返回弱一致性(weakly consistent)的迭代器，这意味着迭代器不一定能反映出它们被构造之后的所有的修改。但是，它们不会将同一个值返回两次，也不会抛出 `ConcurrentModificationException` 异常。

与之形成对照的是，集合如果在迭代器之后发生改变，java.util 包中的迭代器将抛出一个 `ConcurrentModificationException` 异常。

### 映射条目的原子更新 Atomic Update of Map Entries
// TODO

### 对并发散列映射的批操作 Bulk Operations on Concurrent Hash Maps
// TODO

### 并发集视图 Concurrent Set Views
// TODO

### 写数组的拷贝
// TODO

### 并行数组算法
// TODO

### 较早的线程安全集合
// TODO


## Callable 与 Future
`Runnable` 封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步方法。

`Callable` 接口是一个参数化的类型，只有一个方法，与 `Runnable` 类似，但是有返回值：
```java
public interface Callable<V> {
    V call() throws Exceptions;
}
```
类型参数是返回值的类型。`Callable<Integer>` 表示一个最终返回 `Integer` 对象的异步计算。

`Future` 保存异步计算的结果，可以启动一个计算，将 `Future` 对象交给某个线程，然后忘掉它。`Future` 对象的所有者在结果计算好之后就可以获得它。

`Future` 接口具有下面的方法：
```java
public interface Future<V> {
    V get() throws ...;
    V get(long timeout, TimeUnit unit) throws ...;
    void cancel(boolean mayInterrupt);
    boolean isCanceled();
    boolean isDone();
}
```
第一个 `get` 方法的调用被阻塞，直到计算完成。如果在计算完成之前，第二个方法的调用超时，抛出一个 `TimeoutException` 异常。如果运行该计算的线程被中断，两个方法都将抛出 `InterruptedException`。如果计算已经完成，那么 `get` 方法立即返回。

如果方法还在进行，`isDone` 方法返回 `false`，如果完成了，则返回 `true`。

可以用 `cancel` 方法取消计算。如果计算还没有开始，它被取消且不再开始。如果计算处于运行之中，那么如果 `myInterrupt` 参数为 `true`，它就被中断。

`FutureTask` 包装器可将 `Callable` 转换成 `Future` 和 `Runnable`，它同时实现二者的接口：
```java
Callable<Integer> myComputation = ...;
FutureTask<Integer> task = new FutureTask<Integer>(myComputation);
Thread t = new Thread(t); // it's a Runnable
t.start();
...
Integer result = task.get(); // it's a Future
```
利用 `MatchCounter` 创建一个 `FutureTask` 对象，并用来启动一个线程：
```java
class MatchCounter implements Callable<Integer> {
    public MatchCounter(File directory, String keyword) {...}
    public Integer call() {...} // returns the number of matching files
}

MatchCounter counter = new MatchCounter();
FutureTask<Integer> task = new FutureTask<Integer>(counter);
Thread t = new Thread(task);
t.start();

// 最后打印结果
System.out.println(task.get() + " maching files");
```
对 `get` 的调用会发生阻塞，直到有可获得的结果为止。

在 `call` 方法内部，使用相同的递归机制，对于每一个子目录，产生一个新的 `MatchCounter` 并为它启动一个线程。此外，把 `FutureTask` 对象隐藏在 `ArrayList<Future<Integer>>` 中，最后，把所有结果加起来：
```java
for (Future<Integer> result : results) {
    count += result.get();
}
```
每一次对 `get` 的调用都会发生阻塞直到结果可获得为止。


## 执行器
构造一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量的生命期很短的线程，应该使用线程池(thread pool)。一个线程池中包含许多准备运行的空闲线程。将 `Runnable` 对象交给线程池，就会有一个线程调用 `run` 方法。当 `run` 方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务。

另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数固定的线程池以限制并发线程的总数。

执行器(Executor)类有许多静态工厂方法用来构建线程池。

执行器类的工厂方法：

| 方法 | 描述 |
|:-|:-|
| newCachedThreadPool | 必要时创建新线程；空闲线程会被保留 60 秒 |
| newFixedThreadPool | 该池包含固定数量的线程；空闲线程会一直被保留 |
| newSingleThreadExecutor | 只有一个线程的池，该线程顺序执行每一个提交的任务 |
| newScheduledThreadPool | 用于预定执行而构建的固定线程池，替代 java.util.Timer |
| newSingleThreadScheduledExecutor | 用于预定执行而构建的单线程池 |

### 线程池
`newCachedThreadPool` 方法构建一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程。

`newFixedThreadPool` 方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。

`newSingleThreadExecutor` 是一个退化了的大小为 1 的线程池：由一个线程执行提交的任务，一个接一个。

以上三个方法返回实现了 `ExecutorService` 接口的 `ThreadPoolExecutor` 类的对象。

可以将一个 `Runnable` 对象或 `Callable` 对象提交给 `ExecutorService`：
```java
Future<?> submit(Runnable task);
Future<T> submit(Runnable task, T result);
Future<T> submit(Callabale<T> task);
```
该池会在方便的时候尽早执行提交的任务。调用 `submit` 时，会得到一个 `Future` 对象，可用来查询该任务的状态。

第一个 `submit` 方法返回一个 `Future<?>`，可以使用这样一个对象来调用 `isDone`、`cancel` 或 `isCancelled`，但是，`get` 方法在完成的时候只是简单地返回 `null`。

第二个 `submit` 方法也提交一个 `Runnable`，并且 `Future` 的 `get` 方法在完成的时候返回指定的 `result` 对象。

第三个 `submit` 方法提交一个 `Callable`，并且返回的 `Future` 对象将在计算结果准备好的时候得到它。

当用完一个线程池的时候，调用 `shutdown`。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用 `shutdownNow`，该池取消尚未开始的所有任务并试图中断正在运行的线程。

使用连接池时应该做的事：

1) 调用 `Executors` 类中的静态方法 `newCachedThreadPool` 或 `newFixedThreadPool`。

2) 调用 `submit` 提交 `Runnable` 或 `Callable` 对象。

3) 如果想要取消一个任务，或者如果提交 `Callable` 对象，那就要保存好返回的 `Future` 对象。

4) 当不再提交任何任务时，调用 `shutdown`。


### 预定执行
`ScheduledExecutorService` 接口具有为预定执行(Scheduled Execution)或重复执行任务而设计的方法。它是一种允许使用线程池机制的 `java.util.Timer` 的泛化。`Executors` 类的 `newScheduledThreadPool` 和 `newSingleThreadScheduledExecutor` 方法将返回 `ScheduledExecutorService` 接口的对象。

可以预定 `Runnable` 或 `Callable` 在初始的延迟之后只执行一次，也可以预定一个 `Runnable` 对象周期性地运行。

### 控制任务组
可以将一个执行器作为线程池使用，以提高执行任务的效率，除此外，使用执行器可以控制一组相关任务。比如，在执行器中使用 `shutdownNow` 方法取消所有的任务。

`invokeAny` 方法提交所有对象到一个 `Callable` 对象的集合中，并返回某个已经完成了的任务的结果，但无法知道返回的究竟是哪个任务的结果。
```java
List<Callable<T>> tasks = ...;
List<Callable<T>> results = executors.invokeAll(tasks);
for (Future<T> result : results) {
    processFurther(result.get());
}
```
返回一个 `Future` 对象的列表，代表所有任务的解决方案。这个方法的缺点是如果第一个任务恰巧花去了很多时间，则可能不得不进行等待。将结果按可获得的顺序保存起来更有实际意义。

可以使用 `ExecutorCompletionService` 来进行排列。用常规的方法获得一个执行器，然后，构建一个 `ExecutorCompletionService`，提交任务给完成服务(completion service)。该服务管理 `Future` 对象的阻塞队列，其中包含已经提交任务的执行结果（当这些结果成为可用时）：
```java
ExecutorCompletionService<T> service = new ExecutorCompletionService<>(executor);
for (Callable<T> task : tasks) {
    service.submit(task);
}
for (int i = 0; i < tasks.size(); i++) {
    processFurther(service.take().get());
}
```

### fork-join 框架
有些应用使用了大量线程，但其中大多数都是空闲的。比如，一个 Web 服务器可能会为每个连接分别使用一个线程。另外一些应用可能对每个处理器内核分别使用一个线程，来完成计算密集型任务，如图像或视频处理。Java SE 7 中新引入了 fork-join 框架，专门用来支持后一类应用。假设有一个处理任务，它可以很自然地分解为子任务。
```
if (problemSize < threshold) {
    solve problem directly
} else {
    break problem into subproblems
    recursively solve each subproblems
    combine the results
}
```

threshold 美[ˈθreʃhoʊld] n.门槛; 门口; 阈; 界; 起始点; 开端; 起点; 入门;

假设统计一个数组中有多少个元素某个特定的属性，可以将这个数组一分为二，分别对这两部分进行统计，再将结果相加。

要采用框架可用的一种方式来完成这种递归计算，需要提供一个扩展 `RecursiveTask<T>` 类或提供一个扩展 `RecursiveAction` 的类，再覆盖 `compute` 方法来生成并调用子任务，然后合并其结果。
```java
class Counter extends RecursiveTask<Integer> {
    ...
    protected Integer compute() {
        if (to - from < THRESHOLD) {
            solve problem directly
        } else {
            int mid = (from + to) / 2;
            Counter first = new Counter(values, from, mid, filter);
            Counter second = new Counter(values, mid, to, filter);
            invokeAll(first, second);
            return first.join() + second.join();
        }
    }
}
```
在这里 `invoke` 方法接收到很多任务并阻塞，知道所有这些任务都已经完成。`join` 方法将生成结果。对每个子任务应用了 `join`，并返回其总和。

在后台，fork-join 框架使用工作密取(work stealing)的智能方法来平衡可用线程的工作负载。每个工作线程都有一个双端队列(deque)来完成任务。一个工作线程将子任务压入其双端队列的队头（只有一个线程可以访问队头，所以不需要加任何锁）。一个工作线程空闲时，它会从另一个双端队列的队尾密取一个任务。

### 可完成 Future
处理非阻塞调用的传统方法是使用事件处理器，程序员为任务完成后要执行的操作注册一个处理器。如果下一个动作也是异步的，则此后的下一个动作将是在另一个事件处理器中。

即使程序员认为“首先执行步骤1，然后执行步骤2，然后执行步骤3”，但实际上程序逻辑会分散在不同的处理程序中。当必须添加错误处理时，情况会变得更糟。 

JAVA SE 8 的 `CompletableFuture` 类提供了一种候选方法。与事件处理器不同，可完成 Future 可以组合。

假设从一个 Web 页面抽取所有链接来建立爬虫：
```java
public void CompletableFuture<String> readPage(URL url);
```
当 Web 页面可用时，使用方法 `public static List<URL> getLinks(String page)` 生成一个 HTML 页面中的 URL。可以再次调用这个方法：
```java
CompletableFuture<String> contents = readPage(url);
CompletableFuture<List<URL>> links = contents.thenApply(Parser::getLinks);
```
`thenApply` 不会阻塞，它会返回另一个 `Future`。第一个 `Future` 完成时，其结果会提供给 `getLinks` 方法，这个方法的返回值就是最终的结果。

利用可完成 Future，可以指定希望做什么，以及希望以什么顺序执行这些工作。当然，这不会立即发生，不过重要的是所有代码都放在一处。


## 同步器
java.util.concurrent 包包含了几个帮助管理相互合作的线程集的类。这些机制具有为线程之间的共用集结点模式(common rendezvous patterns)提供的预置功能(canned functionality)。如果有一个相互合作的线程集满足这些行为模式之一，那么就应该直接重用合适的类库，而不要试图提供手工的锁和条件的集合。

rendezvous 美 [ˈrɑːndɪvuː] n.约会;约会地点;(酒吧等)热门聚会场所，聚会处

同步器种类：

| 类 | 做什么 | 说明 |
|:-|:-|:-|
| CyclicBarrier | 允许线程集等待至其中预定数目的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作 | 当大量的的线程需要在它们的结果可用之前完成时 |
| Phaser | 类似于循环障栅，有一个可变的计数 | Java SE 7 引入 |
| CountDownLatch | 允许线程集等待至计数器减为 0 | 当一个或多个线程需要等待直到指定数目的事件发生 |
| Exchanger | 允许两个线程在要交换的对象准备好时交换对象 | 当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据，而另一个从实例清除数据 |
| Semaphore | 允许线程集等待直到被允许运行为止 | 限制访问资源的线程总数。如果许可数是 1，常常阻塞线程直到另一个线程给出许可为止 |
| SynchronousQueue | 允许一个线程把对象交给另一个线程 | 在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时 |

### 信号量 Semaphores
semaphore 美 [ˈseməfɔːr] n.信号标;旗语 v.打旗语;(用其他类似的信号系统)发信号

一个信号量管理许多许可证(permit)，该数量在构造函数中提供。为了通过信号量，线程通过调用 `acquire` 请求许可。（没有实际的许可对象，信号量只是维护一个计数。）由于只能使用固定数量的许可，因此信号量限制了允许通过的线程数。其他线程可以通过调用 `release` 释放许可。此外，许可不是必须由获取它的线程释放，任何线程都可以释放任意数量的许可，这可能会增加许可数目以至于超出初始数目。

### 倒计时门栓 Countdown Latches
Latch 美 [lætʃ] 锁存器;闩锁;闭锁

一个倒计时门栓让一个线程集等待直到计数变为 0。倒计时门栓是一次性的，一旦计数为 0，就不能再重用了。

一个有用的特例是计数值为 1 的门栓。实现一个只能通过一次的门栓，线程在门外等候直到另一个线程将计数器值置为 0。

### 障栅 Barriers
`CyclicBarrier` 类实现了一个集结点称为障栅。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它的那部分任务后，让它运行到障栅处。一旦所有的线程都达到了这个障栅，障栅就撤销，线程就可以继续运行。

cyclic 美[ˈsaɪklɪk] adj.循环的; 周期的;

```java
// 首先，构造一个障栅，并给出参与的线程数
CyclicBarrier barrier = new CyclicBarrier(nthreads);
// 每个线程做一些工作，完成后在障栅上调用 await
// await 方法有一个可选的超时参数
public void run() {
    doWork();
    barrier.await();
    // ...
}
```
如果任何一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了（线程可能离开是因为它调用了 `await` 时设置了超时，或者因为它被中断了）。在这种情况下，所有其他线程的 `await` 方法抛出 `BrokenBarrierException` 异常。那些已经在等待的线程立即终止 `await` 的调用。

可以提供一个可选的障栅动作，当所有线程到达障栅的时候就会执行这一动作，该动作可以收集那些单个线程的运行结果：
```java
Runnable barrierAction = ...;
CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction);
```

障栅被称为是循环的，因为可以在所有等待线程被释放后被重用，在这一点上，不同于 `CountDownLatch` 只能被使用一次。

`Phaser` 类增加了更大的灵活性，允许改变不同阶段中参与线程的个数。

### 交换器 Exchangers
当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。

### 同步队列 Synchronous Queues
同步队列是一种将生产者与消费者线程匹配的机制。当一个线程调用 `SynchronousQueue` 的 `put` 方法时，它会阻塞直到另一个线程调用 `take` 方法为止，反之亦然。与 `Exchanger` 的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。


## 线程与 Swing
使用线程的理由之一是提高程序的响应性能。当程序需要做某些耗时的工作时，应该启动一个工作器线程而不是阻塞用户接口。

但是，必须认真考虑工作器线程在做什么，Swing 不是线程安全的，如果试图在多个线程中操纵用户界面的元素，那么用户界面可能崩溃。

### 运行耗时的任务
将线程与 Swing 一起使用时，必须遵循两个简单的原则：

1) 如果一个动作需要花费很长时间，在一个独立的工作器线程中做这件事，不要在事件分配线程中做。

2) 除了事件分配线程外，不要在任何线程中接触 Swing 组件。

如果花很多时间在事件分配线程上，应用程序像死了一样，因为它不响应任何事件。特别是，事件分配线程永远不要进行 input/output 调用，这有可能会阻塞，并且应该永远不要调用 `sleep`。（如果需要等待指定时间，使用定时器事件。）

在任何线程中，可以使用两种有效的方法向事件队列添加任意的动作。不可以从自己的线程接触 Swing 组件，而应该使用 `EventQueue` 类的 `invokeLater` 方法和 `invokeAndWait` 方法使所调用的方法在事件分配线程中执行。

应该将 Swing 代码放置到实现 `Runnable` 接口的类的 `run` 方法中，然后创建该类的一个对象，将其传递给静态的 `invokeLater` 或 `invokeAndWait` 方法。

当事件放入事件队列时，`invokeLater` 方法立即返回，而 `run` 方法被异步执行。`invokeAndWait` 方法等待直到 `run` 方法确实被执行过为止。

这两种方法都是在事件分配线程中执行 `run` 方法，没有新的线程被创建。


### 使用 Swing 工作线程

### 单一线程规则


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8