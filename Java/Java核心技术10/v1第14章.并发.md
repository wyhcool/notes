---
title: 并发
date: 2019-03-22 10:40:00
tags:
categories:
- Java
---

操作系统的多任务(multitasking)是指在同一时刻运行多个程序的能力。

多线程程序是在较低的层次上扩展了多任务(multitasking)的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

多进程与多线程有哪些区别呢？本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在某些操作系统中，与进程相比较，线程更轻量级，创建、撤销一个线程比启动新进程的开销要小得多。

## 什么是线程
调用 `Thread.sleep` 方法不会创建一个新线程，而是用于暂停当前线程的活动。`sleep` 方法可以抛出一个 `InterruptedException` 异常。

在没有使用多线程时，用户很难让它执行多个任务。必须等待上一个过程执行完毕才能与程序进行交互。

### 使用线程给其他任务提供机会
可以将移动球的代码放置在一个独立的线程中，运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球，每个球都在自己的线程中运行。

另外，AWT 的事件分配线程(event dispatch thread)将一直地并行运行，以处理用户界面的事件。由于每个线程都有机会得以运行，所在在球弹跳期间，当用户点击 Close 按钮时，事件调度线程将有机会关注到这个事件，并处理关闭动作。

通常，需要警惕任何长时间运行的计算，这计算可能是更大的框架（例如 GUI 或 Web 框架）的一部分。每当框架调用方法时，通常都会期望快速的返回。如果需要执行任何耗时的任务，则应当并发地运行任务。

在一个单独地线程中执行一个任务的过程：
1) 将任务代码移到实现了 `Runnable` 接口的类的 `run` 方法中，这个接口只有一个方法，是一个函数式接口，可以用 lambda 表达式建立一个实例：
```java
public interface Runnable {
    void run();
}

Runnable r = () -> { /* task code */ }
```
2) 由 `Runnable` 创建一个 `Thread` 对象：
```java
Thread t = new Thread(r);
```
3) 启动线程：
```java
t.start();
```

将弹跳球代码放在一个独立的线程中，只需要实现一个类 `BallRunnable`，然后将动画代码放在 run 方法中：
```java
new Thread(()-> {
    try {
        for (int i = 1; i <= STEPS; i++) {
            ball.move(comp.getBounds());
            comp.repaint();
            Thread.sleep(DELAY);
        }
    } catch (InterruptedException e) {

    }
}).start();
```
在一般情况下，线程在中断时被终止。因此，当发生 `InterruptedException` 异常时，`run` 方法将结束执行。

应该将要并行运行的任务与运行机制解耦合，如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。

警告⚠️：不要调用 `Thread` 类或 `Runnable` 对象的 `run` 方法。直接调用 `run` 方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 `Thread.start` 方法，这个方法将创建一个执行 `run` 方法的新线程。


## 中断线程
当线程的 `run` 方法执行方法体中最后一条语句后，并经由执行 `return` 语句返回，或者出现了在方法中没有捕获的异常时，线程将终止。

在 Java 的早期版本中，有一个 `stop` 方法，另一个线程可以调用该方法来终止线程，但是这个方法现在已经被废弃。

除了不推荐使用的 `stop` 方法之外，没有其他方法可以强制线程终止。但是，`interrupt` 中断方法可用于请求线程终止。

当对一个线程调用 `interrupt` 方法时，线程的中断状态(interrupted status)将被置位，这是每一个线程都具有的 `boolean` 标志，每个线程都应不时地检查这个标志，以判断线程是否被中断。

判断中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法：
```java
while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
    // do more work
}
```
但是，线程如果被阻塞，就无法检测中断状态，这是产生 `InterruptedException` 异常的地方。当在一个被阻塞的线程(调用 `sleep` 或 `wait`)上调用 `interrupt` 方法时，阻塞调用将会被 `InterruptedException` 异常中断。（如果存在不能被中断的阻塞 `I/O` 调用，应该考虑选择可中断的调用。）

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要，以至于它们应该在处理完异常后，继续执行，而不理会中断。但更普遍的是，线程简单地将中断解释为终止的请求，这样的线程的 `run` 方法具有以下形式：
```java
Runnable r = () -> {
    try {
        //...
        while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
            // do more work
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```

如果在每次迭代之后调用 `sleep` 方法（或其他的可中断方法），则 `isInterrupted` 检查既不必要也不有用。如果在设置了中断状态时调用了 `sleep` 方法，则它不会进入睡眠状态。 而是清除状态并引发 `InterruptedException`。因此，如果循环调用 `sleep` 时，不要检查中断状态。而是捕获 `InterruptedException`，如下所示：
```java
Runnable r = () -> {
    try {
        //...
        while (/* more work to do */) {
            // do more work
            Thread.sleep(delay);
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```
注意⚠️：有两个非常类似的方法，`interrupted` 方法是一个静态方法，它检测当前的线程是否被中断，此外，调用 `interrupted` 方法会清除线程的中断状态。另一方面，`isInterrupted` 方法是一个实例方法，可用于检查是否有任何线程被中断，调用它不会更改中断状态。


## 线程状态
线程可以有 6 种状态：
- new（新创建）
- runnable（可运行）
- blocked（被阻塞）
- waiting（等待）
- timed waiting（计时等待）
- terminated（被终止）

要确定一个线程的状态，可调用 `getState` 方法。

### 新创建线程
当用 `new` 操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是 `new`。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 可运行线程
一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

现在所有的桌面以及服务器操作系统都使用抢占式调度，但是，在一些小型设备上可能使用协作式调度：一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。如果线程的数目多于处理器的数目，调度器依然采用时间片机制。

在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行，这就是为什么将这个状态称为“可运行(runnable)”而不是“运行(running)”。

### 被阻塞线程和等待线程
当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

1) 当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的`Lock`），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

2) 当线程等待另一个线程将条件通知调度器时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 java.util.concurrent 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，阻塞状态与等待状态之间的差异并不明显。

3) 有几个方法有一个超时参数，调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 以及 `Object.wait`、`Thread.join`、`Lock.tryLock` 和 `Condition.await` 的定时版本。

当一个线程被阻塞或等待时（或终止时）另一个线程将被调度为运行状态。

当一个线程被重新激活时（例如，因为超时期满或者成功地获得了一个锁），调度器将检查它是否具有比当前运行线程更高的优先级，如果是这样，调度器从当前运行的线程中挑选一个，剥夺其运行权，选择一个新的线程运行。

### 被终止的线程
线程因如下两个原因之一而被终止：
- 因为 `run` 方法正常推出而自然死亡。
- 因为一个没有捕获的异常终止了 `run` 方法而意外死亡。

特别是，可以调用线程的 `stop` 方法杀死一个线程，该方法抛出 `ThreadDeath` 错误对象，由此杀死线程。但是 `stop` 方法已过时，勿使用。

```
        新创建
          |
          | 开始
          |     ------------- 请求锁 -----------> 被阻塞
          |    / <----------  得到锁 ---------------|
          |   /
        可运行 _____------------- 等待通知 ----------> 等待
          |  \     <------------ 出现通知 -------------|
          |   \
          |    \_____------- 等待超时或通知 ---------> 计时等待
          |          <------ 出现超时或通知 --------------|
          |
          | 运行方法
          | exits
          |
        被终止
```


## 线程属性


## 同步


## 阻塞队列


## 线程安全的集合


## Collable 与 Future


## 执行器


## 同步器


## 线程与 Swing


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


