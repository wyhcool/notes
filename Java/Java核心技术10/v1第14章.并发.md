---
title: 并发
date: 2019-03-22 10:40:00
tags:
categories:
- Java
---

操作系统的多任务(multitasking)是指在同一时刻运行多个程序的能力。

多线程程序是在较低的层次上扩展了多任务(multitasking)的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

多进程与多线程有哪些区别呢？本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在某些操作系统中，与进程相比较，线程更轻量级，创建、撤销一个线程比启动新进程的开销要小得多。

## 什么是线程
调用 `Thread.sleep` 方法不会创建一个新线程，而是用于暂停当前线程的活动。`sleep` 方法可以抛出一个 `InterruptedException` 异常。

在没有使用多线程时，用户很难让它执行多个任务。必须等待上一个过程执行完毕才能与程序进行交互。

### 使用线程给其他任务提供机会
可以将移动球的代码放置在一个独立的线程中，运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球，每个球都在自己的线程中运行。

另外，AWT 的事件分配线程(event dispatch thread)将一直地并行运行，以处理用户界面的事件。由于每个线程都有机会得以运行，所在在球弹跳期间，当用户点击 Close 按钮时，事件调度线程将有机会关注到这个事件，并处理关闭动作。

通常，需要警惕任何长时间运行的计算，这计算可能是更大的框架（例如 GUI 或 Web 框架）的一部分。每当框架调用方法时，通常都会期望快速的返回。如果需要执行任何耗时的任务，则应当并发地运行任务。

在一个单独地线程中执行一个任务的过程：
1) 将任务代码移到实现了 `Runnable` 接口的类的 `run` 方法中，这个接口只有一个方法，是一个函数式接口，可以用 lambda 表达式建立一个实例：
```java
public interface Runnable {
    void run();
}

Runnable r = () -> { /* task code */ }
```
2) 由 `Runnable` 创建一个 `Thread` 对象：
```java
Thread t = new Thread(r);
```
3) 启动线程：
```java
t.start();
```

将弹跳球代码放在一个独立的线程中，只需要实现一个类 `BallRunnable`，然后将动画代码放在 run 方法中：
```java
new Thread(()-> {
    try {
        for (int i = 1; i <= STEPS; i++) {
            ball.move(comp.getBounds());
            comp.repaint();
            Thread.sleep(DELAY);
        }
    } catch (InterruptedException e) {

    }
}).start();
```
在一般情况下，线程在中断时被终止。因此，当发生 `InterruptedException` 异常时，`run` 方法将结束执行。

应该将要并行运行的任务与运行机制解耦合，如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。

警告⚠️：不要调用 `Thread` 类或 `Runnable` 对象的 `run` 方法。直接调用 `run` 方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 `Thread.start` 方法，这个方法将创建一个执行 `run` 方法的新线程。


## 中断线程
当线程的 `run` 方法执行方法体中最后一条语句后，并经由执行 `return` 语句返回，或者出现了在方法中没有捕获的异常时，线程将终止。

在 Java 的早期版本中，有一个 `stop` 方法，另一个线程可以调用该方法来终止线程，但是这个方法现在已经被废弃。

除了不推荐使用的 `stop` 方法之外，没有其他方法可以强制线程终止。但是，`interrupt` 中断方法可用于请求线程终止。

当对一个线程调用 `interrupt` 方法时，线程的中断状态(interrupted status)将被置位，这是每一个线程都具有的 `boolean` 标志，每个线程都应不时地检查这个标志，以判断线程是否被中断。

判断中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法：
```java
while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
    // do more work
}
```
但是，线程如果被阻塞，就无法检测中断状态，这是产生 `InterruptedException` 异常的地方。当在一个被阻塞的线程(调用 `sleep` 或 `wait`)上调用 `interrupt` 方法时，阻塞调用将会被 `InterruptedException` 异常中断。（如果存在不能被中断的阻塞 `I/O` 调用，应该考虑选择可中断的调用。）

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要，以至于它们应该在处理完异常后，继续执行，而不理会中断。但更普遍的是，线程简单地将中断解释为终止的请求，这样的线程的 `run` 方法具有以下形式：
```java
Runnable r = () -> {
    try {
        //...
        while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
            // do more work
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```

如果在每次迭代之后调用 `sleep` 方法（或其他的可中断方法），则 `isInterrupted` 检查既不必要也不有用。如果在设置了中断状态时调用了 `sleep` 方法，则它不会进入睡眠状态。 而是清除状态并引发 `InterruptedException`。因此，如果循环调用 `sleep` 时，不要检查中断状态。而是捕获 `InterruptedException`，如下所示：
```java
Runnable r = () -> {
    try {
        //...
        while (/* more work to do */) {
            // do more work
            Thread.sleep(delay);
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```
注意⚠️：有两个非常类似的方法，`interrupted` 方法是一个静态方法，它检测当前的线程是否被中断，此外，调用 `interrupted` 方法会清除线程的中断状态。另一方面，`isInterrupted` 方法是一个实例方法，可用于检查是否有任何线程被中断，调用它不会更改中断状态。


## 线程状态
线程可以有 6 种状态：
- new（新创建）
- runnable（可运行）
- blocked（被阻塞）
- waiting（等待）
- timed waiting（计时等待）
- terminated（被终止）

要确定一个线程的状态，可调用 `getState` 方法。

### 新创建线程
当用 `new` 操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是 `new`。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 可运行线程
一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

现在所有的桌面以及服务器操作系统都使用抢占式调度，但是，在一些小型设备上可能使用协作式调度：一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。如果线程的数目多于处理器的数目，调度器依然采用时间片机制。

在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行，这就是为什么将这个状态称为“可运行(runnable)”而不是“运行(running)”。

### 被阻塞线程和等待线程
当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

1) 当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的`Lock`），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

2) 当线程等待另一个线程将条件通知调度器时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 java.util.concurrent 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，阻塞状态与等待状态之间的差异并不明显。

3) 有几个方法有一个超时参数，调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 以及 `Object.wait`、`Thread.join`、`Lock.tryLock` 和 `Condition.await` 的定时版本。

当一个线程被阻塞或等待时（或终止时）另一个线程将被调度为运行状态。

当一个线程被重新激活时（例如，因为超时期满或者成功地获得了一个锁），调度器将检查它是否具有比当前运行线程更高的优先级，如果是这样，调度器从当前运行的线程中挑选一个，剥夺其运行权，选择一个新的线程运行。

### 被终止的线程
线程因如下两个原因之一而被终止：
- 因为 `run` 方法正常推出而自然死亡。
- 因为一个没有捕获的异常终止了 `run` 方法而意外死亡。

特别是，可以调用线程的 `stop` 方法杀死一个线程，该方法抛出 `ThreadDeath` 错误对象，由此杀死线程。但是 `stop` 方法已过时，勿使用。

```
        新创建
          |
          | 开始
          |     ------------- 请求锁 -----------> 被阻塞
          |    / <----------  得到锁 ---------------|
          |   /
        可运行 _____------------- 等待通知 ----------> 等待
          |  \     <------------ 出现通知 -------------|
          |   \
          |    \_____------- 等待超时或通知 ---------> 计时等待
          |          <------ 出现超时或通知 --------------|
          |
          | 运行方法
          | exits
          |
        被终止
```


## 线程属性
### 线程优先级
在 Java 中，每一个线程都有一个优先级。默认情况下，线程继承构造它的线程的优先级。可以用 `setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 `MIN_PRIORITY`（在 `Thread` 类中定义为 1）与 `MAX_PRIORITY`（定义为 10）之间的任何值，`NORM_PRIORITY` 被定义为 5。

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。

注意⚠️：绝对不要构造这样的程序，以使其正常运行取决于优先级。

警告⚠️：如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，即使这可能会完全饿死低优先级的线程。

### 守护线程
可以通过调用 `t.setDaemon(true)` 将线程转换为守护线程(daemon thread)。

守护线程的唯一用途是为其他线程提供服务。比如计时线程，它定时地发送信号给其他线程或清空过时的高速缓存项的线程，当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，就没必要继续运行程序了。

注意⚠️：守护线程永远不要访问持久性资源，例如文件或数据库，因为它可以在任何时候甚至在一个操作的中间随时终止。

### 未捕获异常处理器
线程的 `run` 方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。在这种情况下，线程就死亡了。

但是，不需要任何 `catch` 子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

该处理器必须属于一个实现 `Thread.UncaughtExceptionHandler` 接口的类，这个接口只有一个方法：
```java
void uncaughtException(Thread t, Throwable e);
```
可以用 `setUncaughtExceptionHanlder` 方法为任何线程安装一个处理器，也可以用 `Thread` 类的静态方法 `setDefaultUncaughtExceptionHandler` 为所有线程安装一个默认的处理器。替换处理程序可以使用日志记录 API 将未捕获的异常的报告发送到日志文件中。

如果不安装默认的处理器，默认的处理器为 `null`。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 `ThreadGroup` 对象。

线程组(thread group)是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于同一线程组，但是，也可以建立其他分组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。

`ThreadGroup` 类实现 `Thread.UncaughtExceptionHandler` 接口，它的 `uncaughtException` 方法做如下操作：

1) 如果该线程有父线程，那么父线程组的 `uncaughtException` 方法被调用。

2) 否则，如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器，则调用该处理器。

3) 否则，如果 `Throwable` 是 `ThreadDeath` 的一个实例，什么都不做。

4) 否则，线程的名字以及 `Throwable` 的栈轨迹被输出到 `System.err` 上。


## 同步
在多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？根据各线程访问数据的次序，可能会产生讹误的数据。这样的情况通常称为竞争条件(race condition)。

### 竞争条件
为了避免多线程引起的对共享数据的讹误，必须学会如何同步存取。

### 竞争条件详解
假设两个线程同时执行指令：
```java
accounts[to] += amount;
```
问题在于这不是原子操作，该指令可能被处理如下：
- 1) 将 `accounts[to]` 加载到寄存器。
- 2) 增加 `amount`。
- 3) 将结果写回 `accounts[to]`。

假定第一个线程执行步骤 1 和 2，然后它被剥夺了运行权。假定第二个线程被唤醒并修改了 `accounts` 数组中的同一项。然后，第一个线程被唤醒并完成其第 3 步。

这样，这一动作擦去了第二个线程所做的更新。

```
javap是 jdk 自带的反解析工具。它的作用就是根据 class 字节码文件，反解析出当前类对应的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。

查看执行类中的每一个语句的虚拟机字节码，运行命令：
javap -c -v Bank
--------------------------------------------------------------------------------
Classfile Bank.class
  Last modified Mar 28, 2020; size 1439 bytes
  MD5 checksum fb066f73ca84623fa463a4cf36c71355
  Compiled from "UnsynchBankTest.java"
class Bank
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #8.#44         // java/lang/Object."<init>":()V
   #2 = Fieldref           #14.#45        // Bank.accounts:[D
   #3 = Methodref          #46.#47        // java/util/Arrays.fill:([DD)V
   #4 = Fieldref           #48.#49        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #50.#51        // java/lang/Thread.currentThread:()Ljava/lang/Thread;
   #6 = Methodref          #52.#53        // java/io/PrintStream.print:(Ljava/lang/Object;)V
   #7 = String             #54            // %10.2f from %d to %d
   #8 = Class              #55            // java/lang/Object
   #9 = Methodref          #56.#57        // java/lang/Double.valueOf:(D)Ljava/lang/Double;
  #10 = Methodref          #58.#59        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
  #11 = Methodref          #52.#60        // java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #12 = String             #61            //  Total Balance: %10.2f%n
  #13 = Methodref          #14.#62        // Bank.getTotalBalance:()D
  #14 = Class              #63            // Bank
  #15 = Utf8               accounts
  #16 = Utf8               [D
  #17 = Utf8               <init>
  #18 = Utf8               (ID)V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               LBank;
  #24 = Utf8               n
  #25 = Utf8               I
  #26 = Utf8               initialBalance
  #27 = Utf8               D
  #28 = Utf8               transfer
  #29 = Utf8               (IID)V
  #30 = Utf8               from
  #31 = Utf8               to
  #32 = Utf8               amount
  #33 = Utf8               StackMapTable
  #34 = Utf8               getTotalBalance
  #35 = Utf8               ()D
  #36 = Utf8               a
  #37 = Utf8               sum
  #38 = Class              #63            // Bank
  #39 = Class              #16            // "[D"
  #40 = Utf8               size
  #41 = Utf8               ()I
  #42 = Utf8               SourceFile
  #43 = Utf8               UnsynchBankTest.java
  #44 = NameAndType        #17:#64        // "<init>":()V
  #45 = NameAndType        #15:#16        // accounts:[D
  #46 = Class              #65            // java/util/Arrays
  #47 = NameAndType        #66:#67        // fill:([DD)V
  #48 = Class              #68            // java/lang/System
  #49 = NameAndType        #69:#70        // out:Ljava/io/PrintStream;
  #50 = Class              #71            // java/lang/Thread
  #51 = NameAndType        #72:#73        // currentThread:()Ljava/lang/Thread;
  #52 = Class              #74            // java/io/PrintStream
  #53 = NameAndType        #75:#76        // print:(Ljava/lang/Object;)V
  #54 = Utf8               %10.2f from %d to %d
  #55 = Utf8               java/lang/Object
  #56 = Class              #77            // java/lang/Double
  #57 = NameAndType        #78:#79        // valueOf:(D)Ljava/lang/Double;
  #58 = Class              #80            // java/lang/Integer
  #59 = NameAndType        #78:#81        // valueOf:(I)Ljava/lang/Integer;
  #60 = NameAndType        #82:#83        // printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #61 = Utf8                Total Balance: %10.2f%n
  #62 = NameAndType        #34:#35        // getTotalBalance:()D
  #63 = Utf8               Bank
  #64 = Utf8               ()V
  #65 = Utf8               java/util/Arrays
  #66 = Utf8               fill
  #67 = Utf8               ([DD)V
  #68 = Utf8               java/lang/System
  #69 = Utf8               out
  #70 = Utf8               Ljava/io/PrintStream;
  #71 = Utf8               java/lang/Thread
  #72 = Utf8               currentThread
  #73 = Utf8               ()Ljava/lang/Thread;
  #74 = Utf8               java/io/PrintStream
  #75 = Utf8               print
  #76 = Utf8               (Ljava/lang/Object;)V
  #77 = Utf8               java/lang/Double
  #78 = Utf8               valueOf
  #79 = Utf8               (D)Ljava/lang/Double;
  #80 = Utf8               java/lang/Integer
  #81 = Utf8               (I)Ljava/lang/Integer;
  #82 = Utf8               printf
  #83 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
{
  public Bank(int, double);
    descriptor: (ID)V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=3
         0: aload_0  //从本地变量表中加载索引为0的变量的值，也即 this 的引用，压入栈
         1: invokespecial #1  //出栈，调用java/lang/Object."<init>":()V 初始化对象，就是this指定的对象的init()方法完成初始化
         4: aload_0
         5: iload_1
         6: newarray       double
         8: putfield      #2                  // Field accounts:[D
        11: aload_0
        12: getfield      #2                  // Field accounts:[D
        15: dload_2
        16: invokestatic  #3                  // Method java/util/Arrays.fill:([DD)V
        19: return
      LineNumberTable:
        line 46: 0
        line 47: 4
        line 48: 11
        line 49: 19
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      20     0  this   LBank;
            0      20     1     n   I
            0      20     2 initialBalance   D

  public void transfer(int, int, double);
    descriptor: (IID)V
    flags: ACC_PUBLIC
    Code:
      stack=7, locals=5, args_size=4
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: iload_1
         5: daload
         6: dload_3
         7: dcmpg
         8: ifge          12
        11: return
        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: invokestatic  #5                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
        18: invokevirtual #6                  // Method java/io/PrintStream.print:(Ljava/lang/Object;)V
        21: aload_0
        22: getfield      #2                  // Field accounts:[D
        25: iload_1
        26: dup2
        27: daload
        28: dload_3
        29: dsub
        30: dastore
        31: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        34: ldc           #7                  // String %10.2f from %d to %d
        36: iconst_3
        37: anewarray     #8                  // class java/lang/Object
        40: dup
        41: iconst_0
        42: dload_3
        43: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        46: aastore
        47: dup
        48: iconst_1
        49: iload_1
        50: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        53: aastore
        54: dup
        55: iconst_2
        56: iload_2
        57: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        60: aastore
        61: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        64: pop
        65: aload_0
        66: getfield      #2                  // Field accounts:[D
        69: iload_2
        70: dup2
        71: daload
        72: dload_3
        73: dadd
        74: dastore
        75: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        78: ldc           #12                 // String  Total Balance: %10.2f%n
        80: iconst_1
        81: anewarray     #8                  // class java/lang/Object
        84: dup
        85: iconst_0
        86: aload_0
        87: invokevirtual #13                 // Method getTotalBalance:()D
        90: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        93: aastore
        94: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        97: pop
        98: return
      LineNumberTable:
        line 52: 0
        line 53: 11
        line 55: 12
        line 56: 21
        line 57: 31
        line 58: 65
        line 59: 75
        line 60: 98
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      99     0  this   LBank;
            0      99     1  from   I
            0      99     2    to   I
            0      99     3 amount   D
      StackMapTable: number_of_entries = 1
        frame_type = 12 /* same */

  public double getTotalBalance();
    descriptor: ()D
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=8, args_size=1
         0: dconst_0
         1: dstore_1
         2: aload_0
         3: getfield      #2                  // Field accounts:[D
         6: astore_3
         7: aload_3
         8: arraylength
         9: istore        4
        11: iconst_0
        12: istore        5
        14: iload         5
        16: iload         4
        18: if_icmpge     38
        21: aload_3
        22: iload         5
        24: daload
        25: dstore        6
        27: dload_1
        28: dload         6
        30: dadd
        31: dstore_1
        32: iinc          5, 1
        35: goto          14
        38: dload_1
        39: dreturn
      LineNumberTable:
        line 63: 0
        line 64: 2
        line 65: 27
        line 64: 32
        line 67: 38
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           27       5     6     a   D
            0      40     0  this   LBank;
            2      38     1   sum   D
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 14
          locals = [ class Bank, double, class "[D", int, int ]
          stack = []
        frame_type = 248 /* chop */
          offset_delta = 23

  public int size();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: arraylength
         5: ireturn
      LineNumberTable:
        line 71: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LBank;
}
SourceFile: "UnsynchBankTest.java"
```
注意🌿：代码行 `accounts[to] += amount;` 增值命令是由几条指令组成的，执行它们的线程可以在任何一条指令点上被中断。

真正的问题是 `transfer` 方法的执行过程中可能被中断。如果能够确保线程在失去控制之前方法运行完成，那么就不会出现数据讹误。

### 锁对象
有两种机制防止代码块受并发访问的干扰，Java 语言为此提供一个 `synchronized` 关键字达到这一目的，而在 Java SE 5.0 引入了 `ReentrantLock` 类。

synchronized 美[ˈsɪŋkrənaɪzd] v.(使) 同步，在时间上一致，同速进行;
synchronize的过去分词和过去式;

reentrant 美[ˌriˈɛntrənt] adj.可重入; 可重入的; 重入; 可再入的; 重进入;

`synchronized` 关键字自动提供一个锁以及相关的条件，对于大多数需要显式锁的情况，这是很便利的。`java.util.concurrent` 框架为这些基础机制提供独立的类。

使用 `ReentrantLock` 保护代码块的基本结构如下：
```java
myLock.lock(); // a ReentrantLock object
try {
    // critical section
}
finally {
    myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown
}
```
这一结构确保任何时刻只有一个线程进入临界区，一旦一个线程封锁了锁对象，其他任何线程都无法通过 `lock` 语句。当其他线程调用 `lock` 时，它们被阻塞，直到第一个线程释放锁对象。

警告：把解锁操作放在 `finally` 子句之中是至关重要的，如果在临界区的代码抛出异常，锁必须被释放，否则，其他线程将永远阻塞。

如果使用锁，就不能使用带资源的 `try` 语句。首先，解锁方法名不是 `close`，不过，即使将它重命名，带资源的 `try` 语句也无法正常工作。它的首部希望声明一个新变量，但是如果使用的是一个锁，那么会是多个线程共享的那个变量。

假定一个线程调用 `transfer`，在执行结束前被剥夺了运行权。假设第二个线程也调用 `transfer`，由于第二个线程不能获得锁，将在调用 `lock` 方法时被阻塞。它必须等待第一个线程完成 `transfer` 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行。

注意每一个 `Bank` 对象有自己的 `ReentrantLock` 对象。如果两个线程视图访问同一个 `Bank` 对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的 `Bank` 对象，每个线程得到不同的锁对象，两个线程都不会发生阻塞。因为线程在操纵不同的 `Bank` 实例时，线程之间不会相互影响。

锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对 `lock` 方法的嵌套调用。线程在每一次调用 `lock` 都要调用 `unlock` 来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。

`transfer` 方法调用 `getTotalBalance` 方法，这也会封锁 `bankLock` 对象，此时 `bankLock` 对象的持有计数为 2。当 `getTotalBalance` 方法退出的时候，持有计数变回 1。当 `transfer` 方法退出的时候，持有计数变为 0。线程释放锁。

通常，保护需要若个操作来更新或检查共享对象的代码块，要确保这些操作完成后，另一个线程才能使用相同对象。

注意⚠️：要留心临界区的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，`finally` 子句将释放锁，但会使对象可能处于一种受损状态。

使用 `ReentrantLock(boolean fair)` 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程，但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。

警告🍓：公平锁比使用常规锁要慢得多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候才使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁。

### 条件对象 Condition Objects
通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。

条件对象，也被称为条件变量(condtion variables)。

避免选择没有足够资金的账户作为转出账户，注意不能使用下面的代码❌：
```java
if (bank.getBalance(from) >= amount) {
    // thread might be deactivated at this point
    bank.transfer(from, to, amount);
}
```
当前线程完全有可能在成功地完成测试，且在调用 `transfer` 方法之前将被中断。在线程再次运行前，账户余额可能已经低于提款金额。必须确保没有其他线程在本检查余额与转账活动之间修改余额。通过使用锁来保护检查与转账动作：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            // wait
            // ...
        }
        // transfer funds
        // ...
    } finally {
        bankLock.unlock();
    }
}
```
现在，当账户没有足够的金额时，等待直到另一个线程向账户中注入资金。但是，这一线程刚刚获得了对 `bankLock` 的排他性访问，因此别的线程没有进行存款操作的机会。

一个锁对象可以有一个或多个相关的条件对象，可以使用 `newCondtion` 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映出它所表达的条件的名字。
```java
class Bank {
    private Condtion sufficientFunds; // 余额充足条件
    // ...
    public Bank() {
        // ...
        sufficientFunds = bankLock.newCondtion();
    }
}
```
如果 `transfer` 方法发现余额不足时，调用 `sufficientFunds.await();`，当前线程现在被阻塞了，并放弃了锁。这样可以使得另一个线程可以进行增加账户余额的操作。

等待获得锁的线程和调用 `await` 方法的线程存在本质上的不同。一旦一个线程调用 `await` 方法，它进入该条件的等待集。等锁可用时，该线程不能马上解除阻塞。相反，它仍然处于阻塞状态，直到另一个线程在相同条件下调用 `signalAll` 方法为止。

当另一个线程转账时，调用 `sufficientFunds.signalAll();`，这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 `await` 调用返回，获得该锁并从被阻塞的地方继续执行。

此时，线程应该再次测试该条件。由于无法确保该条件被满足，`signalAll` 方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。

通常，对 `await` 的调用应该在如下形式的循环体中：
```java
while (!(ok to procced)) {
    condtion.await();
}
```

至关重要的是最终需要在某个其他线程中调用 `signalAll` 方法。当一个线程调用 `await` 时，它没有办法重新激活自身，它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再执行了，这将导致死锁(deadlock)现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用 `await` 方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

应该何时调用 `signalAll` 呢？在对象的状态有利于等待线程的方向改变时调用 `signalAll`。例如，当一个账户余额发生改变时，等待的线程会应该有机会检查余额：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            sufficientFunds.await();
        }
        // transfer funds
        // ...
        sufficientFunds.signalAll();
    } finally {
        bankLock.unlock();
    }
}
```
注意调用 `signalAll` 不会立即激活一个等待线程。它仅仅是解除等待线程的阻塞，以便这些线程可以在当前线程释放锁之后，通过竞争实现对对象的访问。

另一个方法 `signal`，则是随机解除`等待集`中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自身仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 `signal`，则系统死锁。

警告：当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 `await`、`signalAll` 或 `signal` 方法。

### synchronized 关键字
锁 `Lock` 和条件 `Condtion` 的关键之处：
- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 锁可以拥有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

`Lock` 和 `Condition` 接口为开发者提供了高度的锁定控制。然而，大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到 Java 语言内部的机制。

从 1.0 版本开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 `synchronized` 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用方法，线程必须获得内部的对象锁。
```java
public synchronized void method() {
    // method body
}
// 等价于
public void method() {
    this.intrinsicLock.lock();
    try {
        // method body
    } finally {
        this.intrinsicLock.unlock();
    }
}

```

intrinsic 美 [ɪn'trɪnsɪk] adj.固有的，内在的，本质的;

可以简单地声明 `Bank` 类的 `transfer` 方法为 `synchronized`，而不是使用一个显式的锁。

内部对象锁只有一个关联条件。`wait` 方法将线程添加到 `等待集` 中，`notifyAll` 或 `notify` 方法解除等待线程的阻塞状态。换言之，调用 `wait` 或 `notifyAll` 等价于：
```java
intrinsicCondition.await();
intrinsicCondition.signalAll();
```

注意：`wait`、`notifyAll` 以及 `notify` 方法是 `Object` 类的 `final` 方法。`Condition` 方法必须被命名为 `await`、`signalAll` 和 `signal` 以便它们不会与那些方法发生冲突。
```java
class Bank {
    //...
    private double[] accounts;
    //...
    public synchronized void transfer(int from, int to, int amount) throws InterruptedException {
        while (accounts[from] < amount) {
            wait(); // wait on intrinsic object lock's single condition
        }
        accounts[from] -= amount;
        accounts[to] += amount;
        notifyAll(); // notify all threads waiting on the condtion
    }
    //...
}
```
使用 `synchronized` 关键字编写代码要简洁得多。理解这段代码，需要了解每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入 `synchronized` 方法的线程，由条件来管理那些调用 `wait` 的线程。

将静态方法声明为 `synchronized` 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。如果 `Bank` 类有一个静态同步方法，那么当该方法被调用时，`Bank.class` 对象的锁被锁住，因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

内部锁和条件存在一些局限：
- 不能中断一个正在试图获得锁的线程。
- 试图获得锁时不能设定超时。
- 每个锁仅有单一的条件，可能是不够的。

使用 `Lock` 和 `Condition` 对象还是同步方法？
- 最好既不使用 `Lock`/`Condition` 也不使用 `synchronized` 关键字。在许多情况下，可以使用 java.util.concurrent 包中的一种机制，它会处理所有的加锁。
- 如果 `synchronized` 关键字适合，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
- 如果特别需要 `Lock`/`Condition` 结构提供的独有特性时，才使用  `Lock`/`Condition`。

### 同步阻塞
每一个 Java 对象有一个锁，线程可以通过调用同步方法获得锁，还可以通过进入一个同步阻塞(synchronized block)获得锁：
```java
synchoronized(obj) { // the syntax for a synchronized block
    // critical section
}
```
于是获得 obj 的锁。
```java
public class Bank {
    private double[] accounts;
    private Object lock = new Object();
    // ...
    public void transfer(int from, int to, int amount) {
        synchronized(lock) {
            accounts[from] -= amount;
            accounts[to] += amount;
        }
        // ...
    }
}
```
lock 对象被创建仅仅是用来使用每个 Java 对象持有的锁。

使用一个对象的锁来实现额外的原子操作，实际上称为客户端锁定(client-side locking)。

考虑 `Vector` 类，一个列表，它的方法是同步的：
```java
public void transfer(int from, int to, int amount) {
    accounts.set(from, accounts.get(from) - amount);
    accounts.set(to, accounts.get(to) + amount);
    // ...
}
```
虽然 `Vector` 类的 `get` 和 `set` 方法是同步的，但这对于上述程序没有什么帮助。在第一次 `get` 的调用已经完成之后，一个线程完全可能在 `transfer` 方法中被剥夺运行权。然后另一个线程可以将不同的值存储到同一位置。但是，我们可以劫持锁：
```java
public void transfer(int from, int to, int amount) {
    synchronized (accounts) {
        accounts.set(from, accounts.get(from) - amount);
        accounts.set(to, accounts.get(to) + amount);
        // ...
    }
}
```
注意：这个方法可以工作，但是完全依赖于一个事实：`Vector` 类对自己的所有可修改方法都使用内部锁。故，客户端锁定是非常脆弱的，不推荐使用。

### 监视器概念
监视器具有如下特性：
- 监视器是只包含私有域的类。
- 每个监视器类的对象有一个相关的锁。
- 使用该锁对所有对方法进行加锁。如果客户端调用 `obj.method()`，那么 obj 对象的锁是在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域。
- 该锁可以有任意多个相关条件。

Java 中每一个对象有一个内部的锁和内部的条件。如果一个方法用 `synchronized` 关键字声明，那么，它表现得就像是一个监视器方法，通过调用 `wait`/`notifyAll`/`notify` 来访问条件变量。

然而，下述的 3 个方法 Java 对象不同于监视器，从而使得线程的安全性下降：
- 域不要求必须是 `private`。
- 方法不要求必须是 `synchronized`。
- 内部锁对用户是可用的。

### volatile 域
volatile 美[ˈvɑːlətl] adj.易变的; 无定性的;

读写实例域，出错的可能性很大：
- 多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值，结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
- 编译器可以改变指令执行的顺序以使吞吐量最大化，这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变。

如果使用锁来保护被多个线程访问的代码，那么可以不用考虑这种问题，编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令。

同步格言：如果向一个变量写入值，而这个变量接下来可能会被另一个线程读取，或者，从一个变量读值，而这个变量可能是之前被另一个写入的，此时必须使用同步。

`volatile` 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 `volatile`，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

假定一个对象有一个布尔标记 `done`，它的值被一个线程设置却被另一个线程查询：
```java
private boolean done;
public synchronized boolean isDone() { return done; }
public synchronized void setDone() { done = true; }
```
如果另一个线程已经对该对象加锁，`isDone` 和 `setDone` 方法可能阻塞。或者，可以新建一个线程为这一变量使用独立的 `Lock`，但是这样开销过大了。在这种情况下，将域声明为 `volatile` 是合理的：
```java
private volatile boolean done;
public boolean isDone() { return done; }
public void setDone() { done = true; }
```

注意⚠️：`volatile` 变量不能提供原子性：
```java
public void flipDone() { done = !done; } // not atomic
```
不能确保翻转域中的值，不能保证读取、翻转和写入不被中断。

### final 变量
除非使用锁或 `volatile` 修饰符，否则无法从多个线程安全地读取一个域。

还有一种情况可以安全地访问一个共享域，即这个域声明为 `final` 时。

以下声明：
```java
final Map<String, Double> accounts = new HashMap<>();
```
其他线程会在构造函数完成构造之后才看到这个 `accounts` 变量。

如果不使用 `final`，就不能保证其他线程看到的是 `accounts` 更新后的值，它们可能都只是看到 `null`，而不是新构造的 `HashMap`。

当然，对这个映射表的操作并不是线程安全的。如果有多个线程在读写这个映射表，仍然需要进行同步。

### 原子性
假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 `volatile`。

java.util.concurrent.atomic 包中很多类使用了很高效的机器级指令，而不是使用锁来保证其他操作的原子性。例如，`AtomicInteger` 类提供了方法 `incrementAndGet` 和 `decrementAndGet`，它们分别以原子方式将一个整数自增或自减。
```java
public static AtomicLong nextNumber = new AtomicLong();

// in some thread
long id = nextNumber.incrementAndGet();
```
`incrementAndGet` 方法以原子方式将 `nextNumber` 自增，并返回自增后的值。也就是说，获得值、增 1 并设置然后生成新值的操作不会中断。可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

atomic 美[əˈtɑːmɪk] adj.原子的; 与原子有关的; 原子能的; 原子武器的;

跟踪不同线程观察的最大值，下面的代码是不可行的：
```java
public static AtomicLong largest = new AtomicLong();

// in some thread
largest.set(Math.max(larget.get()), observed); // Error - race condtion!
```
这个更新不是原子的，实际上，应该在一个循环中计算新值和使用 `CompareAndSet`：
```java
do {
    oldValue = largest.get();
    newValue = Math.max(oldValue, observed);
} while (!largest.compareAndSet(oldValue, newValue));
```
如果另一个线程也在更新 `largest`，就可能阻止这个线程更新，这样一来，`compareAndSet` 返回 `false`，而不会设置新值。在这种情况下，循环会更新尝试，读取更新后的值，并尝试修改。最终，它会成功地用新值替换原来的值。这听上去有些麻烦，不过 `compareAndSet` 方法会映射到一个处理器操作，比使用锁的速度更快。

在 Java SE 8 中，不再需要编写循环代码，可以提供一个 lambda 表达式更新变量：
```java
largest.updateAndGet(x -> Math.max(x, observed));
// 或
largest.accumulateAndGet(observed, Math::max);
```
`accumulateAndGet` 方法利用一个二元操作符来合并原子值和所提供的参数。

`getAndUpdate` 和 `getAndAccumulate` 方法可以返回原值。

类 `AtomicInteger`、`AtomicIntegerArray`、`AtomicIntegerFieldUpdate`、`AtomicLongArray`、`AtomicLongFieldUpdate`、`AtomicReference`、`AtomicRefenceArray` 和 `AtomicReferenceFieldUpdate` 也提供了这些方法。

如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8 提供了 `LongAdder` 和 `LongAccumulator` 类来解决这个问题。`LongAdder` 包括多个变量(加数)，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效，性能会有显著的提升。

如果认为可能存在大量竞争，只需要使用 `LongAdder` 而不是 `AtomicLong`。调用 `increment` 让计数器自增，或者调用 `add` 来增加一个量，或者调用 `sum` 来获得总和：
```java
final LongAdder adder = new LongAdder();
for (...) {
    pool.submit(() -> {
        while (...) {
            ...
            if (...) {
                adder.increment();
            }
        }
    })
}
...
long total = adder.sum();
```
注意⚠️：`increment` 方法不会返回原值，如果那样做会消除求和分解到多个加数所带来的性能提升。

`LongAccumulator` 将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。要加入新的值，可以调用 `accumulate`。调用 `get` 来获得当前值：
```java
LongAccumulator adder = new LongAccumulator(Long::sum, 0);

// in some thread
adder.accumulate(value);
```
在内部，这个累加器包含变量 a<sub>1</sub>、a<sub>2</sub>、... a<sub>n</sub>，每个变量初始化为零元素。

调用 `accumulate` 并提供值 v 时，其中一个变量会以原子形式更新为 a<sub>i</sub> = a<sub>i</sub> op v，这里的 op 是中缀形式的累加操作。

调用 `get` 的结果是 a<sub>1</sub> op a<sub>2</sub> op ... op a<sub>n</sub>。

### 死锁 deadlock
锁和条件不能解决多线程中的所有问题。

因为账户1 以及账户2 中的余额都不足以进行转账，有可能因为每一个线程都要等待更多的钱款存入而导致所有的线程都被阻塞，这样的状态称为死锁。

导致死锁的另一个途径是让第 i 个线程负责向第 i 个账户存钱，而不是从第 i 个账户取钱。这样一来，有可能将所有的线程都集中一个账户上，每一个线程都试图从这个账户取出大于该账户余额的钱。

还有一种很容易发生死锁的情况：将 `signalAll` 方法换为 `signal`，`signalAll` 通知所有等待增加资金的线程，而 `signal` 方法仅仅对一个线程解锁，如果该线程不能继续运行，所有的线程可能都被阻塞。

Java 编程语言中没有任何东西可以避免或打破这种死锁现象，必须仔细设计程序，以确保不会出现死锁。

### 线程局部变量
在线程间共享变量有风险，使用 `ThreadLocal` 辅助类为各个线程提供各自的实例。例如，`SimpleDateFormat` 类不是线程安全的，假设有一个静态变量：
```java
public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
```
如果有两个线程都执行以下操作：
```java
String dateStamp = dateFormat.format(new Date());
```
`dateFormat` 使用的内部数据结构可能会被并发的访问所破坏。

要为每个线程构造一个实例，可以使用下列代码：
```java
public static final ThreadLocal<SimpleDateFormat> dateFormat = ThreadLocal().withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

要访问具体的格式化方法，可以调用：
```java
String dateStamp = dateFormat.get().format(new Date());
```
在一个给定线程中首次调用 `get` 时，会调用 `initialValue` 方法，在此之后，`get` 方法会返回属于当前线程的那个实例。

java.util.Random 类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器，这样会很低效，可以使用 `ThreadLocal` 辅助类为每个线程提供一个单独的生成器。在 Java SE 7 中另外提供了一个便利类， `ThreadLocalRandom.current()` 调用会返回特定于当前线程的 `Random` 类实例：
```java
int random = ThreadLocalRandom.current().nextInt(upperBound);
```

### 锁测试与超时
线程在调用 `lock` 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞，应该谨慎地申请锁。

`tryLock` 方法试图申请一个锁，在成功获得锁后返回 `true`，否则，立即返回 `false`，而且线程可以立即离开去做其他事情。
```java
if (myLock.tryLock()) {
    // now the thread owns the lock
    try {
        // ...
    } finally {
        myLock.unlock();
    }
} else {
    // do something else
}
```
可以调用 `tryLock` 时，使用超时参数：
```java
if (myLock.tryLock(100, TimeUnit.MILISECONDS)) { ... }
```

`lock` 方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，`lock` 方法无法终止。然而，如果调用带有超时参数的 `tryLock`，那么如果线程在等待期间被中断，将抛出 `InterruptedException` 异常。这是一个非常有用的特性，因为允许程序打破死锁。

也可以调用 `lockInterruptibly` 方法，它就相当于一个超时设为无限的 `tryLock` 方法。

在等待一个条件时，也可以提供一个超时：
```java
myCondtion.await(100, TimeUnit.MILISECONDS);
```
如果一个线程被另一个线程通过调用 `signalAll` 或 `signal` 激活，或者超时时限已达到，或者线程被中断，那么 `await` 方法将返回。

如果等待的线程被中断，`await` 方法将抛出一个 `InterruptedException` 异常。

### 读／写锁
java.util.concurrent.locks 包中定义了两个锁类，`ReentrantLock` 类和 `ReentrantReadWriteLock` 类。

如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，后者是十分有用的。在这种情况下，允许对读线程共享访问是合适的，对写线程依然必须是互斥访问的。

使用读／写锁的步骤：

1) 构造一个 `ReentrantReadWriteLock` 对象：
```java
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
```

2) 抽取读锁和写锁：
```java
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
```

3) 对所有的获取方法加读锁：
```java
public double getTotalBalance() {
    readLock.lock();
    try { ... }
    finally { readLock.unlock(); }
}
```

4) 对所有的修改方法加写锁：
```java
public void transfer(...) {
    writeLock.lock();
    try { ... }
    finally { writeLock.unlock(); }
}
```

### 为什么弃用 stop 和 suspend 方法
初始的 Java 版本定义了一个 `stop` 方法用来终止一个进程，以及一个 `suspend` 方法用来阻塞一个线程直到另一个线程调用 `resume`。`stop` 和 `suspend` 方法有一些共同点：都试图控制一个给定线程的行为。

`stop` 方法终止所有未结束的方法，包括 `run` 方法。当线程被终止，立即释放被它锁住的所有对象的锁，这会导致对象处于不一致的状态。

当线程要终止另一个线程时，无法知道什么时候调用 `stop` 方法是安全的，什么时候导致对象被破坏。<font color="red">在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。</font>

`suspend` 方法不会破坏对象，如果用 `suspend` 挂起一个持有锁的线程，那么，该锁在恢复之前是不可用的。如果调用 `suspend` 方法的线程试图获得同一锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。

如果想安全地挂起线程，引入一个变量 `suspendRequested` 并在 `run` 方法的某个安全地方测试它，安全的地方是指该线程没有封锁其他线程需要的对象的地方。当线程发现 `suspendRequested` 变量已经设置，将会保持等待状态知道它再次获得为止。


## 阻塞队列


## 线程安全的集合


## Collable 与 Future


## 执行器


## 同步器


## 线程与 Swing


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


