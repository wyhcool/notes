---
title: 并发
date: 2019-03-22 10:40:00
tags:
categories:
- Java
---

操作系统的多任务(multitasking)是指在同一时刻运行多个程序的能力。

多线程程序是在较低的层次上扩展了多任务(multitasking)的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

多进程与多线程有哪些区别呢？本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在某些操作系统中，与进程相比较，线程更轻量级，创建、撤销一个线程比启动新进程的开销要小得多。

## 什么是线程
调用 `Thread.sleep` 方法不会创建一个新线程，而是用于暂停当前线程的活动。`sleep` 方法可以抛出一个 `InterruptedException` 异常。

在没有使用多线程时，用户很难让它执行多个任务。必须等待上一个过程执行完毕才能与程序进行交互。

### 使用线程给其他任务提供机会
可以将移动球的代码放置在一个独立的线程中，运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球，每个球都在自己的线程中运行。

另外，AWT 的事件分配线程(event dispatch thread)将一直地并行运行，以处理用户界面的事件。由于每个线程都有机会得以运行，所在在球弹跳期间，当用户点击 Close 按钮时，事件调度线程将有机会关注到这个事件，并处理关闭动作。

通常，需要警惕任何长时间运行的计算，这计算可能是更大的框架（例如 GUI 或 Web 框架）的一部分。每当框架调用方法时，通常都会期望快速的返回。如果需要执行任何耗时的任务，则应当并发地运行任务。

在一个单独地线程中执行一个任务的过程：
1) 将任务代码移到实现了 `Runnable` 接口的类的 `run` 方法中，这个接口只有一个方法，是一个函数式接口，可以用 lambda 表达式建立一个实例：
```java
public interface Runnable {
    void run();
}

Runnable r = () -> { /* task code */ }
```
2) 由 `Runnable` 创建一个 `Thread` 对象：
```java
Thread t = new Thread(r);
```
3) 启动线程：
```java
t.start();
```

将弹跳球代码放在一个独立的线程中，只需要实现一个类 `BallRunnable`，然后将动画代码放在 run 方法中：
```java
new Thread(()-> {
    try {
        for (int i = 1; i <= STEPS; i++) {
            ball.move(comp.getBounds());
            comp.repaint();
            Thread.sleep(DELAY);
        }
    } catch (InterruptedException e) {

    }
}).start();
```
在一般情况下，线程在中断时被终止。因此，当发生 `InterruptedException` 异常时，`run` 方法将结束执行。

应该将要并行运行的任务与运行机制解耦合，如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。

警告⚠️：不要调用 `Thread` 类或 `Runnable` 对象的 `run` 方法。直接调用 `run` 方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 `Thread.start` 方法，这个方法将创建一个执行 `run` 方法的新线程。


## 中断线程
当线程的 `run` 方法执行方法体中最后一条语句后，并经由执行 `return` 语句返回，或者出现了在方法中没有捕获的异常时，线程将终止。

在 Java 的早期版本中，有一个 `stop` 方法，另一个线程可以调用该方法来终止线程，但是这个方法现在已经被废弃。

除了不推荐使用的 `stop` 方法之外，没有其他方法可以强制线程终止。但是，`interrupt` 中断方法可用于请求线程终止。

当对一个线程调用 `interrupt` 方法时，线程的中断状态(interrupted status)将被置位，这是每一个线程都具有的 `boolean` 标志，每个线程都应不时地检查这个标志，以判断线程是否被中断。

判断中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程，然后调用 `isInterrupted` 方法：
```java
while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
    // do more work
}
```
但是，线程如果被阻塞，就无法检测中断状态，这是产生 `InterruptedException` 异常的地方。当在一个被阻塞的线程(调用 `sleep` 或 `wait`)上调用 `interrupt` 方法时，阻塞调用将会被 `InterruptedException` 异常中断。（如果存在不能被中断的阻塞 `I/O` 调用，应该考虑选择可中断的调用。）

没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要，以至于它们应该在处理完异常后，继续执行，而不理会中断。但更普遍的是，线程简单地将中断解释为终止的请求，这样的线程的 `run` 方法具有以下形式：
```java
Runnable r = () -> {
    try {
        //...
        while (!Thread.currentThread().isInterrupted() /* && more work to do */) {
            // do more work
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```

如果在每次迭代之后调用 `sleep` 方法（或其他的可中断方法），则 `isInterrupted` 检查既不必要也不有用。如果在设置了中断状态时调用了 `sleep` 方法，则它不会进入睡眠状态。 而是清除状态并引发 `InterruptedException`。因此，如果循环调用 `sleep` 时，不要检查中断状态。而是捕获 `InterruptedException`，如下所示：
```java
Runnable r = () -> {
    try {
        //...
        while (/* more work to do */) {
            // do more work
            Thread.sleep(delay);
        }
    } catch (InterruptedException ex) {
        // thread was interrupted during sleep or wait
    } finally {
        // cleanup, if required
    }
    // exiting the run method termintates the thread
};
```
注意⚠️：有两个非常类似的方法，`interrupted` 方法是一个静态方法，它检测当前的线程是否被中断，此外，调用 `interrupted` 方法会清除线程的中断状态。另一方面，`isInterrupted` 方法是一个实例方法，可用于检查是否有任何线程被中断，调用它不会更改中断状态。


## 线程状态
线程可以有 6 种状态：
- new（新创建）
- runnable（可运行）
- blocked（被阻塞）
- waiting（等待）
- timed waiting（计时等待）
- terminated（被终止）

要确定一个线程的状态，可调用 `getState` 方法。

### 新创建线程
当用 `new` 操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是 `new`。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 可运行线程
一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

现在所有的桌面以及服务器操作系统都使用抢占式调度，但是，在一些小型设备上可能使用协作式调度：一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权。

在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。如果线程的数目多于处理器的数目，调度器依然采用时间片机制。

在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行，这就是为什么将这个状态称为“可运行(runnable)”而不是“运行(running)”。

### 被阻塞线程和等待线程
当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

1) 当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的`Lock`），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

2) 当线程等待另一个线程将条件通知调度器时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 java.util.concurrent 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，阻塞状态与等待状态之间的差异并不明显。

3) 有几个方法有一个超时参数，调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 以及 `Object.wait`、`Thread.join`、`Lock.tryLock` 和 `Condition.await` 的定时版本。

当一个线程被阻塞或等待时（或终止时）另一个线程将被调度为运行状态。

当一个线程被重新激活时（例如，因为超时期满或者成功地获得了一个锁），调度器将检查它是否具有比当前运行线程更高的优先级，如果是这样，调度器从当前运行的线程中挑选一个，剥夺其运行权，选择一个新的线程运行。

### 被终止的线程
线程因如下两个原因之一而被终止：
- 因为 `run` 方法正常推出而自然死亡。
- 因为一个没有捕获的异常终止了 `run` 方法而意外死亡。

特别是，可以调用线程的 `stop` 方法杀死一个线程，该方法抛出 `ThreadDeath` 错误对象，由此杀死线程。但是 `stop` 方法已过时，勿使用。

```
        新创建
          |
          | 开始
          |     ------------- 请求锁 -----------> 被阻塞
          |    / <----------  得到锁 ---------------|
          |   /
        可运行 _____------------- 等待通知 ----------> 等待
          |  \     <------------ 出现通知 -------------|
          |   \
          |    \_____------- 等待超时或通知 ---------> 计时等待
          |          <------ 出现超时或通知 --------------|
          |
          | 运行方法
          | exits
          |
        被终止
```


## 线程属性
### 线程优先级
在 Java 中，每一个线程都有一个优先级。默认情况下，线程继承构造它的线程的优先级。可以用 `setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 `MIN_PRIORITY`（在 `Thread` 类中定义为 1）与 `MAX_PRIORITY`（定义为 10）之间的任何值，`NORM_PRIORITY` 被定义为 5。

每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。

注意⚠️：绝对不要构造这样的程序，以使其正常运行取决于优先级。

警告⚠️：如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，即使这可能会完全饿死低优先级的线程。

### 守护线程
可以通过调用 `t.setDaemon(true)` 将线程转换为守护线程(daemon thread)。

守护线程的唯一用途是为其他线程提供服务。比如计时线程，它定时地发送信号给其他线程或清空过时的高速缓存项的线程，当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，就没必要继续运行程序了。

注意⚠️：守护线程永远不要访问持久性资源，例如文件或数据库，因为它可以在任何时候甚至在一个操作的中间随时终止。

### 未捕获异常处理器
线程的 `run` 方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。在这种情况下，线程就死亡了。

但是，不需要任何 `catch` 子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

该处理器必须属于一个实现 `Thread.UncaughtExceptionHandler` 接口的类，这个接口只有一个方法：
```java
void uncaughtException(Thread t, Throwable e);
```
可以用 `setUncaughtExceptionHanlder` 方法为任何线程安装一个处理器，也可以用 `Thread` 类的静态方法 `setDefaultUncaughtExceptionHandler` 为所有线程安装一个默认的处理器。替换处理程序可以使用日志记录 API 将未捕获的异常的报告发送到日志文件中。

如果不安装默认的处理器，默认的处理器为 `null`。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 `ThreadGroup` 对象。

线程组(thread group)是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于同一线程组，但是，也可以建立其他分组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。

`ThreadGroup` 类实现 `Thread.UncaughtExceptionHandler` 接口，它的 `uncaughtException` 方法做如下操作：

1) 如果该线程有父线程，那么父线程组的 `uncaughtException` 方法被调用。

2) 否则，如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器，则调用该处理器。

3) 否则，如果 `Throwable` 是 `ThreadDeath` 的一个实例，什么都不做。

4) 否则，线程的名字以及 `Throwable` 的栈轨迹被输出到 `System.err` 上。


## 同步
在多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？根据各线程访问数据的次序，可能会产生讹误的数据。这样的情况通常称为竞争条件(race condition)。

### 竞争条件
为了避免多线程引起的对共享数据的讹误，必须学会如何同步存取。

### 竞争条件详解
假设两个线程同时执行指令：
```java
accounts[to] += amount;
```
问题在于这不是原子操作，该指令可能被处理如下：
- 1) 将 `accounts[to]` 加载到寄存器。
- 2) 增加 `amount`。
- 3) 将结果写回 `accounts[to]`。

假定第一个线程执行步骤 1 和 2，然后它被剥夺了运行权。假定第二个线程被唤醒并修改了 `accounts` 数组中的同一项。然后，第一个线程被唤醒并完成其第 3 步。

这样，这一动作擦去了第二个线程所做的更新。

```
javap是 jdk 自带的反解析工具。它的作用就是根据 class 字节码文件，反解析出当前类对应的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。

查看执行类中的每一个语句的虚拟机字节码，运行命令：
javap -c -v Bank
--------------------------------------------------------------------------------
Classfile Bank.class
  Last modified Mar 28, 2020; size 1439 bytes
  MD5 checksum fb066f73ca84623fa463a4cf36c71355
  Compiled from "UnsynchBankTest.java"
class Bank
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #8.#44         // java/lang/Object."<init>":()V
   #2 = Fieldref           #14.#45        // Bank.accounts:[D
   #3 = Methodref          #46.#47        // java/util/Arrays.fill:([DD)V
   #4 = Fieldref           #48.#49        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #50.#51        // java/lang/Thread.currentThread:()Ljava/lang/Thread;
   #6 = Methodref          #52.#53        // java/io/PrintStream.print:(Ljava/lang/Object;)V
   #7 = String             #54            // %10.2f from %d to %d
   #8 = Class              #55            // java/lang/Object
   #9 = Methodref          #56.#57        // java/lang/Double.valueOf:(D)Ljava/lang/Double;
  #10 = Methodref          #58.#59        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
  #11 = Methodref          #52.#60        // java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #12 = String             #61            //  Total Balance: %10.2f%n
  #13 = Methodref          #14.#62        // Bank.getTotalBalance:()D
  #14 = Class              #63            // Bank
  #15 = Utf8               accounts
  #16 = Utf8               [D
  #17 = Utf8               <init>
  #18 = Utf8               (ID)V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               LBank;
  #24 = Utf8               n
  #25 = Utf8               I
  #26 = Utf8               initialBalance
  #27 = Utf8               D
  #28 = Utf8               transfer
  #29 = Utf8               (IID)V
  #30 = Utf8               from
  #31 = Utf8               to
  #32 = Utf8               amount
  #33 = Utf8               StackMapTable
  #34 = Utf8               getTotalBalance
  #35 = Utf8               ()D
  #36 = Utf8               a
  #37 = Utf8               sum
  #38 = Class              #63            // Bank
  #39 = Class              #16            // "[D"
  #40 = Utf8               size
  #41 = Utf8               ()I
  #42 = Utf8               SourceFile
  #43 = Utf8               UnsynchBankTest.java
  #44 = NameAndType        #17:#64        // "<init>":()V
  #45 = NameAndType        #15:#16        // accounts:[D
  #46 = Class              #65            // java/util/Arrays
  #47 = NameAndType        #66:#67        // fill:([DD)V
  #48 = Class              #68            // java/lang/System
  #49 = NameAndType        #69:#70        // out:Ljava/io/PrintStream;
  #50 = Class              #71            // java/lang/Thread
  #51 = NameAndType        #72:#73        // currentThread:()Ljava/lang/Thread;
  #52 = Class              #74            // java/io/PrintStream
  #53 = NameAndType        #75:#76        // print:(Ljava/lang/Object;)V
  #54 = Utf8               %10.2f from %d to %d
  #55 = Utf8               java/lang/Object
  #56 = Class              #77            // java/lang/Double
  #57 = NameAndType        #78:#79        // valueOf:(D)Ljava/lang/Double;
  #58 = Class              #80            // java/lang/Integer
  #59 = NameAndType        #78:#81        // valueOf:(I)Ljava/lang/Integer;
  #60 = NameAndType        #82:#83        // printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
  #61 = Utf8                Total Balance: %10.2f%n
  #62 = NameAndType        #34:#35        // getTotalBalance:()D
  #63 = Utf8               Bank
  #64 = Utf8               ()V
  #65 = Utf8               java/util/Arrays
  #66 = Utf8               fill
  #67 = Utf8               ([DD)V
  #68 = Utf8               java/lang/System
  #69 = Utf8               out
  #70 = Utf8               Ljava/io/PrintStream;
  #71 = Utf8               java/lang/Thread
  #72 = Utf8               currentThread
  #73 = Utf8               ()Ljava/lang/Thread;
  #74 = Utf8               java/io/PrintStream
  #75 = Utf8               print
  #76 = Utf8               (Ljava/lang/Object;)V
  #77 = Utf8               java/lang/Double
  #78 = Utf8               valueOf
  #79 = Utf8               (D)Ljava/lang/Double;
  #80 = Utf8               java/lang/Integer
  #81 = Utf8               (I)Ljava/lang/Integer;
  #82 = Utf8               printf
  #83 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
{
  public Bank(int, double);
    descriptor: (ID)V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=3
         0: aload_0  //从本地变量表中加载索引为0的变量的值，也即 this 的引用，压入栈
         1: invokespecial #1  //出栈，调用java/lang/Object."<init>":()V 初始化对象，就是this指定的对象的init()方法完成初始化
         4: aload_0
         5: iload_1
         6: newarray       double
         8: putfield      #2                  // Field accounts:[D
        11: aload_0
        12: getfield      #2                  // Field accounts:[D
        15: dload_2
        16: invokestatic  #3                  // Method java/util/Arrays.fill:([DD)V
        19: return
      LineNumberTable:
        line 46: 0
        line 47: 4
        line 48: 11
        line 49: 19
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      20     0  this   LBank;
            0      20     1     n   I
            0      20     2 initialBalance   D

  public void transfer(int, int, double);
    descriptor: (IID)V
    flags: ACC_PUBLIC
    Code:
      stack=7, locals=5, args_size=4
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: iload_1
         5: daload
         6: dload_3
         7: dcmpg
         8: ifge          12
        11: return
        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: invokestatic  #5                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;
        18: invokevirtual #6                  // Method java/io/PrintStream.print:(Ljava/lang/Object;)V
        21: aload_0
        22: getfield      #2                  // Field accounts:[D
        25: iload_1
        26: dup2
        27: daload
        28: dload_3
        29: dsub
        30: dastore
        31: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        34: ldc           #7                  // String %10.2f from %d to %d
        36: iconst_3
        37: anewarray     #8                  // class java/lang/Object
        40: dup
        41: iconst_0
        42: dload_3
        43: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        46: aastore
        47: dup
        48: iconst_1
        49: iload_1
        50: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        53: aastore
        54: dup
        55: iconst_2
        56: iload_2
        57: invokestatic  #10                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        60: aastore
        61: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        64: pop
        65: aload_0
        66: getfield      #2                  // Field accounts:[D
        69: iload_2
        70: dup2
        71: daload
        72: dload_3
        73: dadd
        74: dastore
        75: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        78: ldc           #12                 // String  Total Balance: %10.2f%n
        80: iconst_1
        81: anewarray     #8                  // class java/lang/Object
        84: dup
        85: iconst_0
        86: aload_0
        87: invokevirtual #13                 // Method getTotalBalance:()D
        90: invokestatic  #9                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;
        93: aastore
        94: invokevirtual #11                 // Method java/io/PrintStream.printf:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
        97: pop
        98: return
      LineNumberTable:
        line 52: 0
        line 53: 11
        line 55: 12
        line 56: 21
        line 57: 31
        line 58: 65
        line 59: 75
        line 60: 98
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      99     0  this   LBank;
            0      99     1  from   I
            0      99     2    to   I
            0      99     3 amount   D
      StackMapTable: number_of_entries = 1
        frame_type = 12 /* same */

  public double getTotalBalance();
    descriptor: ()D
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=8, args_size=1
         0: dconst_0
         1: dstore_1
         2: aload_0
         3: getfield      #2                  // Field accounts:[D
         6: astore_3
         7: aload_3
         8: arraylength
         9: istore        4
        11: iconst_0
        12: istore        5
        14: iload         5
        16: iload         4
        18: if_icmpge     38
        21: aload_3
        22: iload         5
        24: daload
        25: dstore        6
        27: dload_1
        28: dload         6
        30: dadd
        31: dstore_1
        32: iinc          5, 1
        35: goto          14
        38: dload_1
        39: dreturn
      LineNumberTable:
        line 63: 0
        line 64: 2
        line 65: 27
        line 64: 32
        line 67: 38
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           27       5     6     a   D
            0      40     0  this   LBank;
            2      38     1   sum   D
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 14
          locals = [ class Bank, double, class "[D", int, int ]
          stack = []
        frame_type = 248 /* chop */
          offset_delta = 23

  public int size();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field accounts:[D
         4: arraylength
         5: ireturn
      LineNumberTable:
        line 71: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   LBank;
}
SourceFile: "UnsynchBankTest.java"
```
注意🌿：代码行 `accounts[to] += amount;` 增值命令是由几条指令组成的，执行它们的线程可以在任何一条指令点上被中断。

真正的问题是 `transfer` 方法的执行过程中可能被中断。如果能够确保线程在失去控制之前方法运行完成，那么就不会出现数据讹误。

### 锁对象
有两种机制防止代码块受并发访问的干扰，Java 语言为此提供一个 `synchronized` 关键字达到这一目的，而在 Java SE 5.0 引入了 `ReentrantLock` 类。

synchronized 美[ˈsɪŋkrənaɪzd] v.(使) 同步，在时间上一致，同速进行;
synchronize的过去分词和过去式;

reentrant 美[ˌriˈɛntrənt] adj.可重入; 可重入的; 重入; 可再入的; 重进入;

`synchronized` 关键字自动提供一个锁以及相关的条件，对于大多数需要显式锁的情况，这是很便利的。`java.util.concurrent` 框架为这些基础机制提供独立的类。

使用 `ReentrantLock` 保护代码块的基本结构如下：
```java
myLock.lock(); // a ReentrantLock object
try {
    // critical section
}
finally {
    myLock.unlock(); // make sure the lock is unlocked even if an exception is thrown
}
```
这一结构确保任何时刻只有一个线程进入临界区，一旦一个线程封锁了锁对象，其他任何线程都无法通过 `lock` 语句。当其他线程调用 `lock` 时，它们被阻塞，直到第一个线程释放锁对象。

警告：把解锁操作放在 `finally` 子句之中是至关重要的，如果在临界区的代码抛出异常，锁必须被释放，否则，其他线程将永远阻塞。

如果使用锁，就不能使用带资源的 `try` 语句。首先，解锁方法名不是 `close`，不过，即使将它重命名，带资源的 `try` 语句也无法正常工作。它的首部希望声明一个新变量，但是如果使用的是一个锁，那么会是多个线程共享的那个变量。

假定一个线程调用 `transfer`，在执行结束前被剥夺了运行权。假设第二个线程也调用 `transfer`，由于第二个线程不能获得锁，将在调用 `lock` 方法时被阻塞。它必须等待第一个线程完成 `transfer` 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行。

注意每一个 `Bank` 对象有自己的 `ReentrantLock` 对象。如果两个线程视图访问同一个 `Bank` 对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的 `Bank` 对象，每个线程得到不同的锁对象，两个线程都不会发生阻塞。因为线程在操纵不同的 `Bank` 实例时，线程之间不会相互影响。

锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对 `lock` 方法的嵌套调用。线程在每一次调用 `lock` 都要调用 `unlock` 来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。

`transfer` 方法调用 `getTotalBalance` 方法，这也会封锁 `bankLock` 对象，此时 `bankLock` 对象的持有计数为 2。当 `getTotalBalance` 方法退出的时候，持有计数变回 1。当 `transfer` 方法退出的时候，持有计数变为 0。线程释放锁。

通常，保护需要若个操作来更新或检查共享对象的代码块，要确保这些操作完成后，另一个线程才能使用相同对象。

注意⚠️：要留心临界区的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，`finally` 子句将释放锁，但会使对象可能处于一种受损状态。

使用 `ReentrantLock(boolean fair)` 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程，但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。

警告🍓：公平锁比使用常规锁要慢得多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候才使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁。

### 条件对象 Condition Objects
通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。

条件对象，也被称为条件变量(condtion variables)。

避免选择没有足够资金的账户作为转出账户，注意不能使用下面的代码❌：
```java
if (bank.getBalance(from) >= amount) {
    // thread might be deactivated at this point
    bank.transfer(from, to, amount);
}
```
当前线程完全有可能在成功地完成测试，且在调用 `transfer` 方法之前将被中断。在线程再次运行前，账户余额可能已经低于提款金额。必须确保没有其他线程在本检查余额与转账活动之间修改余额。通过使用锁来保护检查与转账动作：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            // wait
            // ...
        }
        // transfer funds
        // ...
    } finally {
        bankLock.unlock();
    }
}
```
现在，当账户没有足够的金额时，等待直到另一个线程向账户中注入资金。但是，这一线程刚刚获得了对 `bankLock` 的排他性访问，因此别的线程没有进行存款操作的机会。

一个锁对象可以有一个或多个相关的条件对象，可以使用 `newCondtion` 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映出它所表达的条件的名字。
```java
class Bank {
    private Condtion sufficientFunds; // 余额充足条件
    // ...
    public Bank() {
        // ...
        sufficientFunds = bankLock.newCondtion();
    }
}
```
如果 `transfer` 方法发现余额不足时，调用 `sufficientFunds.await();`，当前线程现在被阻塞了，并放弃了锁。这样可以使得另一个线程可以进行增加账户余额的操作。

等待获得锁的线程和调用 `await` 方法的线程存在本质上的不同。一旦一个线程调用 `await` 方法，它进入该条件的等待集。等锁可用时，该线程不能马上解除阻塞。相反，它仍然处于阻塞状态，直到另一个线程在相同条件下调用 `signalAll` 方法为止。

当另一个线程转账时，调用 `sufficientFunds.signalAll();`，这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 `await` 调用返回，获得该锁并从被阻塞的地方继续执行。

此时，线程应该再次测试该条件。由于无法确保该条件被满足，`signalAll` 方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。

通常，对 `await` 的调用应该在如下形式的循环体中：
```java
while (!(ok to procced)) {
    condtion.await();
}
```

至关重要的是最终需要在某个其他线程中调用 `signalAll` 方法。当一个线程调用 `await` 时，它没有办法重新激活自身，它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再执行了，这将导致死锁(deadlock)现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用 `await` 方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

应该何时调用 `signalAll` 呢？在对象的状态有利于等待线程的方向改变时调用 `signalAll`。例如，当一个账户余额发生改变时，等待的线程会应该有机会检查余额：
```java
public void transfer(int from, int to, int amount) {
    bankLock.lock();
    try {
        while (accounts[from] < amount) {
            sufficientFunds.await();
        }
        // transfer funds
        // ...
        sufficientFunds.signalAll();
    } finally {
        bankLock.unlock();
    }
}
```
注意调用 `signalAll` 不会立即激活一个等待线程。它仅仅是解除等待线程的阻塞，以便这些线程可以在当前线程释放锁之后，通过竞争实现对对象的访问。

另一个方法 `signal`，则是随机解除`等待集`中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自身仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 `signal`，则系统死锁。

警告：当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 `await`、`signalAll` 或 `signal` 方法。

### synchronized 关键字
锁 `Lock` 和条件 `Condtion` 的关键之处：
- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 锁可以拥有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

`Lock` 和 `Condition` 接口为开发者提供了高度的锁定控制。然而，大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到 Java 语言内部的机制。

从 1.0 版本开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 `synchronized` 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用方法，线程必须获得内部的对象锁。
```java
public synchronized void method() {
    // method body
}
// 等价于
public void method() {
    this.intrinsicLock.lock();
    try {
        // method body
    } finally {
        this.intrinsicLock.unlock();
    }
}

```

intrinsic 美 [ɪn'trɪnsɪk] adj.固有的，内在的，本质的;

可以简单地声明 `Bank` 类的 `transfer` 方法为 `synchronized`，而不是使用一个显式的锁。

内部对象锁只有一个关联条件。`wait` 方法将线程添加到 `等待集` 中，`notifyAll` 或 `notify` 方法解除等待线程的阻塞状态。换言之，调用 `wait` 或 `notifyAll` 等价于：
```java
intrinsicCondition.await();
intrinsicCondition.signalAll();
```

注意：`wait`、`notifyAll` 以及 `notify` 方法是 `Object` 类的 `final` 方法。`Condition` 方法必须被命名为 `await`、`signalAll` 和 `signal` 以便它们不会与那些方法发生冲突。
```java
class Bank {
    //...
    private double[] accounts;
    //...
    public synchronized void transfer(int from, int to, int amount) throws InterruptedException {
        while (accounts[from] < amount) {
            wait(); // wait on intrinsic object lock's single condition
        }
        accounts[from] -= amount;
        accounts[to] += amount;
        notifyAll(); // notify all threads waiting on the condtion
    }
    //...
}
```
使用 `synchronized` 关键字编写代码要简洁得多。理解这段代码，需要了解每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入 `synchronized` 方法的线程，由条件来管理那些调用 `wait` 的线程。

将静态方法声明为 `synchronized` 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。如果 `Bank` 类有一个静态同步方法，那么当该方法被调用时，`Bank.class` 对象的锁被锁住，因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

内部锁和条件存在一些局限：
- 不能中断一个正在试图获得锁的线程。
- 试图获得锁时不能设定超时。
- 每个锁仅有单一的条件，可能是不够的。

使用 `Lock` 和 `Condition` 对象还是同步方法？
- 最好既不使用 `Lock`/`Condition` 也不使用 `synchronized` 关键字。在许多情况下，可以使用 java.util.concurrent 包中的一种机制，它会处理所有的加锁。
- 如果 `synchronized` 关键字适合，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
- 如果特别需要 `Lock`/`Condition` 结构提供的独有特性时，才使用  `Lock`/`Condition`。


## 阻塞队列


## 线程安全的集合


## Collable 与 Future


## 执行器


## 同步器


## 线程与 Swing


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8


