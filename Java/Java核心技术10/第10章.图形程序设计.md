---
title: 图形程序设计
date: 2020-02-23 18:50:00
tags:
categories:
- Java
---

## Swing 概述
在 Java 1.0 刚刚出现时，包含了一个用于基本 GUI 程序设计的类库：抽象窗口工具箱(Abstract Window Toolkit, AWT)。基本 AWT 库采用将处理用户界面元素的任务委派给每个目标平台的本地 GUI 工具箱的方式，由本地 GUI 工具箱负责用户界面元素的创建和动作。

在 Java SE 1.2 标准库中创建了名为 Swing 的用户界面库，它采用了与 AWT 完全不同的工作方式，它将按钮、菜单这样的用户界面元素绘制在空白窗口上。

注意：Swing 没有完全替代 AWT，而是基于 AWT 架构之上。Swing 仅仅提供了能力更加强大的用户界面组件，尤其在采用 Swing 编写的程序中，还需要使用基本的 AWT 处理事件。Swing 是指被绘制的用户界面类，AWT 是指像事件处理这样的窗口工具箱的底层机制。

当然，在用户屏幕上显示基于 Swing 用户界面的元素要比显示 AWT 的基于对等体组件的速度慢一些，选择 Swing：
- Swing 拥有一个丰富、便捷的用户界面元素集合。
- Swing 对底层平台依赖得很少，因此与平台相关的 bug 很少。
- Swing 给予不同平台的用户一致的感觉。

对于第三点存在着一个潜在的问题：如果在所有平台上用户界面元素看起来都一样，那么它们就有可能与本地控件不一样。

在编写 Swing 程序时，可以为程序指定专门的“观感”。Sun 公司开发了一种称为 Metal 的独立于平台的观感。


## 创建框架
在 Java 中，顶层窗口（就是没有包含在其他窗口中的窗口）被称为框架(frame)。在 AWT 库中有一个称为 `Frame` 的类，用于描述顶层窗口。这个类的 Swing 版本名为 `JFrame`，它扩展于 `Frame` 类。

`JFrame` 是极少数几个不绘制在画布上的 Swing 组件之一，因此它的修饰部件(按钮、标题栏、图标等)由用户的窗口系统绘制，而不是由 Swing 绘制。

警告❌：绝大多数 Swing 组件类都以 `J` 开头，例如，`JButton`、`JFrame` 等，在 Java 中有 `Button` 和 `Frame` 这样的类，但它们属于 AWT 组件。将 Swing 组件和 AWT 组件混合在一起使用将会导致视觉和行为的不一致。

Swing 类位于 `javax.swing` 包中，包名 `javax` 表示这是一个 Java 扩展包，而不是核心包。出于历史原因，Swing 类被认为是一个扩展，不过从 1.2 版本开始，在每个 Java SE 实现中都包含它。

在默认情况下，框架的大小为 `0✖️0` 像素，这种框架没有什么实际意义。定义子类时的构造器需要将框架大小重新设置。

在每个 Swing 程序中，有两个技术问题需要重视。

第一，所有的 Swing 组件必须由事件分派线程(event dispatch thread)进行配置，线程将鼠标点击和按键控制转移到用户接口组件。以下代码片段是事件分派线程中的执行代码：
```java
EventQueue.invokeLater(()->{
    // statements
})
```
注意，许多 Swing 程序并没有在事件分派线程中初始化用户界面，在主线程中完成初始化是通常采用的方式。由于 Swing 组件十分复杂，程序员无法保证这种方式的安全性。

第二，定义一个用户关闭这个框架时的响应动作。

在包含许多框架的程序中，不能在用户关闭其中一个框架时就让程序退出。在默认情况下，用户关闭窗口时只是将框架隐藏起来，而程序并没有终止。

简单地构造框架是不会自动地显示出来地，框架起初是不可见地，这样程序员就可以在框架第一次显示之前往其中添加组件。为了显示框架，需要调用框架的 `setVisible` 方法。

注意：在初始化语句结束后，`main` 方法退出，并没有终止程序，终止的只是主线程，事件分派线程保持程序处于激活状态，直到关闭框架或调用 `System.exit` 方法终止程序。

可以调用 `frame.setUndecorated(true)` 关闭所有框架装饰。


## 框架定位
`JFrame` 类本身只包含若干个改变框架外观的方法，通过继承，从 `JFrame` 的各个超类中继承了许多用于处理框架大小和位置的方法，其中最重要的几个：
- `setLocation` 和 `setBounds` 方法用于设置框架的位置。
- `setIconImage` 用于告诉窗口系统在标题栏、任务切换窗口等位置显示哪个图标。
- `setTitle` 用于改变标题栏的文字。
- `setResizable` 利用一个 `boolean` 值确定框架的大小是否允许用户改变。

`JFrame` 类的继承层次：
```
         Object
           |
        Component
           |
        Container
     _______|______
     |            | 
 JComponent    Window
     |            | 
  JPanel        Frame
                  |
                JFrame
```
`Component` 类是所有 GUI 对象的祖先，`Window` 类是 `Frame` 类的超类。

在 `Component` 类中的 `setLocation(x, y)` 方法将窗口放置在左上角水平 x 像素、垂直 y 像素的位置，坐标 `(0, 0)` 位于屏幕的左上角。同样地，`Component` 类中的 `setBounds(x, y, width, height)` 方法可以实现一步重定位组件大小和位置的操作。如果在显示窗口之前调用 `setLocationByPlatform(true)`，窗口系统会选用串口的位置，通常是距最后一个显示窗口很少偏移量的位置。

对于框架来说，`setLocation` 和 `setBounds` 中的坐标均相对于整个屏幕；在容器中包含的组件所指的坐标均相对于容器。

### 框架属性
组件类的很多方法是以获取／设置方法对形式出现的，比如，`Frame` 类的下列方法：
```java
public String getTitle()
public void setTitle(String title)
```

针对 get/set 约定有一个例外：对于类型为 `boolean` 的属性，获取方法由 `is` 开头，比如：
```java
public boolean isLocationByPlatform();
public void setLocationByPlatform(boolean b)
```

### 确定合适的框架大小
要记住：如果没有明确地指定框架的大小，所有框架的默认值为 `0✖️0` 像素。对于应用程序而言，应该检查屏幕的分辨率，并根据其分辨率编写代码重置框架的大小。

为了得到屏幕的大小，需要调用 `Toolkit` 类的静态方法 `getDefaultToolkit` 得到一个 `Toolkit` 对象（`Toolkit` 类包含很多与本地窗口系统打交道的方法）。然后，调用 `getScreenSize` 方法，这个方法以 `Dimension` 对象的形式返回屏幕的大小。`Dimension` 对象同时用公有实例变量 `width` 和 `height` 保存着屏幕的宽度和高度。
```java
Toolkit kit = Toolkit.getDefaultToolkit();
Dimension screenSize = kit.getScreenSize();
int screenWidth = screenSize.width;
int screenHeight = screenSize.height;
```
存在问题❌：与实际屏幕分辨率不符，本机 `13.3-inch (2560 x 1600)`，结果打印 `1440 x 900`。

另外，还可以提供一个图标。`ImageIcon` 类便于加载图像，然后，将这个图像设置为框架的图标：
```java
Image img = new ImageIcon("icon.gif").getImage();
setIconImage(img);
```
对于不同的操作系统，所看到的图标显示位置有可能不同。

处理框架的提示：
- 如果框架中只包含标准的组件，如按钮和文本框，那么可以调用 `pack` 方法设置框架大小，框架将被设置为刚好能够放置所有组件的大小。在通常情况下，调用 `frame.setExtendedState(Frame.MAXIMIZED_BOTH)` 将程序的主框架尺寸设置为最大。
- 可以存储数据来记录用户定位应用程序的框架位置、重置框架大小，并且在应用程序再次启动时恢复这些内容。
- `GraphicsDevice` 类允许以全屏模式执行应用。


## 在组件中显示信息
在 Java 中，框架被设计为放置组件的容器，可以将菜单栏和其他的用户界面元素放置在其中。在通常情况下，应该在另一个组件上绘制信息，并将这个组件添加到框架中。

`JFrame` 的结构中有四层面板：其中的根窗格(root pane)、层级窗格(layered pane)和玻璃窗格(glass pane)通常不用太关心，它们是用来组织菜单栏(menu bar)和内容窗格(content pane)以及实现观感的。Swing 程序原最关心的是内容窗格，在设计框架的时候，要使用下列代码将所有的组件添加到内容窗格中：
```java
Container contentPane = frame.getContentPane();
Component c = ...;
contentPane.add(c);
```
注意⚠️：在 Java SE 1.4 及以前的版本中，`JFrame` 类中的 `add` 方法抛出一个异常信息 `Do not use JFrame.add(). Use JFrame.getContentPane().add() instead.`，但在之后的版本中，`JFrame.add` 方法不再显示这些提示信息，只是简单地调用内容窗格的 `add` 方法，因此，可以直接调用：
```java
frame.add(c)
```

绘制一个组件，需要定义一个扩展 `JComponent` 的类，并覆盖其中的 `paintComponent` 方法。

`paintComponent` 方法有一个 `Graphics` 类型的参数，这个参数保存着用于绘制图像和文本的设置。在 Java 中，所有的绘制都必须使用 `Graphics` 对想，其中包含了绘制图案、图像和文本的方法。

创建一个能够进行绘制的组件：
```java
class MyComponent extends JComponent {
    public void paintComponent(Graphics g) {
        // code for drawing
    }
}
```
无论何种原因，只要窗口需要重新绘图，事件处理器就会通告组件，从而引发执行所有组件的 `paintComponent` 方法。

一定不要主动调用 `paintComponent` 方法，在应用程序需要重新绘图的时候，这个方法将被自动地调用，不要人为地干预这个自动的处理过程。

何种类别的动作会触发这个自动响应过程呢？例如，在用户扩大窗口或最小化窗口，然后又恢复窗口的大小时会引发重新绘图。如果用户弹出了另外一个窗口，并且这个窗口覆盖了一个已经存在的窗口，使得覆盖的窗口不可见，则此时被覆盖的应用程序窗口被破坏，需要重新绘制(图形系统不保存下面的像素)。当然，窗口第一次显示时，需要处理一些代码，主要包含确定绘制最初元素的方式以及位置。

如果需要强制刷新屏幕，就需要调用 `repaint` 方法，它将引发采用相应配置的 `Graphics` 对象调用所有组件的 `paintComponent` 方法。

对于屏幕显示来说，`Graphics` 对象的度量单位是像素，坐标 `(0, 0)` 指出所绘制组件表面的左上角。

显示文本是一种特殊的绘图，在 `Graphics` 类中有一个 `drawString` 方法，调用的语法格式为：
```java
g.drawString(text, x, y);
```

最后，组件要告诉用户它应该又多大，覆盖 `getPreferredSize` 方法，返回一个有首选宽度和高度的 `Dimension` 类对象：
```java
public Dimension getPreferredSize() {
    return new Dimension(DEFUALT_WIDTH, DEFAULT_HEIGHT);
}
```

在框架中填入一个或多个组件时，如果只想使用它们的首选大小，可以调用 `pack` 方法而不是 `setSize` 方法。

注意：有些程序员更喜欢扩展 `JPanel`，而不是 `JComponent`。`JPanel` 是一个可以包含其他组件的容器(container)，但同样也可以在其上面进行绘制。但有一点不同之处是：面板不透明，这意味着需要在面板的边界内绘制所有的像素。最容易实现的方法是，在每个面板子类的 `paintComponent` 方法中调用 `super.paintComponent` 来用背景色绘制面板。


## 处理 2D 图形

## 使用颜色

## 文本使用特殊字体

## 显示图像


## 参考
[1] Java核心技术.卷Ⅰ.基础知识(原书第10版).机械工业出版社,2016.8