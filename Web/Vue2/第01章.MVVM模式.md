---
title: Web 应用中的 MVC-MVP-MVVM 模式
date: 2019-04-04 23:56:00
tags:
categories:
- Vue
---

## 介绍

MVC、MVP、MVVM 这些模式是为了解决开发过程中的实际问题而提出来的。

### MVC
MVC 模式中 M 表示数据模型 Model，V 表示界面视图 View，C 表示控制 Controller，用来协调用户操作、Model 和 View。

MVC 模式为开发提供了指导原则，并没有明确指明各部分承担具体什么职责，相互之间应该如何交互，这些很大程度上都是由开发工具或者开发框架定义的。随着 Web 应用、移动端应用的流行，各种开发框架层出不穷，MVC 衍生出了几种变体，比如 MVP 和 MVVM。

在服务器端参与的 MVC 框架中 Model 通常是实体模型，数据存储在数据库中，View 则是 HTML 页面，Controller 则处理路由请求，协调调用服务层业务逻辑，获得结果，渲染成合适的 HTML 页面返回。

在纯客户端的 MVC 框架中，当数据已经到达客户端后，需要管理客户端的数据模型，需要 View 将数据展示给用户并给用户操作触点，需要协调处理用户的操作。

### 客户端 MVC 框架之 MVP
MVP 模式更加明确定义了各个组件的职责。

在 Passive View(被动视图模式)中 View 是完全被动的，只有数据显示逻辑和触发操作的入口，所有的逻辑都由 Presenter 承担；View 和 Model 不直接交互；Presenter 负责将数据通过 View 接口设置到视图控件上，负责响应 View 的事件并作出处理，根据需要更新 Model，然后触发视图重新加载或刷新。

其中，Presenter 需要通过 View 的接口来与之交互，这就需要 View 提供非常多的接口，导致代码臃肿、不易阅读和修改。

在 Supervising Controller(监督控制器模式)中 通过数据(双向)绑定为 View 和 Model 建立映射关系来消除上述的繁琐，而且开发框架通常会提供声明的方式建立绑定关系。视图变化时，绑定的 Model 自动更新，而 Model 数据变化时，视图也自动更新内容。除了这种简单的映射外，复杂的逻辑需要 Presenter 来完成处理。eg.WPF 的 DataBinding

### 客户端 MVC 框架之 MVVM
MVVM 与 MVP 的区别主要在职责上，Model 的职责不变，View 的职责被拆分，一部分是可视化展示，展示数据和用户操作交互等，仍然由 View 来承担；另外一部分是 View 的状态，包括数据更新、控件的激活或选中状态，被转移到了 ViewModel 中，所以 View 不再需要与 Model 做绑定，而是与 ViewModel 绑定，View 与 Model 没有直接交互。ViewModel 除了需要响应用户操作外，还需要维护视图的状态。

注意：MVP 中的 Presenter 也是需要维护视图状态的，但是 Presenter 是将视图状态设置到视图上，Presenter 自己并不需要持有这些状态，而在 MVVM 中 View Model 是视图状态的权威来源，View 只是反映 View Model 的状态。

MVVM 和 MVP 一样，View 只负责显示，没有逻辑，所以带来了可测试性的提高。

## MVVM 框架
Model 是数据模型，和我们的业务需求或者说业务实体（Entity）是一一映射关系。而 ViewModel 就是一个 Model of View，它是一个 View 信息的存储结构，ViewModel 和 View 上的信息是一一映射关系。

MVVM 框架的设计思想：关注 Model 的变化，让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来。

当任何外部事件(界面点击、文字输入、网络通信等事件)发生时，永远只操作 ViewModel 中的数据。

单向绑定就是 ViewModel 变化时自动更新 View；双向绑定是在单向绑定的基础上，View 变化时自动更新 ViewModel。

数据绑定(配置 ViewModel 和 View 的映射关系)和动态变化(监控 ViewModel 并自动变化这一切)这都是由具体的 MVVM 框架这个“上帝之手”来实现的。


## 前端 MVVM 框架的原理
不同的框架对于 MVVM 的实现是不同的。
- 数据劫持(Vue)，对数据 Model 进行劫持，当数据发生变动时，会触发绑定的方法，对视图进行更新。（数据劫持的核心原理是使用Object.defineProperty(obj, prop, descriptor)这个API，在 setter 中加入劫持方法，一旦有任何地方执行相关的赋值语句，则 setter 都会被调用，由 setter 去触发重新渲染 view。）
- 脏检查机制(Angular)，当发生了某种事件后，会检查新的数据结构和之前的数据结构是否发生了变化，来决定是否更新视图。（脏检查的原理是拷贝一份 copy_viewModel 在内存中，一旦有用户点击，输入操作，或 ajax 请求，setInterval，setTimeout等这些可能导致 viewModel 发生改变的行为，框架都会把 copy_viewModel 和最新的 viewModel 进行深度比较，一旦发现有属性发生变化，则重新渲染与该属性绑定的 DOM 节点。）
- 发布订阅模式(Knockout)，在解析时会在对应视图节点上绑定订阅器，而在数据上绑定发布器，当修改数据时，就触发了发布器，相应的订阅器会更新所在的视图节点。

但它们还是有很多相同点的，都有三个步骤：
- 解析模板。通过定义模板关键字，根据这些关键字解析模板，将模板对应到期望的数据结构。
- 解析数据。Model 中的数据经过劫持或绑定发布器来解析，数据解析器需要保证数据解析的一致性，对于每种数据解析后暴露的接口应该保持一致。
- 绑定模板和数据。定义数据结构以何种方式与模板进行绑定。


## 动手实现 MVVM
MVVM 库 = 单向显示 + 逆向修改 + 同步机制。

### 扫描器 Scanner
利用递归深度优先遍历 DOM 树，处理属性中含有模板关键字的 DOM 节点，及其对应的 ViewModel 的表达式，返回 View 与 ViewModel 的映射关系。

### 检测器 Watcher
注册 ViewModel 到检测器，一旦检测到 ViewModel 发生了改变，通知渲染器刷新相应的 View。
对于交互性控件注册到检测器，一旦检测到 View 发生了改变，则改变相应的 ViewModel。

### 渲染器 Renderer
负责单向显示，也负责逆向修改(针对交互性控件)。

### 核心模块
负责维护 view 与 viewModel 的映射关系，以及各个模块间的调度。





## 参考
[1] https://www.cnblogs.com/winter-cn/p/4285171.html

[2] https://zhuanlan.zhihu.com/p/59814282

[3] https://blog.csdn.net/binglan520/article/details/71107807

[4] https://www.cnblogs.com/libin-1/p/6201061.html

[5] https://segmentfault.com/a/1190000010744960




