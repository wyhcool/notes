---
title: React 高级组件
date: 2022-05-14 14:05:00
tags:
categories:
- React
---

重用代码。

## 高阶组件
高阶组件(Higher Order Component, HOC)是使用 React 的一种模式，用于增强现有组件的功能。

一个高阶组件就是一个函数，这个函数接受一个组件作为输入，然后返回一个新的组件作为结果，而且，返回的新组件拥有了输入组件所不具有的功能。

定义高阶组件的意义：
- 重用代码。把公共的逻辑提取出来，利用高阶组件的方式应用出去，就可以减少很多组件的重复代码。
- 修改现有 React 组件的行为。通过一个独立于原有组件的函数，可以产生新的组件，对原有组件没有任何侵害。

根据返回的新组件和传入组件参数的关系，高阶组件的实现方式可以分为两大类：
- 代理方式的高阶组件；
- 继承方式的高阶组件。

### 代理方式的高阶组件
代理方式的高阶组件，特点是返回的新组件类直接继承自 React.Component 类，新组件扮演的角色是传入参数组件的一个代理，在新组件的 render 函数中，把被包裹组件渲染出来，除了高阶组件自己要做的工作，其余功能全部转手给了被包裹的组件。

代理方式的高阶组件，可以应用在以下场景中：
- 操纵 prop
- 访问 ref
- 抽取状态
- 包装组件

#### 操纵 prop
代理类型高阶组件返回的新组件，渲染过程也被新组件的 render 函数控制，而 render 函数相当于一个代理，完全决定如何使用被包裹的组件。

在 render 函数中，this.props 包含新组件接收到的所有 prop，最简单的方式是把 this.props 原封不动地传递给被包裹组件，高阶组件也可以增加、删除、修改传递给包裹组件的 props 列表。

#### 访问 ref
ref 是特殊的 prop，其值可以是一个函数，在被包裹组件的装载过程完成的时候被调用，参数就是被装载的组件本身。

#### 抽取状态
在展示组件和容器组件的关系中，通常让展示组件不要管理自己的状态，只要做一个无状态的组件就好，所有状态的管理都交给外面的容器组件，这个模式就是抽取状态。

#### 包装组件
通过向 render 函数的 JSX 中引入其他元素，或者组合多个 React 组件，达到包装组件的效果。

### 继承方式的高阶组件
继承方式的高阶组件采用继承关系关联作为参数的组件和返回的组件。

代理方式和继承关系最大的区别是使用被包裹组件的方式。在代理方式下被包裹的组件经历了一个完整的生命周期，但在继承方式下 `super.render()` 只是一个生命周期中的一个函数而已。在代理方式下产生的新组件和参数组件是两个不同的组件，一次渲染，两个组件都要经历各自的生命周期，在继承方式下两者合二为一，只有一个生命周期。

继承方式的高阶组件，可以应用在以下场景中：
- 操纵 prop
- 操纵生命周期函数

#### 操纵 prop
继承方式的高阶组件可以操纵 props，还可以利用 React.cloneElement 让组件重新绘制。

#### 操纵生命周期函数
继承方式的高阶函数返回的新组件继承了参数组件，所以可以重新定义任何一个 React 组件的生命周期函数，这是继承方式高阶函数的特用场景。

`优先考虑组合，然后才考虑继承(Composition over Inheritance)。`

### 高级组件的显示名
每个高阶组件都会产生一个新的组件，使用这个新组件就丢失掉了参数组件的显示名，为了方便开发和维护，往往需要给高阶组件重新定义一个显示名。

增加显示名的方式是给高阶组件类的 displayName 赋上一个字符串类型的值。

### 曾经的 React Mixin
Mixin 只能在用 React.createClass 方式创建的组件类中才能使用。

## 以函数为子组件
高阶组件对原组件的 props 有了固化的要求，也就是说，能不能把一个高阶组件作用于某个组件 X，要先看一下这个组件 X 是不是能够接受高阶组件传过来的 props。

以函数为子组件的模式就是为了克服高阶组件的这种局限而生的，在这种模式下，实现代码重用的不是一个函数，而是一个真正的 React 组件，这样的 React 组件有个特点，要求必须有子组件的存在，而且这个子组件必须是一个函数。在组件实例的生命周期函数中，this.props.children 引用的就是子组件，render 函数会直接把 this.props.children 当作函数来调用，得到的结果就可以作为 render 返回结果的一部分。

以函数为子组件的模式可以让代码非常灵活，但这种模式的缺点就是难以做性能优化。每次外层组件的更新过程，都要执行一个函数获得子组件的实际渲染结果，无法利用 shouldComponentUpdate 来避免渲染浪费。


## 参考
[1] 程墨.深入浅出 React 和 Redux.机械工业出版社.2017.04

[2] https://github.com/mocheng/react-and-redux
