---
title: 回调
date: 2020-05-23 08:09:00
tags:
categories:
- JavaScript
---

处理所有事件(异步函数调用)的单线程(一次一个)事件循环队列。

把函数当作独立不可分割的运作单元来使用，在函数内部，语句以可预测的顺序执行(在编译器以上的层级)，但是在函数顺序这一层级，事件(异步函数调用)的运行顺序可以有多种可能。

函数作为回调(callback)使用，因为它是事件循环回头调用到程序中的目标，队列处理到这个项目的时候会运行它。


## continuation
回调函数包裹(封装)了程序的延续(continuation)。

一旦以回调函数的形式引入多个 continuation，代码会变得更加难以理解、追踪、调试和维护。

## 顺序的大脑
### 执行与计划
编写同步代码的时候，语句是一条接一条执行的。

编写异步事件代码，特别是当回调是唯一的实现手段时，苦难之处就在于这种思考／计划的意识流对我们来说是不自然的。

### 嵌套回调与链式回调
将多个函数嵌套在一起构成的链，其中每个函数代表异步任务中的一个步骤，这种代码常常被称为回调地狱(callback hell)，有时也被称为毁灭金字塔(pyramid of doom，得名于嵌套缩进产生的横向三角形状)。

hell \[hel] n.地狱; 苦难的经历; 悲惨的境况; (有人认为含冒犯意) 该死，见鬼;

pyramid \[ˈpɪrəmɪd] n.(古埃及的) 金字塔; 锥体; 棱锥体; 金字塔形的物体(或一堆东西);

doom \[duːm] n.死亡; 毁灭; 厄运; 劫数;

在线性顺序地追踪代码的过程中，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以查看流程。

手工硬编码，即使包含了出错处理，回调的脆弱本性就远没有那么优雅了。一旦指定(预先计划)了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。

顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码，这就是回调方式的主要缺陷，对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。


## 信任问题
回调驱动设计最严重，也是最微妙的问题是，它以这样一个思路为中心，有时你交付回调 continuation 的第三方不是你编写的代码，也不在你的直接控制下。多数情况下，它是某个第三方提供的工具。

这称为控制反转(inversion of control)，也就是把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具之间有一份并没有明确表达的契约。

对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑。

在某种程度上我们应该在内部函数中构建一些防御性的输入参数检查，以便减少或阻止无法预料的问题。

回调并没有为我们提供任何东西来支持这一点，我们不得不自己构建全部的机制，而且通常为每个异步回调重复这样的工作最后都成了负担。

信任，但要核实。

回调最大的问题是控制反转，它会导致信任链的完全断裂。

回调设计存在几个变体，意在解决一些信任问题，但是试图从回调模式内部挽救它的意图是勇敢的，但却注定要失败。

为了更优雅的处理错误，有些 API 设计提供了分离调用(一个用于成功通知，一个用于出错通知)，在这种设计下，API 的出错处理函数常常是可选的，如果没有提供的话，就是假定这个错误可以吞掉。

还有一种常见的回调模式叫做 `error-first` 风格，也被称为 Node 风格，因为几乎所有 Node.js API 都采用这种风格，其中回调的第一个参数保留用作错误对象。如果成功的话，这个参数就会被清空/置假，后续的参数就是成功数据；如果产生了错误结果，那么第一个参数就会被置起/置真，通常就不会再传递其他结果。

如果完全不调用，可能需要设置一个超时来取消事件：
```javascript
function timeoutify(fn, delay) {
    var intv = setTimeout(function() {
        intv = null;
        fn(new Error("Timeout"));
    }, delay);
    return function() {
        // 还没超时
        if (intv) {
            clearTimeout(intv);
            fn.apply(this, arguments);
        }
    }
}

// error-first 风格回调设计
function foo(err, data) {
    if (err) {
        console.error(err);
    } else {
        console.log(data);
    }
}

ajax('http://some.url.1', timeoutify(foo ,500));
```

这种由同步或异步行为引起的不确定性几乎总会带来极大的 bug 追踪难度，人们用虚构的十分疯狂的恶魔 Zalgo 来描述这种同步/异步噩梦，因此建议：永远异步调用回调，即使就在实现循环的下一轮，这样所有回调就都是可预测的异步调用了。

如果不确定关注的 API 会不会永远异步执行，可以创建一个验证概念版本的工具：
```javascript
function asyncify(fn) {
    var orig_fn = fn,
        intv = setTimeout(function() {
            intv = null;
            if (fn) fn();
        }, 0);
    
    fn = null;

    return function() {
        // 触发太快，在定时器 intv 触发指示异步转换发生之前
        if (intv) {
            fn = orig_fn.bind.apply(orig_fn, 
            // 把封装器的 this 添加到 bind(..) 调用的参数中
            // 以及克里化(currying)所有传入参数
            [this].concat([].slice.call(arguments)));
        } else {
            // 已经是异步
            // 调用原来的函数
            orig_fn.apply(this, arguments);
        }
    };
}

function result(data) {
    console.log(a);
}
var a = 0;
ajax('http://some.url.1', asyncify(result));
a++;
```


## 总结
回调函数是 JavaScript 异步的基本单元。

随着 JavaScript 越来越成熟，对于异步编程领域的发展，回调已经不够用了：
- 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。
- 回调会受到控制反转的影响，因为回调暗中把控制权交给第三方来调用你代码中的 continuation，这样控制权转移导致一系列麻烦的信任问题。


## 参考
[1] Kyle Simpson. You Don't Know JS