---
title: 异步：现在与将来
date: 2020-05-21 06:24:00
tags:
categories:
- JavaScript
---

## 分块的程序
一些块现在执行，其余的则会在将来执行。

任何时候，只要把一段代码包装起来，并指定它在响应某个事件（定时器、鼠标点击、Ajax 响应等）时执行，就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。

### 异步控制台
并没有什么规范或一组需求指定 console.* 方法族是如何工作，它们并不是 JavaScript 正式的一部分，而是由宿主环境添加到 JavaScript 中的。

因此，不同的浏览器和 JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。

在某些浏览器的 console.log(...) 并不会把传入的内容立即输出，因为 I/O 是非常低速的阻塞部分，所以浏览器在后台异步处理控制台 I/O 能够提高性能。

```javascript
var a = {
    index: 1
}

console.log(a);

a.index++;
```
通常认为恰好在执行到 console.log(...) 语句的时候会看到对象 a 的快照，打印出类似于 { index: 1 }，然后在下一条语句 a.index++ 执行时将其修改，这句的执行会严格在 a 的输出之后。

但是，浏览器可能会认为需要把控制台 I/O 延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时，a.index++ 可能已经执行，因此会显示 { index: 2 }。

注意⚠️：最好的选择是在 JavaScript 调试器中使用断点，而不要依赖控制台输出。次优的方案是把对象序列化到一个字符串中，以强制执行一次快照，比如通过 JSON.stringify(...)。


## 事件循环
JavaScript 引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。

JavaScript 引擎并不是独立运行的，它运行在宿主环境中。所有的宿主环境都有一个共同点，即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。

换言之，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。事件(JavaScript 代码执行)调度总是由包含它的环境进行。

```javascript
// eventLoop 是一个用作队列的数组 先进先出
var eventLoop = []
var event;

// 永远执行
while (true) {
    // 一次 tick
    if (eventLoop.length > 0) {
        // 拿到队列中的下一个事件
        event = eventLoop.shift();

        // 现在，执行下一个事件
        try {
            event();
        } catch (err) {
            reportError(err)
        }
    }
}
```
有一个用 while 循环实现的持续运行的循环，循环的每一轮称为一个 tick。对于每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行，这些事件就是回调函数。

tick \[tɪk] v.发出滴答声; 滴答地走时; 标记号; 打上钩; 打对号;

注意⚠️：setTimeout(...) 并没有把回调函数挂在事件循环队列中，它所做的是设定一个定时器，当定时器到时后，环境会把回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。

注意：ES6 从本质上改变了在哪里管理事件循环，ES6 精确指定了事件循环的工作细节，这意味着在技术上将其纳入了 JavaScript 引擎的势力范围，而不是只由宿主环境来管理。


## 并行线程
异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。

并行计算最常用的工具是进程和线程，进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。

与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。

注意⚠️：并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。

一段代码实际上可能有很多个不同的底层运算，在单线程环境中，线程队列中这些底层运算不会被中断，但是在并行系统中，同一程序中可能有两个不同的线程在运转，这时可能会得到不确定的结果。

JavaScript 从不跨线程共享数据。

### 完整运行
由于 JavaScript 的单线程特性，foo() (以及 bar()) 中的代码具有原子性，即一旦 foo() 开始运行，它的所有代码都会在 bar() 中的任意代码运行之前完成，或者相反。这称为完整运行(run-to-completion)特性。

同一段代码有可能多个可能输出意味着还是存在不确定性！但是，这种不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别(表达式运算顺序级别)。

在 JavaScript 的特性中，这种函数顺序的不确定性就是竞态条件(race condition)。


## 并发
要实现随用户向下滚动列表而逐渐加载更多内容，至少需要两个独立的进程同时运行，也就是说，在同一时间段内，并不需要在同一时刻。

这里的进程并不是真正操作系统级进程，而是任务，表示一个逻辑上相关的运算序列。

第一个进程在用户向下滚动页面触发 onscroll 事件时响应这些事件(发起 Ajax 请求)，第二个进程接收 Ajax 响应(把内容展示到页面)。

进程1 和进程2 并发运行(任务级并发)，但是它们的各个事件是在事件循环队列中依次进行的。

### 非交互
两个或多个进程在同一个程序内并发地交替运行它们的步骤／事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。

### 交互
更常见的情况是，并发的进程需要相互交流，通过作用域或 DOM 间接交互。

可以协调交互顺序来避免竞态条件的不确定性。

有些并发场景，无论 foo() 和 bar() 哪一个先被触发，总会使 baz() 过早运行。这里可以使用包裹 baz() 调用的条件判断 if (a && b)，传统上这称为门(gate)，虽然不能确定 a 和 b 到达的顺序，但是会等到它们两个都准备好再进一步打开门。

另一种可能遇到的并发交互条件叫做门闩(latch)，它的特性可以描述为“只有第一名取胜”，在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要竞争到终点，且只有唯一的胜利者。

### 协作
并发协作(cooperative concurrency)的重点不再是通过共享作用域中的值进行交互，而是取到一个长期运行的进程，并将其分割成多个步骤或多批任务，使得其他并发进程有机会将自己的运算插入到事件循环队列中交替运行。

要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，可以异步地批处理这些结果，每次处理之后返回事件循环，让其他等待事件有机会运行。
```javascript
var res = []

function response(data) {
    // 一次处理 1000 个
    var chunk = data.splice(0, 1000);

    //  添加到已有的 res 组
    res = res.concat(
        chunk.map(function(val) {
            return val * 2;
        })
    )

    if (data.length > 0) {
        // 异步调度下一次批处理
        setTimeout(function() {
            response(data);
        }, 0)
    }
}
```
把数据集合放在最多包含 1000 条项目的块中，这样，我们就确保了进程运行时间会很短，即使这意味着需要更多的后续进程，因为事件循环队列的交替运行会提高站点／APP 的响应性能。

注意⚠️：这里使用 setTimeout(..0) 进行异步调度，表示的意思是把这个函数插入到当前事件循环队列的结尾处。

严格来说，setTimeout(..0) 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。

两个连续的 setTimeout(..0) 调用并不能保证会严格按照调用顺序处理，并入定时器漂移。

在 Node.js 中使用 process.nextTick(..) 来确保异步事件的顺序。


## 任务
在 ES6 中，有一个新概念建立在事件循环队列之上，叫做任务队列(job queue)。

任务队列是挂在事件循环队列的每个 tick 之后的一个队列。在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个任务。

注意⚠️：一个任务可能引起更多任务被添加到同一个队列末尾，所以，理论上说，任务循环(job loop)可能无限循环，进而导致程序的饿死，无法转移到下一个事件循环 tick。

任务和 setTimeout(..0) 的思路类似，但是其实现方式的定义更加良好，对顺序的保证性更强：尽可能早的将来。

注意：任务处理是在当前事件循环 tick 结尾处，且定时器触发是为了调度下一个事件循环 tick（如果可用的话）。


## 语句顺序
代码中语句的顺序和 JavaScript 引擎执行语句的顺序并不一定要一致。

使用断点和单步执行一行一行地遍历代码。

JavaScript 引擎可能会通过(安全地)重新安排这些语句的顺序有可能提高执行速度。

注意⚠️：代码编写的方式(从上到下的模式)和编译后执行的方式之间的联系非常脆弱。


## 总结
JavaScript 程序总是至少分为两个块：第一块现在运行，下一块将来运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前的累积的修改之上进行的。

一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。

任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。

并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。

通过需要对这些并发执行的进程进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些进程也可以通过把自身分割为更小的块，以便其他进程插入进来。

 
## 参考
[1] Kyle Simpson. You Don't Know JS