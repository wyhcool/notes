---
title: 运算符的优先级和结合性
date: 2019-04-23 21:34:15
tags:
categories:
- JavaScript
---

## 介绍
运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。

结合性决定了拥有相同优先级的运算符的执行顺序。

| 优先级 | 运算类型 | 结合性 | 运算符 |
| :-: | :- | :- | :- |
| 20 | 圆括号 | n/a | ( … ) |
| 19 | 点号成员访问 | 从左到右 | … . … |
|    | 方括号成员访问 | 从左到右 | … [ … ] |
|    | new (带参数列表) | n/a | new … ( … ) |
|    | 函数调用 | 从左到右 | … ( … ) |
| 18 | new (无参数列表) | 从右到左 | new … |
| 17 | 后置递增(运算符在后) | n/a | … ++ |
|    | 后置递减(运算符在后) |     | … -- |
| 16 | 逻辑非 | 从右到左 | ! … |
|    | 按位非 |        | ~ … |
|    | 一元加法 |       | + … |
|    | 一元减法 |       | - … |
|    | 前置递增 |       | ++ … |
|    | 前置递减 |       | -- … |
|    | typeof |       | typeof … |
|    | void |         | void … |
|    | delete |       | delete … |
|    | await |        | await … |
| 15 | 幂 | 从右到左 | … ** … |
| 14 | 乘法 | 从左到右 | … * … |
|    | 除法 |         | … / … |
|    | 取模 |         | … % … |
| 13 | 加法 | 从左到右 | … + … |
|    | 减法 |         | … - … |
| 12 | 按位左移 | 从左到右 | … << … |
|    | 按位右移 |         | … >> … |
|    | 无符号右移 |       | … >>> … |
| 11 | 小于 | 从左到右 | … < … |
|    | 小于等于 |     | … <= … |
|    | 大于 |        | … > … |
|    | 大于等于 |     | … >= … |
|    | in |          | … in … |
|    | instanceof |  | … instanceof … |
| 10 | 等号 | 从左到右 | … == … |
|    | 非等号 |       | … != … |
|    | 全等号 |       | … === … |
|    | 非全等号 |     | … !== … |
|  9 | 按位与 | 从左到右 | … & … |
|  8 | 按位异或 | 从左到右 | … ^ … |
|  7 | 按位或 | 从左到右 | … | … |
|  6 | 逻辑与 | 从左到右 | … && … |
|  5 | 逻辑或 | 从左到右 | … || … |
|  4 | 条件运算符 | 从右到左 | … ? … : … |
|  3 | 赋值 | 从右到左 | … = … |
|    |     |         | … += … |
|    |     |         | … -= … |
|    |     |         | … *= … |
|    |     |         | … /= … |
|    |     |         | … %= … |
|    |     |         | … <<= … |
|    |     |         | … >>= … |
|    |     |         | … >>>= … |
|    |     |         | … &= … |
|    |     |         | … ^= … |
|    |     |         | … |= … |
|  2 | yield | 从右到左 | yield … |
|    | yield* |        | yield* … | 
|  1 | 展开运算符 | n/a  | ... … |
|  0 | 逗号 | 从左到右 |  … , … |

## 问题
### 连续赋值问题
问题来自于周内分享。

```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

console.log(a.x);  //undefined
console.log(b.x);  //{n:2}
```

#### 赋值表达式
形如 A = B 的表达式称为赋值表达式。其中 A 和 B 又分别可以是表达式。B 可以是任意表达式，但是 A 必须是一个左值。

所谓左值，就是可以被赋值的表达式，在 ES 规范中是用内部类型引用(Reference)描述的。例如：

表达式 foo.bar 可以作为一个左值，表示对 foo 这个对象中 bar 这个名称的引用；

变量 email 可以作为一个左值，表示对当前执行环境中的环境记录项 envRec 中 email 这个名称的引用；

同样地，函数名 func 可以做左值，然而函数调用表达式 func(a, b) 不可以。

那么 JS 引擎是怎样计算一般的赋值表达式 A = B 的呢？简单地说，按如下步骤：

- 计算表达式 A，得到一个引用 refA；
- 计算表达式 B，得到一个值 valueB；
- 将 valueB 赋给 refA 指向的名称绑定；
- 返回 valueB。

#### 结合性
所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。

赋值表达式是右结合的。这意味着：Exp1 = Exp2 = Exp3 = Exp4 等价于 Exp1 = (Exp2 = (Exp3 = Exp4))。

#### 连等的解析
对于单个赋值运算，JS引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：
- 计算 Exp1，得到 Ref1；
- 计算 Exp2，得到 Ref2；
- 计算 Exp3，得到 Ref3；
- 计算 Exp4，得到 Value4。

得到中间过程：Ref1 = (Ref2 = (Ref3 = Value4))。

接下来的步骤是：
- 将 Value4 赋给 Ref3；
- 将 Value4 赋给 Ref2；
- 将 Value4 赋给 Ref1；
- 返回表达式最终的结果 Value4。

先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。

### 另一个连续赋值问题
```javascript
function foo(){
    var a = b = 5;
}
foo();

console.log(typeof a);  //"undefined"
console.log(typeof b);  //"number"
```

解析：变量 a 在 foo 作用域内，全局作用域未定义；变量 b 在 foo 作用域内未定义，溢出为全局变量。

### new new Foo().getName() 怎么理解
问题来自于 2019.04.23 的面试题。
```javascript
function Foo() {
    getName = function() {
        console.log(1);
    }
    return this;
}
 
Foo.getName = function() {
    console.log(2);
}
 
Foo.prototype.getName = function() {
    console.log(3);
}

var getName = function() {
    console.log(4);
}
 
function getName(){
    console.log(5);
}
 
Foo.getName();             //2
getName();                 //4
Foo().getName();           //1
getName();                 //1
new Foo.getName();         //2
new Foo().getName();       //3
new new Foo().getName();   //3
```

问题解析：
```javascript
/*
1.进入全局执行环境阶段，变量对象 VO = global = window，this 指向 window，作用域链被填充为[ window ]，所有的函数声明和变量声明将会被依次提升，以填充变量对象 VO。
VO = {
    Foo: <reference to FunctionDeclaration 'Foo'>,
    getName: <reference to FunctionDeclaration 'getName'>
}
注意：
(1) 所有函数声明(function declaration, FD) 使用函数对象的名称创建变量对象的属性，属性值为函数对象的引用，**如果变量对象中已存在相同名称的属性，则替换该属性和属性值**
(2) 所有变量声明(varibal declaration) 使用变量的名称创建变量对象的属性，属性值为undefined，**如果变量对象中已存在相同名称的属性(指向形式参数或函数对象)，则变量声明不会影响已存在的属性**
*/

/*
2.代码执行阶段
(1) Foo 函数对象增加成员方法 getName，指向一个匿名函数(设定其引用为 F2);
(2) Foo 的原型对象增加成员方法 getName，指向一个匿名函数(设定其引用为 F3)；
(3) getName 变量指向一个匿名函数(设定其引用为 F4)；
此时的变量对象被填充为：
VO = {
    Foo: <reference to FunctionDeclaration 'Foo'>,
    getName: <reference to F4>
}
*/

Foo.getName(); //2
/*
(4) 表达式中出现 . 点号成员访问运算符和 () 调用运算符，优先级相同，结合性均为自左向右。
标识符 Foo 在全局变量对象 VO 中已定义，查找其 getName 属性引用的是匿名函数 F2，再对该函数进行调用。
进入函数执行环境时，激活对象 AO = VO，this 指向 Foo 对象，作用域链被填充为 [AO, window]。
AO(annoymous func-F2) = {
    arguments: {
        callee: <reference to F2>
        length: 0
    }
}
函数执行完毕，激活对象激活对象销毁，作用域链移除。
*/

getName(); //4, 而不是 5
/*
(5) 标识符 getName 在 VO 中已定义，指向匿名函数 F4，再对该函数进行调用。
*/


Foo().getName(); //1
/*
(6) 调用 Foo 函数，进入函数执行环境时，生成激活对象 AO，this 指向 window 对象，作用域链被填充为[AO, window]。
AO(func-Foo) = {
    arguments: {
        callee: <reference to F2>
        length: 0
    }
}
代码执行阶段，查找 getName 标识符，在当前作用域中未定义，沿着作用域链查找，在 window 对象中已定义，此时全局作用域下的变量对象被修改为：
VO = {
    Foo: <reference to FunctionDeclaration 'Foo'>,
    getName: <reference to F1>
}
函数返回值为 window 对象，然后调用 window 对象的 getName 方法。
*/

getName(); //1
/*
(7) 调用 getName 函数，getName 标识符在全局作用域中已定义。
*/

new Foo.getName(); //2
/*
(8) 首先根据运算符优先级，new Foo.getName() = new (Foo.getName)()，即通过 new 来返回一个 Foo.getName 的实例。

当代码 new Foo(...) 执行时，会发生以下事情：
a. 一个继承自 Foo.prototype 的新对象被创建。
b. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。
c. 执行构造函数，由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）

*/
new Foo().getName();
/*
(9) 首先根据运算符优先级，new Foo().getName() = (new Foo()).getName()，即创建了一个 Foo 的实例，再调用该实例上的 getName 方法。
Foo 实例本身没有 getName 方法，因为其继承自 Foo.prototype，通过沿着原型链可查找到 getName 方法。
*/
new new Foo().getName();
/*
(10) 首先根据运算符优先级，new new Foo().getName() = new ((new Foo()).getName)()，即创建了一个 Foo 的实例，再创建一个以该实例的 getName 方法为构造函数的新实例。
*/
```

## 补充 C 语言运算符优先级和结合性

| 优先级 | 运算符 | 名称或含义 | 使用形式 | 结合方向 | 说明 |
|:-:    |:-:    |:-        |:-       |:-       |:-   | 
| 1     | []    | 数组下标   | 数组名[常量表达式] | 左到右 | |
|       | ()    | 圆括号     | (表达式), 函数名(形参表) | | |
|       | .     | 成员选择（对象）| 对象.成员名 | | |
|       | ->    | 成员选择（指针）| 对象指针->成员名 | | |
| 2     | -     | 负号运算符     | -表达式        | 右到左 | 单目运算符 |
|       | (类型) | 强制类型转换   | (数据类型)表达式 | | |
|       | ++    | 自增运算符     | ++变量名, 变量名++ | | 单目运算符 |
|       | --    | 自减运算符     | --变量名, 变量名-- | | 单目运算符 |
|       | *     | 取值运算符     | *指针变量         | | 单目运算符 |
|       | &     | 取地址运算符   | &变量名           | | 单目运算符 |
|       | !     | 逻辑非运算符   | !表达式           | | 单目运算符 |
|       | ~     | 按位取反运算符 | ~表达式           | | 单目运算符  |
|       | sizeof | 长度运算符   | sizeof(表达式)    | | |
| 3     | /     | 除 | 表达式 / 表达式 | 左到右 | 双目运算符 |
|       | *     | 乘 | 表达式 * 表达式 |       | 双目运算符 |
|       | %     | 余数（取模）| 整型表达式%整型表达式 | | 双目运算符 |
| 4     | +     | 加 | 表达式 + 表达式 | 左到右 | 双目运算符 |
|       | -     | 减 | 表达式 - 表达式 |       | 双目运算符 |
| 5     | <<    | 左移 | 变量 << 表达式  | 左到右 | 双目运算符 |
|       | >>    | 右移 | 变量 >> 表达式  |       | 双目运算符 |
| 6     | >     | 大于 |  表达式 > 表达式 | 左到右 | 双目运算符 |
|       | >=    | 大于等于 | 表达式 >= 表达式 |    | 双目运算符 |
|       | <     | 小于 | 表达式 < 表达式  |       | 双目运算符 |
|       | <=    | 小于等于 | 表达式 <= 表达式 |    | 双目运算符 |
| 7     | ==    | 等于 | 表达式 == 表达式 | 左到右 | 双目运算符 |
|       | !=    | 不等于 | 表达式 != 表达式 |     | 双目运算符 |
| 8     | &     | 按位与 | 表达式 & 表达式 | 左到右 | 双目运算符 |
| 9     | ^     | 按位异或 | 表达式 ^ 表达式 | 左到右 | 双目运算符 |
| 10    | |     | 按位或  | 表达式 | 表达式 | 左到右 | 双目运算符 |
| 11    | &&    | 逻辑与  | 表达式 && 表达式 | 左到右 | 双目运算符 |
| 12    | ||    | 逻辑或  | 表达式 || 表达式 | 左到右 | 双目运算符 |
| 13    | ?:    | 条件运算符 | 表达式1 ? 表达式2 : 表达式3 | 右到左 | 三目运算符 |
| 14    | =     | 赋值运算符 | 变量 = 表达式 | 右到左 | |
|       | /=    | 除后赋值   | 变量 /= 表达式 | | | 
|       | \*=   | 乘后赋值   | 变量 *= 表达式 | | | 
|       | %=    | 取模后赋值 | 变量 %= 表达式 | | |
|       | +=    | 加后赋值   | 变量 += 表达式 | | | 
|       | -=    | 减后赋值   | 变量 -= 表达式 | | | 
|       | <<=   | 左移后赋值 | 变量 <<= 表达式 | | |
|       | >>=   | 右移后赋值 | 变量>>=表达式 | | | 
|       | &=    | 按位与后赋值 | 变量 &= 表达式 | | |
|       | ^=    | 按位异或后赋值 | 变量 ^= 表达式 | | | 
|       | |=    | 按位或后赋值  | 变量 |= 表达式 | | |
| 15    | ,     | 逗号运算符   | 表达式,表达式,… | 左到右 | |

上表中可以总结出如下规律：
- 结合方向只有三个是从右往左，其余都是从左往右。
- 所有双目运算符中只有赋值运算符的结合方向是从右往左。
- 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。
- 有且只有一个三目运算符。
- 逗号运算符的优先级最低，要记住。
- 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。


口诀：
- 括号成员第一;        //括号运算符[]() 成员运算符.  ->
- 全体单目第二;        //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&乘除余三,加减四;   //这个"余"是指取余运算即%
- 移位五，关系六;       //移位运算符：<< >> ，关系：> < >= <= 等
- 等于(与)不等排第七;   //即== 和!=
- 位与异或和位或;       //这几个都是位运算: 位与(&)异或(^)位或(|)    
- "三分天下"八九十;  
- 逻辑或跟与;          //逻辑运算符:|| 和 &&
- 十二和十一;          //注意顺序:优先级(||)  底于 优先级(&&) 
- 条件高赋值,          //三目运算符优先级排到13 位只比赋值运算符和","高
- 逗号运算级最低!       //逗号运算符优先级最低 




## 参考
[1] https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

[2] https://segmentfault.com/a/1190000004224719