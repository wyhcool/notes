---
title: JS 浏览器事件循环
date: 2020-06-13 11:45:00
tags:
categories:
- JavaScript
---

## 浏览器内核
进程是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。

线程是进程的执行流，是 CPU 调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。

浏览器是多进程的，浏览器的每一个 tab 标签都代表一个独立的进程(多个空白的 tab 标签会合并成一个进程)，浏览器内核(浏览器渲染进程)是属于浏览器多进程中的一种。

浏览器内核有多种线程在工作：
- GUI 渲染线程：
  - 负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起的回流都会调起该线程。
  - 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作时，GUI 渲染线程会被挂起，GUI 更新被放入 JS 任务队列中，等待 JS 引擎线程空闲时继续执行。
- JS 引擎线程：
  - 单线程工作，负责解析运行 JavaScript 脚本。
  - 和 GUI 渲染线程互斥，JS 运行耗时过长时就会导致页面阻塞。
- 事件触发线程：
  - 当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。
- 定时器触发线程：
  - 浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。
  - 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。
- HTTP 请求线程：
  - http 请求的时候会开启一条请求线程。
  - 请求完成有结果之后，将请求的回调函数添加到任务队列的队尾，等待 JS 引擎处理。


## JavaScript 引擎是单线程
JavaScript 是单线程。单线程意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等待。


## JavaScript 事件循环机制
浏览器 Event Loop 是 HTML 中定义的规范。

JavaScript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。
- JS 调用栈。
  - JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。
- 同步任务、异步任务。JavaScript 单线程中的任务分为同步任务和异步任务。
  - 同步任务会在调用栈中按照顺序排序等待主线程执行，
  - 异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中，等待主线程空闲时，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。
- Event Loop。
  - 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。
- 定时器。
  - 定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。
  - 定时器指定的延时毫秒数其实并不准确，因为定时器只是到了指定的时间后将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成以后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。
- 宏任务(macro-task)和微任务(micro-task)
  - 除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。
  - macro-task 包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。
  - micro-task 包括：process.nextTick, Promise, Object.observe, MutationObserver。

```javascript
console.log(1)
setTimeout(function() {
    console.log(2);
})
var promise = new Promise(function(resolve, reject) {
    console.log(3);
    resolve();
})
promise.then(function() {
    console.log(4)
})
console.log(5)

// 1
// 3
// 5
// 4
// 2
```
其中，setTimeout 和 Promise 被称为任务源，来自不同的任务源注册的回调函数会被放入不同的任务队列中。

第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否存在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，在读取宏任务的任务队列中的所有任务，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。

setTimeout 语句，等到过了指定的时间后将回调函数放入到宏任务的任务队列中。

Promise 语句，执行函数体，将 then 函数放入到微任务的任务队列中。

当函数执行栈为空时，从任务队列取一个任务(函数)来执行。再次为空时，再取一个任务来执行，如此循环执行，这就是事件循环，即 Event Loop。

JS 主线程的函数执行时，遇到异步函数，交给指定的模块处理，然后继续执行同步代码。

异步函数达到触发条件，比如定时器到时、ajax 请求返回，那么把相应的回调处理，根据异步模块类型，压入指定的任务队列。
