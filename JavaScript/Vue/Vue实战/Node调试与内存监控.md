---
title: Node 调试与内存监控
date: 2023-07-02 15:02:00
tags:
categories:
- Vue
---

## Node 调试模式
启动 Node 调试模式：
```sh
# --inspect 参数是启动调试模式必需的
$ node --inspect app.js
```

有两种打开调试工具的方法：
- 第一种是在 Chrome 浏览器的地址栏，键入 `chrome://inspect` 或者 `about:inspect`
- 第二种是在 `http://127.0.0.1:3000` 的窗口打开"开发者工具"，顶部左上角有一个 Node 的绿色标志，点击就可以进入。

调试工具窗口就是"开发者工具"的定制版，省去了那些对服务器脚本没用的部分，它主要有四个面板：
- Console：控制台
- Memory：内存
- Profiler：性能
- Sources：源码


## vue-cli 调试
修改package.json，在scripts中增加一行配置 "debug": 

"node.exe --inspect-brk=9229 node_modules\\@vue\\cli-service\\bin\\vue-cli-service.js serve"


## Node 内存
Node 的存储分为堆和栈，栈中存储基本数据类型，堆中存放引用类型：对象。对于 Node 存储来说，堆内存是整个内存的主要占用。我们所关注的内存指标就是指堆内存的占用指标。

一般的后端语言几乎没有内存限制的问题。但是 Node 是基于 V8 引擎，在对象分配上遵从 V8 的方式，Node 通过 JavaScript 使用内存是有限制的，在 64 位系统最大内存为 `1.4G` 左右，32 位系统为 `0.7G` 左右。之所以有内存的限制，一方面 V8 的设计之初是用于浏览器使用，这个限制的值对于一般网页来说是足够的，更深层的原因是 V8 的垃圾回收机制。

当我们声明一个变量并赋值的时候，就会存放在 V8 申请的堆内存中，当堆内存不够会继续申请内存，知道达到内存的限制。如果超出限制，那么就会出现内存泄漏的现象，出现卡顿等现象；这里的内存指标是最方便去量化的，通过 Node 提供 `process.memoryUsage()` 即可查看与了解。

### 垃圾回收
V8 垃圾回收的基础是先将内存进行分代；在 V8 中按照对象存活的时间将内存的进行分代。存活时间短（可立即回收的变量）的放入新生代，常驻内存（全局变量、无法立即去回收的变量）放入老生代；

v8内存空间 = 新生代占用内存空间 + 老生代占用内存空间；

Node 也提供了扩宽内存的方法，在启动 Node 的时候，可以通过传递 `–max-old-space-size` 和 `--max-new-space-size` 来调整内存的大小，这两个对应扩充的值就是上面提到的老生代内存与新生代的内存值，这个调整一旦启动，就不可更改，除非再次启动。在 V8 内存受限制的时候，可以按照这个值进行放宽：
```sh
$ node --max-old-space-size=1800 server.js // 1800Mb
```
目前的 Node 使用的是 scavenge 算法，它基于复制的方式实现垃圾回收，这在一定的程度是有对内存资源的浪费存在；代码开发过程中，也可以按需使用 `global.gc()` 去主动触发垃圾回收，如果主动触发之后，查询 heapUsed 并没有下降，可以考虑是内存泄漏的存在了。

### 内存泄漏分析
如果堆内存达到了堆内存的指标，无法再为新的变量/对象进行申请新内存的时候就是出现内存泄漏的现象了。老生代的常驻内存是不会被 V8 回收的，即使是手动触发。代码中常见的几项不会被垃圾立即回收，积累过多会造成内存泄漏隐患：
- 全局变量引用
- 闭包作用域内变量
- 模块的缓存


## 参考
[1] https://www.ruanyifeng.com/blog/2018/03/node-debugger.html

[2] https://blog.csdn.net/connie_0217/article/details/122239759

[3] https://blog.csdn.net/Tencent_TEG/article/details/108138254